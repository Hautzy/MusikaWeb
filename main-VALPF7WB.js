var n6=Object.create;var Cg=Object.defineProperty,r6=Object.defineProperties,o6=Object.getOwnPropertyDescriptor,s6=Object.getOwnPropertyDescriptors,i6=Object.getOwnPropertyNames,Y1=Object.getOwnPropertySymbols,a6=Object.getPrototypeOf,Q1=Object.prototype.hasOwnProperty,l6=Object.prototype.propertyIsEnumerable;var Z1=(n,t,e)=>t in n?Cg(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,Te=(n,t)=>{for(var e in t||={})Q1.call(t,e)&&Z1(n,e,t[e]);if(Y1)for(var e of Y1(t))l6.call(t,e)&&Z1(n,e,t[e]);return n},dn=(n,t)=>r6(n,s6(t));var so=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),yt=(n,t)=>{for(var e in t)Cg(n,e,{get:t[e],enumerable:!0})},u6=(n,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of i6(t))!Q1.call(n,o)&&o!==e&&Cg(n,o,{get:()=>t[o],enumerable:!(r=o6(t,o))||r.enumerable});return n};var gh=(n,t,e)=>(e=n!=null?n6(a6(n)):{},u6(t||!n||!n.__esModule?Cg(e,"default",{value:n,enumerable:!0}):e,n));var z=(n,t,e)=>new Promise((r,o)=>{var s=l=>{try{a(e.next(l))}catch(u){o(u)}},i=l=>{try{a(e.throw(l))}catch(u){o(u)}},a=l=>l.done?r(l.value):Promise.resolve(l.value).then(s,i);a((e=e.apply(n,t)).next())});var Q_=so(($Ce,Z_)=>{"use strict";Z_.exports=Wt;var ho=null;try{ho=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Wt(n,t,e){this.low=n|0,this.high=t|0,this.unsigned=!!e}Wt.prototype.__isLong__;Object.defineProperty(Wt.prototype,"__isLong__",{value:!0});function _r(n){return(n&&n.__isLong__)===!0}Wt.isLong=_r;var U_={},G_={};function Ku(n,t){var e,r,o;return t?(n>>>=0,(o=0<=n&&n<256)&&(r=G_[n],r)?r:(e=jt(n,(n|0)<0?-1:0,!0),o&&(G_[n]=e),e)):(n|=0,(o=-128<=n&&n<128)&&(r=U_[n],r)?r:(e=jt(n,n<0?-1:0,!1),o&&(U_[n]=e),e))}Wt.fromInt=Ku;function mo(n,t){if(isNaN(n))return t?qu:go;if(t){if(n<0)return qu;if(n>=q_)return Y_}else{if(n<=-j_)return Rr;if(n+1>=j_)return X_}return n<0?mo(-n,t).neg():jt(n%Uf|0,n/Uf|0,t)}Wt.fromNumber=mo;function jt(n,t,e){return new Wt(n,t,e)}Wt.fromBits=jt;var ex=Math.pow;function cT(n,t,e){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return go;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return cT(n.substring(1),t,e).neg();for(var o=mo(ex(e,8)),s=go,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),l=parseInt(n.substring(i,i+a),e);if(a<8){var u=mo(ex(e,a));s=s.mul(u).add(mo(l))}else s=s.mul(o),s=s.add(mo(l))}return s.unsigned=t,s}Wt.fromString=cT;function Wo(n,t){return typeof n=="number"?mo(n,t):typeof n=="string"?cT(n,t):jt(n.low,n.high,typeof t=="boolean"?t:n.unsigned)}Wt.fromValue=Wo;var W_=65536,UX=1<<24,Uf=W_*W_,q_=Uf*Uf,j_=q_/2,H_=Ku(UX),go=Ku(0);Wt.ZERO=go;var qu=Ku(0,!0);Wt.UZERO=qu;var Vf=Ku(1);Wt.ONE=Vf;var K_=Ku(1,!0);Wt.UONE=K_;var uT=Ku(-1);Wt.NEG_ONE=uT;var X_=jt(-1,2147483647,!1);Wt.MAX_VALUE=X_;var Y_=jt(-1,-1,!0);Wt.MAX_UNSIGNED_VALUE=Y_;var Rr=jt(0,-2147483648,!1);Wt.MIN_VALUE=Rr;var ce=Wt.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low};ce.toNumber=function(){return this.unsigned?(this.high>>>0)*Uf+(this.low>>>0):this.high*Uf+(this.low>>>0)};ce.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Rr)){var e=mo(t),r=this.div(e),o=r.mul(e).sub(this);return r.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=mo(ex(t,6),this.unsigned),i=this,a="";;){var l=i.div(s),u=i.sub(l.mul(s)).toInt()>>>0,c=u.toString(t);if(i=l,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};ce.getHighBits=function(){return this.high};ce.getHighBitsUnsigned=function(){return this.high>>>0};ce.getLowBits=function(){return this.low};ce.getLowBitsUnsigned=function(){return this.low>>>0};ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Rr)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return this.high!=0?e+33:e+1};ce.isZero=function(){return this.high===0&&this.low===0};ce.eqz=ce.isZero;ce.isNegative=function(){return!this.unsigned&&this.high<0};ce.isPositive=function(){return this.unsigned||this.high>=0};ce.isOdd=function(){return(this.low&1)===1};ce.isEven=function(){return(this.low&1)===0};ce.equals=function(t){return _r(t)||(t=Wo(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};ce.eq=ce.equals;ce.notEquals=function(t){return!this.eq(t)};ce.neq=ce.notEquals;ce.ne=ce.notEquals;ce.lessThan=function(t){return this.comp(t)<0};ce.lt=ce.lessThan;ce.lessThanOrEqual=function(t){return this.comp(t)<=0};ce.lte=ce.lessThanOrEqual;ce.le=ce.lessThanOrEqual;ce.greaterThan=function(t){return this.comp(t)>0};ce.gt=ce.greaterThan;ce.greaterThanOrEqual=function(t){return this.comp(t)>=0};ce.gte=ce.greaterThanOrEqual;ce.ge=ce.greaterThanOrEqual;ce.compare=function(t){if(_r(t)||(t=Wo(t)),this.eq(t))return 0;var e=this.isNegative(),r=t.isNegative();return e&&!r?-1:!e&&r?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};ce.comp=ce.compare;ce.negate=function(){return!this.unsigned&&this.eq(Rr)?Rr:this.not().add(Vf)};ce.neg=ce.negate;ce.add=function(t){_r(t)||(t=Wo(t));var e=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,p=0,f=0,d=0;return d+=s+u,f+=d>>>16,d&=65535,f+=o+l,p+=f>>>16,f&=65535,p+=r+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,jt(f<<16|d,c<<16|p,this.unsigned)};ce.subtract=function(t){return _r(t)||(t=Wo(t)),this.add(t.neg())};ce.sub=ce.subtract;ce.multiply=function(t){if(this.isZero())return go;if(_r(t)||(t=Wo(t)),ho){var e=ho.mul(this.low,this.high,t.low,t.high);return jt(e,ho.get_high(),this.unsigned)}if(t.isZero())return go;if(this.eq(Rr))return t.isOdd()?Rr:go;if(t.eq(Rr))return this.isOdd()?Rr:go;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(H_)&&t.lt(H_))return mo(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,p=0,f=0,d=0,h=0;return h+=i*c,d+=h>>>16,h&=65535,d+=s*c,f+=d>>>16,d&=65535,d+=i*u,f+=d>>>16,d&=65535,f+=o*c,p+=f>>>16,f&=65535,f+=s*u,p+=f>>>16,f&=65535,f+=i*l,p+=f>>>16,f&=65535,p+=r*c+o*u+s*l+i*a,p&=65535,jt(d<<16|h,p<<16|f,this.unsigned)};ce.mul=ce.multiply;ce.divide=function(t){if(_r(t)||(t=Wo(t)),t.isZero())throw Error("division by zero");if(ho){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?ho.div_u:ho.div_s)(this.low,this.high,t.low,t.high);return jt(e,ho.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?qu:go;var r,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return qu;if(t.gt(this.shru(1)))return K_;s=qu}else{if(this.eq(Rr)){if(t.eq(Vf)||t.eq(uT))return Rr;if(t.eq(Rr))return Vf;var i=this.shr(1);return r=i.div(t).shl(1),r.eq(go)?t.isNegative()?Vf:uT:(o=this.sub(t.mul(r)),s=r.add(o.div(t)),s)}else if(t.eq(Rr))return this.unsigned?qu:go;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=go}for(o=this;o.gte(t);){r=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:ex(2,a-48),u=mo(r),c=u.mul(t);c.isNegative()||c.gt(o);)r-=l,u=mo(r,this.unsigned),c=u.mul(t);u.isZero()&&(u=Vf),s=s.add(u),o=o.sub(c)}return s};ce.div=ce.divide;ce.modulo=function(t){if(_r(t)||(t=Wo(t)),ho){var e=(this.unsigned?ho.rem_u:ho.rem_s)(this.low,this.high,t.low,t.high);return jt(e,ho.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};ce.mod=ce.modulo;ce.rem=ce.modulo;ce.not=function(){return jt(~this.low,~this.high,this.unsigned)};ce.and=function(t){return _r(t)||(t=Wo(t)),jt(this.low&t.low,this.high&t.high,this.unsigned)};ce.or=function(t){return _r(t)||(t=Wo(t)),jt(this.low|t.low,this.high|t.high,this.unsigned)};ce.xor=function(t){return _r(t)||(t=Wo(t)),jt(this.low^t.low,this.high^t.high,this.unsigned)};ce.shiftLeft=function(t){return _r(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?jt(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):jt(0,this.low<<t-32,this.unsigned)};ce.shl=ce.shiftLeft;ce.shiftRight=function(t){return _r(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?jt(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):jt(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};ce.shr=ce.shiftRight;ce.shiftRightUnsigned=function(t){if(_r(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var r=this.low;return jt(r>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?jt(e,0,this.unsigned):jt(e>>>t-32,0,this.unsigned)};ce.shru=ce.shiftRightUnsigned;ce.shr_u=ce.shiftRightUnsigned;ce.toSigned=function(){return this.unsigned?jt(this.low,this.high,!1):this};ce.toUnsigned=function(){return this.unsigned?this:jt(this.low,this.high,!0)};ce.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};ce.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};ce.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Wt.fromBytes=function(t,e,r){return r?Wt.fromBytesLE(t,e):Wt.fromBytesBE(t,e)};Wt.fromBytesLE=function(t,e){return new Wt(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Wt.fromBytesBE=function(t,e){return new Wt(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var U2=so((Yf,V2)=>{"use strict";var DY=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},rc=DY();V2.exports=Yf=rc.fetch;rc.fetch&&(Yf.default=rc.fetch.bind(rc));Yf.Headers=rc.Headers;Yf.Request=rc.Request;Yf.Response=rc.Response});var G2=so(()=>{"use strict"});var xO=so((yO,PT)=>{"use strict";(function(n,t,e){function r(a){var l=this,u=i();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(a),l.s0<0&&(l.s0+=1),l.s1-=u(a),l.s1<0&&(l.s1+=1),l.s2-=u(a),l.s2<0&&(l.s2+=1),u=null}function o(a,l){return l.c=a.c,l.s0=a.s0,l.s1=a.s1,l.s2=a.s2,l}function s(a,l){var u=new r(a),c=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,u),p.state=function(){return o(u,{})}),p}function i(){var a=4022871197,l=function(u){u=String(u);for(var c=0;c<u.length;c++){a+=u.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(yO,typeof PT=="object"&&PT,typeof define=="function"&&define)});var vO=so((bO,LT)=>{"use strict";(function(n,t,e){function r(i){var a=this,l="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(bO,typeof LT=="object"&&LT,typeof define=="function"&&define)});var CO=so((wO,BT)=>{"use strict";(function(n,t,e){function r(i){var a=this,l="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:l+=i;for(var u=0;u<l.length+64;u++)a.x^=l.charCodeAt(u)|0,u==l.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(wO,typeof BT=="object"&&BT,typeof define=="function"&&define)});var SO=so((IO,zT)=>{"use strict";(function(n,t,e){function r(i){var a=this;a.next=function(){var u=a.x,c=a.i,p,f,d;return p=u[c],p^=p>>>7,f=p^p<<24,p=u[c+1&7],f^=p^p>>>10,p=u[c+3&7],f^=p^p>>>3,p=u[c+4&7],f^=p^p<<7,p=u[c+7&7],p=p^p<<13,f^=p^p<<9,u[c]=f,a.i=c+1&7,f};function l(u,c){var p,f,d=[];if(c===(c|0))f=d[0]=c;else for(c=""+c,p=0;p<c.length;++p)d[p&7]=d[p&7]<<15^c.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8?f=d[7]=-1:f=d[p],u.x=d,u.i=0,p=256;p>0;--p)u.next()}l(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(u.x&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(IO,typeof zT=="object"&&zT,typeof define=="function"&&define)});var NO=so((TO,VT)=>{"use strict";(function(n,t,e){function r(i){var a=this;a.next=function(){var u=a.w,c=a.X,p=a.i,f,d;return a.w=u=u+1640531527|0,d=c[p+34&127],f=c[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,d=c[p]=d^f,a.i=p,d+(u^u>>>16)|0};function l(u,c){var p,f,d,h,g,m=[],y=128;for(c===(c|0)?(f=c,c=null):(c=c+"\0",f=0,y=Math.max(y,c.length)),d=0,h=-32;h<y;++h)c&&(f^=c.charCodeAt((h+32)%c.length)),h===0&&(g=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,h>=0&&(g=g+1640531527|0,p=m[h&127]^=f+g,d=p==0?d+1:0);for(d>=128&&(m[(c&&c.length||0)&127]=-1),d=127,h=4*128;h>0;--h)f=m[d+34&127],p=m[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,m[d]=f^p;u.w=g,u.X=m,u.i=d}l(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(u.X&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(TO,typeof VT=="object"&&VT,typeof define=="function"&&define)});var DO=so((EO,UT)=>{"use strict";(function(n,t,e){function r(i){var a=this,l="";a.next=function(){var c=a.b,p=a.c,f=a.d,d=a.a;return c=c<<25^c>>>7^p,p=p-f|0,f=f<<24^f>>>8^d,d=d-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-f|0,a.d=f<<16^p>>>16^d,a.a=d-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):l+=i;for(var u=0;u<l.length+20;u++)a.b^=l.charCodeAt(u)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var l=new r(i),u=a&&a.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},c.int32=l.next,c.quick=c,u&&(typeof u=="object"&&o(u,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(EO,typeof UT=="object"&&UT,typeof define=="function"&&define)});var kO=so(()=>{"use strict"});var RO=so((AO,nb)=>{"use strict";(function(n,t,e){var r=256,o=6,s=52,i="random",a=e.pow(r,o),l=e.pow(2,s),u=l*2,c=r-1,p;function f(v,w,S){var k=[];w=w==!0?{entropy:!0}:w||{};var A=m(g(w.entropy?[v,x(t)]:v??y(),3),k),_=new d(k),F=function(){for(var $=_.g(o),V=a,U=0;$<l;)$=($+U)*r,V*=r,U=_.g(1);for(;$>=u;)$/=2,V/=2,U>>>=1;return($+U)/V};return F.int32=function(){return _.g(4)|0},F.quick=function(){return _.g(4)/4294967296},F.double=F,m(x(_.S),t),(w.pass||S||function($,V,U,W){return W&&(W.S&&h(W,_),$.state=function(){return h(_,{})}),U?(e[i]=$,V):$})(F,A,"global"in w?w.global:this==e,w.state)}function d(v){var w,S=v.length,k=this,A=0,_=k.i=k.j=0,F=k.S=[];for(S||(v=[S++]);A<r;)F[A]=A++;for(A=0;A<r;A++)F[A]=F[_=c&_+v[A%S]+(w=F[A])],F[_]=w;(k.g=function($){for(var V,U=0,W=k.i,G=k.j,H=k.S;$--;)V=H[W=c&W+1],U=U*r+H[c&(H[W]=H[G=c&G+V])+(H[G]=V)];return k.i=W,k.j=G,U})(r)}function h(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function g(v,w){var S=[],k=typeof v,A;if(w&&k=="object")for(A in v)try{S.push(g(v[A],w-1))}catch{}return S.length?S:k=="string"?v:v+"\0"}function m(v,w){for(var S=v+"",k,A=0;A<S.length;)w[c&A]=c&(k^=w[c&A]*19)+S.charCodeAt(A++);return x(w)}function y(){try{var v;return p&&(v=p.randomBytes)?v=v(r):(v=new Uint8Array(r),(n.crypto||n.msCrypto).getRandomValues(v)),x(v)}catch{var w=n.navigator,S=w&&w.plugins;return[+new Date,n,S,n.screen,x(t)]}}function x(v){return String.fromCharCode.apply(0,v)}if(m(e.random(),t),typeof nb=="object"&&nb.exports){nb.exports=f;try{p=kO()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):e["seed"+i]=f})(typeof self<"u"?self:AO,[],Math)});var Tm=so((C$e,_O)=>{"use strict";var dJ=xO(),hJ=vO(),mJ=CO(),gJ=SO(),yJ=NO(),xJ=DO(),cc=RO();cc.alea=dJ;cc.xor128=hJ;cc.xorwow=mJ;cc.xorshift7=gJ;cc.xor4096=yJ;cc.tychei=xJ;_O.exports=cc});var QC=null;var ZC=1,J1=Symbol("SIGNAL");function xt(n){let t=QC;return QC=n,t}function eD(){return QC}var JC={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function c6(n){if(!(o0(n)&&!n.dirty)&&!(!n.dirty&&n.lastCleanEpoch===ZC)){if(!n.producerMustRecompute(n)&&!t0(n)){n.dirty=!1,n.lastCleanEpoch=ZC;return}n.producerRecomputeValue(n),n.dirty=!1,n.lastCleanEpoch=ZC}}function e0(n){return n&&(n.nextProducerIndex=0),xt(n)}function tD(n,t){if(xt(t),!(!n||n.producerNode===void 0||n.producerIndexOfThis===void 0||n.producerLastReadVersion===void 0)){if(o0(n))for(let e=n.nextProducerIndex;e<n.producerNode.length;e++)r0(n.producerNode[e],n.producerIndexOfThis[e]);for(;n.producerNode.length>n.nextProducerIndex;)n.producerNode.pop(),n.producerLastReadVersion.pop(),n.producerIndexOfThis.pop()}}function t0(n){s0(n);for(let t=0;t<n.producerNode.length;t++){let e=n.producerNode[t],r=n.producerLastReadVersion[t];if(r!==e.version||(c6(e),r!==e.version))return!0}return!1}function n0(n){if(s0(n),o0(n))for(let t=0;t<n.producerNode.length;t++)r0(n.producerNode[t],n.producerIndexOfThis[t]);n.producerNode.length=n.producerLastReadVersion.length=n.producerIndexOfThis.length=0,n.liveConsumerNode&&(n.liveConsumerNode.length=n.liveConsumerIndexOfThis.length=0)}function r0(n,t){if(p6(n),n.liveConsumerNode.length===1&&f6(n))for(let r=0;r<n.producerNode.length;r++)r0(n.producerNode[r],n.producerIndexOfThis[r]);let e=n.liveConsumerNode.length-1;if(n.liveConsumerNode[t]=n.liveConsumerNode[e],n.liveConsumerIndexOfThis[t]=n.liveConsumerIndexOfThis[e],n.liveConsumerNode.length--,n.liveConsumerIndexOfThis.length--,t<n.liveConsumerNode.length){let r=n.liveConsumerIndexOfThis[t],o=n.liveConsumerNode[t];s0(o),o.producerIndexOfThis[r]=t}}function o0(n){return n.consumerIsAlwaysLive||(n?.liveConsumerNode?.length??0)>0}function s0(n){n.producerNode??=[],n.producerIndexOfThis??=[],n.producerLastReadVersion??=[]}function p6(n){n.liveConsumerNode??=[],n.liveConsumerIndexOfThis??=[]}function f6(n){return n.producerNode!==void 0}function d6(){throw new Error}var h6=d6;function nD(n){h6=n}function Ue(n){return typeof n=="function"}function Vc(n){let e=n(r=>{Error.call(r),r.stack=new Error().stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}var Ig=Vc(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:
${e.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=e});function yh(n,t){if(n){let e=n.indexOf(t);0<=e&&n.splice(e,1)}}var gn=class n{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;let{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(let s of e)s.remove(this);else e.remove(this);let{initialTeardown:r}=this;if(Ue(r))try{r()}catch(s){t=s instanceof Ig?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{rD(s)}catch(i){t=t??[],i instanceof Ig?t=[...t,...i.errors]:t.push(i)}}if(t)throw new Ig(t)}}add(t){var e;if(t&&t!==this)if(this.closed)rD(t);else{if(t instanceof n){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=(e=this._finalizers)!==null&&e!==void 0?e:[]).push(t)}}_hasParent(t){let{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){let{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){let{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&yh(e,t)}remove(t){let{_finalizers:e}=this;e&&yh(e,t),t instanceof n&&t._removeParent(this)}};gn.EMPTY=(()=>{let n=new gn;return n.closed=!0,n})();var i0=gn.EMPTY;function Sg(n){return n instanceof gn||n&&"closed"in n&&Ue(n.remove)&&Ue(n.add)&&Ue(n.unsubscribe)}function rD(n){Ue(n)?n():n.unsubscribe()}var Fo={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var Uc={setTimeout(n,t,...e){let{delegate:r}=Uc;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){let{delegate:t}=Uc;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Tg(n){Uc.setTimeout(()=>{let{onUnhandledError:t}=Fo;if(t)t(n);else throw n})}function xh(){}var oD=a0("C",void 0,void 0);function sD(n){return a0("E",void 0,n)}function iD(n){return a0("N",n,void 0)}function a0(n,t,e){return{kind:n,value:t,error:e}}var su=null;function Gc(n){if(Fo.useDeprecatedSynchronousErrorHandling){let t=!su;if(t&&(su={errorThrown:!1,error:null}),n(),t){let{errorThrown:e,error:r}=su;if(su=null,e)throw r}}else n()}function aD(n){Fo.useDeprecatedSynchronousErrorHandling&&su&&(su.errorThrown=!0,su.error=n)}var iu=class extends gn{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Sg(t)&&t.add(this)):this.destination=y6}static create(t,e,r){return new Wc(t,e,r)}next(t){this.isStopped?u0(iD(t),this):this._next(t)}error(t){this.isStopped?u0(sD(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?u0(oD,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},m6=Function.prototype.bind;function l0(n,t){return m6.call(n,t)}var c0=class{constructor(t){this.partialObserver=t}next(t){let{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Ng(r)}}error(t){let{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Ng(r)}else Ng(t)}complete(){let{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Ng(e)}}},Wc=class extends iu{constructor(t,e,r){super();let o;if(Ue(t)||!t)o={next:t??void 0,error:e??void 0,complete:r??void 0};else{let s;this&&Fo.useDeprecatedNextContext?(s=Object.create(t),s.unsubscribe=()=>this.unsubscribe(),o={next:t.next&&l0(t.next,s),error:t.error&&l0(t.error,s),complete:t.complete&&l0(t.complete,s)}):o=t}this.destination=new c0(o)}};function Ng(n){Fo.useDeprecatedSynchronousErrorHandling?aD(n):Tg(n)}function g6(n){throw n}function u0(n,t){let{onStoppedNotification:e}=Fo;e&&Uc.setTimeout(()=>e(n,t))}var y6={closed:!0,next:xh,error:g6,complete:xh};var jc=typeof Symbol=="function"&&Symbol.observable||"@@observable";function Hr(n){return n}function p0(...n){return f0(n)}function f0(n){return n.length===0?Hr:n.length===1?n[0]:function(e){return n.reduce((r,o)=>o(r),e)}}var Dt=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){let r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,o){let s=b6(e)?e:new Wc(e,r,o);return Gc(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return r=lD(r),new r((o,s)=>{let i=new Wc({next:a=>{try{e(a)}catch(l){s(l),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(e){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(e)}[jc](){return this}pipe(...e){return f0(e)(this)}toPromise(e){return e=lD(e),new e((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return n.create=t=>new n(t),n})();function lD(n){var t;return(t=n??Fo.Promise)!==null&&t!==void 0?t:Promise}function x6(n){return n&&Ue(n.next)&&Ue(n.error)&&Ue(n.complete)}function b6(n){return n&&n instanceof iu||x6(n)&&Sg(n)}function d0(n){return Ue(n?.lift)}function lt(n){return t=>{if(d0(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function ut(n,t,e,r,o){return new h0(n,t,e,r,o)}var h0=class extends iu{constructor(t,e,r,o,s,i){super(t),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=o?function(a){try{o(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:e}=this;super.unsubscribe(),!e&&((t=this.onFinalize)===null||t===void 0||t.call(this))}}};function Hc(){return lt((n,t)=>{let e=null;n._refCount++;let r=ut(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount){e=null;return}let o=n._connection,s=e;e=null,o&&(!s||o===s)&&o.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}var qc=class extends Dt{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,d0(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){let t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;let{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new gn;let e=this.getSubject();t.add(this.source.subscribe(ut(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=gn.EMPTY)}return t}refCount(){return Hc()(this)}};var uD=Vc(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var mr=(()=>{class n extends Dt{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){let r=new Eg(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new uD}next(e){Gc(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(e)}})}error(e){Gc(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;let{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Gc(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return((e=this.observers)===null||e===void 0?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){let{hasError:r,isStopped:o,observers:s}=this;return r||o?i0:(this.currentObservers=null,s.push(e),new gn(()=>{this.currentObservers=null,yh(s,e)}))}_checkFinalizedStatuses(e){let{hasError:r,thrownError:o,isStopped:s}=this;r?e.error(o):s&&e.complete()}asObservable(){let e=new Dt;return e.source=this,e}}return n.create=(t,e)=>new Eg(t,e),n})(),Eg=class extends mr{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.next)===null||r===void 0||r.call(e,t)}error(t){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.error)===null||r===void 0||r.call(e,t)}complete(){var t,e;(e=(t=this.destination)===null||t===void 0?void 0:t.complete)===null||e===void 0||e.call(t)}_subscribe(t){var e,r;return(r=(e=this.source)===null||e===void 0?void 0:e.subscribe(t))!==null&&r!==void 0?r:i0}};var jn=class extends mr{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){let e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){let{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}};var qr=new Dt(n=>n.complete());function cD(n){return n&&Ue(n.schedule)}function pD(n){return n[n.length-1]}function fD(n){return Ue(pD(n))?n.pop():void 0}function va(n){return cD(pD(n))?n.pop():void 0}function hD(n,t,e,r){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(c){try{u(r.next(c))}catch(p){i(p)}}function l(c){try{u(r.throw(c))}catch(p){i(p)}}function u(c){c.done?s(c.value):o(c.value).then(a,l)}u((r=r.apply(n,t||[])).next())})}function dD(n){var t=typeof Symbol=="function"&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function au(n){return this instanceof au?(this.v=n,this):new au(n)}function mD(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=e.apply(n,t||[]),o,s=[];return o={},a("next"),a("throw"),a("return",i),o[Symbol.asyncIterator]=function(){return this},o;function i(d){return function(h){return Promise.resolve(h).then(d,p)}}function a(d,h){r[d]&&(o[d]=function(g){return new Promise(function(m,y){s.push([d,g,m,y])>1||l(d,g)})},h&&(o[d]=h(o[d])))}function l(d,h){try{u(r[d](h))}catch(g){f(s[0][3],g)}}function u(d){d.value instanceof au?Promise.resolve(d.value.v).then(c,p):f(s[0][2],d)}function c(d){l("next",d)}function p(d){l("throw",d)}function f(d,h){d(h),s.shift(),s.length&&l(s[0][0],s[0][1])}}function gD(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t=n[Symbol.asyncIterator],e;return t?t.call(n):(n=typeof dD=="function"?dD(n):n[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(s){e[s]=n[s]&&function(i){return new Promise(function(a,l){i=n[s](i),o(a,l,i.done,i.value)})}}function o(s,i,a,l){Promise.resolve(l).then(function(u){s({value:u,done:a})},i)}}var Dg=n=>n&&typeof n.length=="number"&&typeof n!="function";function kg(n){return Ue(n?.then)}function Ag(n){return Ue(n[jc])}function Rg(n){return Symbol.asyncIterator&&Ue(n?.[Symbol.asyncIterator])}function _g(n){return new TypeError(`You provided ${n!==null&&typeof n=="object"?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}function v6(){return typeof Symbol!="function"||!Symbol.iterator?"@@iterator":Symbol.iterator}var Og=v6();function Mg(n){return Ue(n?.[Og])}function Fg(n){return mD(this,arguments,function*(){let e=n.getReader();try{for(;;){let{value:r,done:o}=yield au(e.read());if(o)return yield au(void 0);yield yield au(r)}}finally{e.releaseLock()}})}function $g(n){return Ue(n?.getReader)}function $n(n){if(n instanceof Dt)return n;if(n!=null){if(Ag(n))return w6(n);if(Dg(n))return C6(n);if(kg(n))return I6(n);if(Rg(n))return yD(n);if(Mg(n))return S6(n);if($g(n))return T6(n)}throw _g(n)}function w6(n){return new Dt(t=>{let e=n[jc]();if(Ue(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}function C6(n){return new Dt(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}function I6(n){return new Dt(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Tg)})}function S6(n){return new Dt(t=>{for(let e of n)if(t.next(e),t.closed)return;t.complete()})}function yD(n){return new Dt(t=>{N6(n,t).catch(e=>t.error(e))})}function T6(n){return yD(Fg(n))}function N6(n,t){var e,r,o,s;return hD(this,void 0,void 0,function*(){try{for(e=gD(n);r=yield e.next(),!r.done;){let i=r.value;if(t.next(i),t.closed)return}}catch(i){o={error:i}}finally{try{r&&!r.done&&(s=e.return)&&(yield s.call(e))}finally{if(o)throw o.error}}t.complete()})}function Dr(n,t,e,r=0,o=!1){let s=t.schedule(function(){e(),o?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(s),!o)return s}function Pg(n,t=0){return lt((e,r)=>{e.subscribe(ut(r,o=>Dr(r,n,()=>r.next(o),t),()=>Dr(r,n,()=>r.complete(),t),o=>Dr(r,n,()=>r.error(o),t)))})}function Lg(n,t=0){return lt((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function xD(n,t){return $n(n).pipe(Lg(t),Pg(t))}function bD(n,t){return $n(n).pipe(Lg(t),Pg(t))}function vD(n,t){return new Dt(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}function wD(n,t){return new Dt(e=>{let r;return Dr(e,t,()=>{r=n[Og](),Dr(e,t,()=>{let o,s;try{({value:o,done:s}=r.next())}catch(i){e.error(i);return}s?e.complete():e.next(o)},0,!0)}),()=>Ue(r?.return)&&r.return()})}function Bg(n,t){if(!n)throw new Error("Iterable cannot be null");return new Dt(e=>{Dr(e,t,()=>{let r=n[Symbol.asyncIterator]();Dr(e,t,()=>{r.next().then(o=>{o.done?e.complete():e.next(o.value)})},0,!0)})})}function CD(n,t){return Bg(Fg(n),t)}function ID(n,t){if(n!=null){if(Ag(n))return xD(n,t);if(Dg(n))return vD(n,t);if(kg(n))return bD(n,t);if(Rg(n))return Bg(n,t);if(Mg(n))return wD(n,t);if($g(n))return CD(n,t)}throw _g(n)}function Nn(n,t){return t?ID(n,t):$n(n)}function We(...n){let t=va(n);return Nn(n,t)}function Kc(n,t){let e=Ue(n)?n:()=>n,r=o=>o.error(e());return new Dt(t?o=>t.schedule(r,0,o):r)}function m0(n){return!!n&&(n instanceof Dt||Ue(n.lift)&&Ue(n.subscribe))}var Ws=Vc(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"});function st(n,t){return lt((e,r)=>{let o=0;e.subscribe(ut(r,s=>{r.next(n.call(t,s,o++))}))})}var{isArray:E6}=Array;function D6(n,t){return E6(t)?n(...t):n(t)}function SD(n){return st(t=>D6(n,t))}var{isArray:k6}=Array,{getPrototypeOf:A6,prototype:R6,keys:_6}=Object;function TD(n){if(n.length===1){let t=n[0];if(k6(t))return{args:t,keys:null};if(O6(t)){let e=_6(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}function O6(n){return n&&typeof n=="object"&&A6(n)===R6}function ND(n,t){return n.reduce((e,r,o)=>(e[r]=t[o],e),{})}function zg(...n){let t=va(n),e=fD(n),{args:r,keys:o}=TD(n);if(r.length===0)return Nn([],t);let s=new Dt(M6(r,t,o?i=>ND(o,i):Hr));return e?s.pipe(SD(e)):s}function M6(n,t,e=Hr){return r=>{ED(t,()=>{let{length:o}=n,s=new Array(o),i=o,a=o;for(let l=0;l<o;l++)ED(t,()=>{let u=Nn(n[l],t),c=!1;u.subscribe(ut(r,p=>{s[l]=p,c||(c=!0,a--),a||r.next(e(s.slice()))},()=>{--i||r.complete()}))},r)},r)}}function ED(n,t,e){n?Dr(e,n,t):t()}function DD(n,t,e,r,o,s,i,a){let l=[],u=0,c=0,p=!1,f=()=>{p&&!l.length&&!u&&t.complete()},d=g=>u<r?h(g):l.push(g),h=g=>{s&&t.next(g),u++;let m=!1;$n(e(g,c++)).subscribe(ut(t,y=>{o?.(y),s?d(y):t.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(u--;l.length&&u<r;){let y=l.shift();i?Dr(t,i,()=>h(y)):h(y)}f()}catch(y){t.error(y)}}))};return n.subscribe(ut(t,d,()=>{p=!0,f()})),()=>{a?.()}}function En(n,t,e=1/0){return Ue(t)?En((r,o)=>st((s,i)=>t(r,s,o,i))($n(n(r,o))),e):(typeof t=="number"&&(e=t),lt((r,o)=>DD(r,o,n,e)))}function g0(n=1/0){return En(Hr,n)}function kD(){return g0(1)}function Xc(...n){return kD()(Nn(n,va(n)))}function Vg(n){return new Dt(t=>{$n(n()).subscribe(t)})}function $o(n,t){return lt((e,r)=>{let o=0;e.subscribe(ut(r,s=>n.call(t,s,o++)&&r.next(s)))})}function wa(n){return lt((t,e)=>{let r=null,o=!1,s;r=t.subscribe(ut(e,void 0,void 0,i=>{s=$n(n(i,wa(n)(t))),r?(r.unsubscribe(),r=null,s.subscribe(e)):o=!0})),o&&(r.unsubscribe(),r=null,s.subscribe(e))})}function AD(n,t,e,r,o){return(s,i)=>{let a=e,l=t,u=0;s.subscribe(ut(i,c=>{let p=u++;l=a?n(l,c,p):(a=!0,c),r&&i.next(l)},o&&(()=>{a&&i.next(l),i.complete()})))}}function Yc(n,t){return Ue(t)?En(n,t,1):En(n,1)}function Ca(n){return lt((t,e)=>{let r=!1;t.subscribe(ut(e,o=>{r=!0,e.next(o)},()=>{r||e.next(n),e.complete()}))})}function js(n){return n<=0?()=>qr:lt((t,e)=>{let r=0;t.subscribe(ut(e,o=>{++r<=n&&(e.next(o),n<=r&&e.complete())}))})}function y0(n){return st(()=>n)}function Ug(n=F6){return lt((t,e)=>{let r=!1;t.subscribe(ut(e,o=>{r=!0,e.next(o)},()=>r?e.complete():e.error(n())))})}function F6(){return new Ws}function bh(n){return lt((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}function us(n,t){let e=arguments.length>=2;return r=>r.pipe(n?$o((o,s)=>n(o,s,r)):Hr,js(1),e?Ca(t):Ug(()=>new Ws))}function Zc(n){return n<=0?()=>qr:lt((t,e)=>{let r=[];t.subscribe(ut(e,o=>{r.push(o),n<r.length&&r.shift()},()=>{for(let o of r)e.next(o);e.complete()},void 0,()=>{r=null}))})}function x0(n,t){let e=arguments.length>=2;return r=>r.pipe(n?$o((o,s)=>n(o,s,r)):Hr,Zc(1),e?Ca(t):Ug(()=>new Ws))}function b0(n,t){return lt(AD(n,t,arguments.length>=2,!0))}function v0(...n){let t=va(n);return lt((e,r)=>{(t?Xc(n,e,t):Xc(n,e)).subscribe(r)})}function Po(n,t){return lt((e,r)=>{let o=null,s=0,i=!1,a=()=>i&&!o&&r.complete();e.subscribe(ut(r,l=>{o?.unsubscribe();let u=0,c=s++;$n(n(l,c)).subscribe(o=ut(r,p=>r.next(t?t(l,p,c,u++):p),()=>{o=null,a()}))},()=>{i=!0,a()}))})}function w0(n){return lt((t,e)=>{$n(n).subscribe(ut(e,()=>e.complete(),xh)),!e.closed&&t.subscribe(e)})}function Hn(n,t,e){let r=Ue(n)||t||e?{next:n,error:t,complete:e}:n;return r?lt((o,s)=>{var i;(i=r.subscribe)===null||i===void 0||i.call(r);let a=!0;o.subscribe(ut(s,l=>{var u;(u=r.next)===null||u===void 0||u.call(r,l),s.next(l)},()=>{var l;a=!1,(l=r.complete)===null||l===void 0||l.call(r),s.complete()},l=>{var u;a=!1,(u=r.error)===null||u===void 0||u.call(r,l),s.error(l)},()=>{var l,u;a&&((l=r.unsubscribe)===null||l===void 0||l.call(r)),(u=r.finalize)===null||u===void 0||u.call(r)}))}):Hr}var Pe=class extends Error{constructor(t,e){super(gI(t,e)),this.code=t}};function gI(n,t){return`${`NG0${Math.abs(n)}`}${t?": "+t:""}`}function yI(n){return{toString:n}.toString()}var R0=globalThis;function Ot(n){for(let t in n)if(n[t]===Ot)return t;throw Error("Could not find renamed property on target object.")}function Kr(n){if(typeof n=="string")return n;if(Array.isArray(n))return"["+n.map(Kr).join(", ")+"]";if(n==null)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;let t=n.toString();if(t==null)return""+t;let e=t.indexOf(`
`);return e===-1?t:t.substring(0,e)}function RD(n,t){return n==null||n===""?t===null?"":t:t==null||t===""?n:n+" "+t}var $6=Ot({__forward_ref__:Ot});function dk(n){return n.__forward_ref__=dk,n.toString=function(){return Kr(this())},n}function ao(n){return hk(n)?n():n}function hk(n){return typeof n=="function"&&n.hasOwnProperty($6)&&n.__forward_ref__===dk}function je(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function py(n){return _D(n,gk)||_D(n,yk)}function mk(n){return py(n)!==null}function _D(n,t){return n.hasOwnProperty(t)?n[t]:null}function P6(n){let t=n&&(n[gk]||n[yk]);return t||null}function OD(n){return n&&(n.hasOwnProperty(MD)||n.hasOwnProperty(L6))?n[MD]:null}var gk=Ot({\u0275prov:Ot}),MD=Ot({\u0275inj:Ot}),yk=Ot({ngInjectableDef:Ot}),L6=Ot({ngInjectorDef:Ot}),Qe=class{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,typeof e=="number"?this.__NG_ELEMENT_ID__=e:e!==void 0&&(this.\u0275prov=je({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function xk(n){return n&&!!n.\u0275providers}var B6=Ot({\u0275cmp:Ot}),z6=Ot({\u0275dir:Ot}),V6=Ot({\u0275pipe:Ot}),U6=Ot({\u0275mod:Ot}),Xg=Ot({\u0275fac:Ot}),vh=Ot({__NG_ELEMENT_ID__:Ot}),FD=Ot({__NG_ENV_ID__:Ot});function bk(n){return typeof n=="string"?n:n==null?"":String(n)}function G6(n){return typeof n=="function"?n.name||n.toString():typeof n=="object"&&n!=null&&typeof n.type=="function"?n.type.name||n.type.toString():bk(n)}function W6(n,t){let e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new Pe(-200,n)}function xI(n,t){throw new Pe(-201,!1)}var Ye=function(n){return n[n.Default=0]="Default",n[n.Host=1]="Host",n[n.Self=2]="Self",n[n.SkipSelf=4]="SkipSelf",n[n.Optional=8]="Optional",n}(Ye||{}),_0;function vk(){return _0}function io(n){let t=_0;return _0=n,t}function wk(n,t,e){let r=py(n);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(e&Ye.Optional)return null;if(t!==void 0)return t;xI(n,"Injector")}var j6={},wh=j6,H6="__NG_DI_FLAG__",Yg="ngTempTokenPath",q6="ngTokenPath",K6=/\n/gm,X6="\u0275",$D="__source",tp;function Y6(){return tp}function Ia(n){let t=tp;return tp=n,t}function Z6(n,t=Ye.Default){if(tp===void 0)throw new Pe(-203,!1);return tp===null?wk(n,void 0,t):tp.get(n,t&Ye.Optional?null:void 0,t)}function it(n,t=Ye.Default){return(vk()||Z6)(ao(n),t)}function ge(n,t=Ye.Default){return it(n,fy(t))}function fy(n){return typeof n>"u"||typeof n=="number"?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function O0(n){let t=[];for(let e=0;e<n.length;e++){let r=ao(n[e]);if(Array.isArray(r)){if(r.length===0)throw new Pe(900,!1);let o,s=Ye.Default;for(let i=0;i<r.length;i++){let a=r[i],l=Q6(a);typeof l=="number"?l===-1?o=a.token:s|=l:o=a}t.push(it(o,s))}else t.push(it(r))}return t}function Q6(n){return n[H6]}function J6(n,t,e,r){let o=n[Yg];throw t[$D]&&o.unshift(t[$D]),n.message=e8(`
`+n.message,o,e,r),n[q6]=o,n[Yg]=null,n}function e8(n,t,e,r=null){n=n&&n.charAt(0)===`
`&&n.charAt(1)==X6?n.slice(2):n;let o=Kr(t);if(Array.isArray(t))o=t.map(Kr).join(" -> ");else if(typeof t=="object"){let s=[];for(let i in t)if(t.hasOwnProperty(i)){let a=t[i];s.push(i+":"+(typeof a=="string"?JSON.stringify(a):Kr(a)))}o=`{${s.join(", ")}}`}return`${e}${r?"("+r+")":""}[${o}]: ${n.replace(K6,`
  `)}`}function rp(n,t){let e=n.hasOwnProperty(Xg);return e?n[Xg]:null}function t8(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let o=n[r],s=t[r];if(e&&(o=e(o),s=e(s)),s!==o)return!1}return!0}function n8(n){return n.flat(Number.POSITIVE_INFINITY)}function bI(n,t){n.forEach(e=>Array.isArray(e)?bI(e,t):t(e))}function Ck(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function Zg(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}var Ch={},op=[],sp=new Qe(""),Ik=new Qe("",-1),Sk=new Qe(""),Qg=class{get(t,e=wh){if(e===wh){let r=new Error(`NullInjectorError: No provider for ${Kr(t)}!`);throw r.name="NullInjectorError",r}return e}},Tk=function(n){return n[n.OnPush=0]="OnPush",n[n.Default=1]="Default",n}(Tk||{}),fs=function(n){return n[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",n}(fs||{}),ip=function(n){return n[n.None=0]="None",n[n.SignalBased=1]="SignalBased",n[n.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",n}(ip||{});function r8(n,t,e){let r=n.length;for(;;){let o=n.indexOf(t,e);if(o===-1)return o;if(o===0||n.charCodeAt(o-1)<=32){let s=t.length;if(o+s===r||n.charCodeAt(o+s)<=32)return o}e=o+1}}function M0(n,t,e){let r=0;for(;r<e.length;){let o=e[r];if(typeof o=="number"){if(o!==0)break;r++;let s=e[r++],i=e[r++],a=e[r++];n.setAttribute(t,i,a,s)}else{let s=o,i=e[++r];s8(s)?n.setProperty(t,s,i):n.setAttribute(t,s,i),r++}}return r}function o8(n){return n===3||n===4||n===6}function s8(n){return n.charCodeAt(0)===64}function vI(n,t){if(!(t===null||t.length===0))if(n===null||n.length===0)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){let o=t[r];typeof o=="number"?e=o:e===0||(e===-1||e===2?PD(n,e,o,null,t[++r]):PD(n,e,o,null,null))}}return n}function PD(n,t,e,r,o){let s=0,i=n.length;if(t===-1)i=-1;else for(;s<n.length;){let a=n[s++];if(typeof a=="number"){if(a===t){i=-1;break}else if(a>t){i=s-1;break}}}for(;s<n.length;){let a=n[s];if(typeof a=="number")break;if(a===e){if(r===null){o!==null&&(n[s+1]=o);return}else if(r===n[s+1]){n[s+2]=o;return}}s++,r!==null&&s++,o!==null&&s++}i!==-1&&(n.splice(i,0,t),s=i+1),n.splice(s++,0,e),r!==null&&n.splice(s++,0,r),o!==null&&n.splice(s++,0,o)}var Nk="ng-template";function i8(n,t,e,r){let o=0;if(r){for(;o<t.length&&typeof t[o]=="string";o+=2)if(t[o]==="class"&&r8(t[o+1].toLowerCase(),e,0)!==-1)return!0}else if(wI(n))return!1;if(o=t.indexOf(1,o),o>-1){let s;for(;++o<t.length&&typeof(s=t[o])=="string";)if(s.toLowerCase()===e)return!0}return!1}function wI(n){return n.type===4&&n.value!==Nk}function a8(n,t,e){let r=n.type===4&&!e?Nk:n.value;return t===r}function l8(n,t,e){let r=4,o=n.attrs,s=o!==null?p8(o):0,i=!1;for(let a=0;a<t.length;a++){let l=t[a];if(typeof l=="number"){if(!i&&!Lo(r)&&!Lo(l))return!1;if(i&&Lo(l))continue;i=!1,r=l|r&1;continue}if(!i)if(r&4){if(r=2|r&1,l!==""&&!a8(n,l,e)||l===""&&t.length===1){if(Lo(r))return!1;i=!0}}else if(r&8){if(o===null||!i8(n,o,l,e)){if(Lo(r))return!1;i=!0}}else{let u=t[++a],c=u8(l,o,wI(n),e);if(c===-1){if(Lo(r))return!1;i=!0;continue}if(u!==""){let p;if(c>s?p="":p=o[c+1].toLowerCase(),r&2&&u!==p){if(Lo(r))return!1;i=!0}}}}return Lo(r)||i}function Lo(n){return(n&1)===0}function u8(n,t,e,r){if(t===null)return-1;let o=0;if(r||!e){let s=!1;for(;o<t.length;){let i=t[o];if(i===n)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=t[++o];for(;typeof a=="string";)a=t[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return f8(t,n)}function c8(n,t,e=!1){for(let r=0;r<t.length;r++)if(l8(n,t[r],e))return!0;return!1}function p8(n){for(let t=0;t<n.length;t++){let e=n[t];if(o8(e))return t}return n.length}function f8(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){let r=n[e];if(typeof r=="number")return-1;if(r===t)return e;e++}return-1}function LD(n,t){return n?":not("+t.trim()+")":t}function d8(n){let t=n[0],e=1,r=2,o="",s=!1;for(;e<n.length;){let i=n[e];if(typeof i=="string")if(r&2){let a=n[++e];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!Lo(i)&&(t+=LD(s,o),o=""),r=i,s=s||!Lo(r);e++}return o!==""&&(t+=LD(s,o)),t}function h8(n){return n.map(d8).join(",")}function m8(n){let t=[],e=[],r=1,o=2;for(;r<n.length;){let s=n[r];if(typeof s=="string")o===2?s!==""&&t.push(s,n[++r]):o===8&&e.push(s);else{if(!Lo(o))break;o=s}r++}return{attrs:t,classes:e}}function dy(n){return yI(()=>{let t=Rk(n),e=dn(Te({},t),{decls:n.decls,vars:n.vars,template:n.template,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,onPush:n.changeDetection===Tk.OnPush,directiveDefs:null,pipeDefs:null,dependencies:t.standalone&&n.dependencies||null,getStandaloneInjector:null,signals:n.signals??!1,data:n.data||{},encapsulation:n.encapsulation||fs.Emulated,styles:n.styles||op,_:null,schemas:n.schemas||null,tView:null,id:""});_k(e);let r=n.dependencies;return e.directiveDefs=zD(r,!1),e.pipeDefs=zD(r,!0),e.id=x8(e),e})}function g8(n){return pu(n)||Ek(n)}function y8(n){return n!==null}function BD(n,t){if(n==null)return Ch;let e={};for(let r in n)if(n.hasOwnProperty(r)){let o=n[r],s,i,a=ip.None;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s):(s=o,i=o),t?(e[s]=a!==ip.None?[r,a]:r,t[s]=i):e[s]=r}return e}function CI(n){return yI(()=>{let t=Rk(n);return _k(t),t})}function pu(n){return n[B6]||null}function Ek(n){return n[z6]||null}function Dk(n){return n[V6]||null}function kk(n){let t=pu(n)||Ek(n)||Dk(n);return t!==null?t.standalone:!1}function Ak(n,t){let e=n[U6]||null;if(!e&&t===!0)throw new Error(`Type ${Kr(n)} does not have '\u0275mod' property.`);return e}function Rk(n){let t={};return{type:n.type,providersResolver:null,factory:null,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:t,inputTransforms:null,inputConfig:n.inputs||Ch,exportAs:n.exportAs||null,standalone:n.standalone===!0,signals:n.signals===!0,selectors:n.selectors||op,viewQuery:n.viewQuery||null,features:n.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:BD(n.inputs,t),outputs:BD(n.outputs),debugInfo:null}}function _k(n){n.features?.forEach(t=>t(n))}function zD(n,t){if(!n)return null;let e=t?Dk:g8;return()=>(typeof n=="function"?n():n).map(r=>e(r)).filter(y8)}function x8(n){let t=0,e=[n.selectors,n.ngContentSelectors,n.hostVars,n.hostAttrs,n.consts,n.vars,n.decls,n.encapsulation,n.standalone,n.signals,n.exportAs,JSON.stringify(n.inputs),JSON.stringify(n.outputs),Object.getOwnPropertyNames(n.type.prototype),!!n.contentQueries,!!n.viewQuery].join("|");for(let o of e)t=Math.imul(31,t)+o.charCodeAt(0)<<0;return t+=2147483648,"c"+t}function hy(n){return{\u0275providers:n}}function b8(...n){return{\u0275providers:Ok(!0,n),\u0275fromNgModule:!0}}function Ok(n,...t){let e=[],r=new Set,o,s=i=>{e.push(i)};return bI(t,i=>{let a=i;F0(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&Mk(o,s),e}function Mk(n,t){for(let e=0;e<n.length;e++){let{ngModule:r,providers:o}=n[e];II(o,s=>{t(s,r)})}}function F0(n,t,e,r){if(n=ao(n),!n)return!1;let o=null,s=OD(n),i=!s&&pu(n);if(!s&&!i){let l=n.ngModule;if(s=OD(l),s)o=l;else return!1}else{if(i&&!i.standalone)return!1;o=n}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let l=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let u of l)F0(u,t,e,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let u;try{bI(s.imports,c=>{F0(c,t,e,r)&&(u||=[],u.push(c))})}finally{}u!==void 0&&Mk(u,t)}if(!a){let u=rp(o)||(()=>new o);t({provide:o,useFactory:u,deps:op},o),t({provide:Sk,useValue:o,multi:!0},o),t({provide:sp,useValue:()=>it(o),multi:!0},o)}let l=s.providers;if(l!=null&&!a){let u=n;II(l,c=>{t(c,u)})}}else return!1;return o!==n&&n.providers!==void 0}function II(n,t){for(let e of n)xk(e)&&(e=e.\u0275providers),Array.isArray(e)?II(e,t):t(e)}var v8=Ot({provide:String,useValue:Ot});function Fk(n){return n!==null&&typeof n=="object"&&v8 in n}function w8(n){return!!(n&&n.useExisting)}function C8(n){return!!(n&&n.useFactory)}function $0(n){return typeof n=="function"}var my=new Qe(""),Gg={},I8={},C0;function SI(){return C0===void 0&&(C0=new Qg),C0}var uo=class{},Ih=class extends uo{get destroyed(){return this._destroyed}constructor(t,e,r,o){super(),this.parent=e,this.source=r,this.scopes=o,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,L0(t,i=>this.processProvider(i)),this.records.set(Ik,Qc(void 0,this)),o.has("environment")&&this.records.set(uo,Qc(void 0,this));let s=this.records.get(my);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(Sk,op,Ye.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;let t=xt(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let e=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of e)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),xt(t)}}onDestroy(t){return this.assertNotDestroyed(),this._onDestroyHooks.push(t),()=>this.removeOnDestroy(t)}runInContext(t){this.assertNotDestroyed();let e=Ia(this),r=io(void 0),o;try{return t()}finally{Ia(e),io(r)}}get(t,e=wh,r=Ye.Default){if(this.assertNotDestroyed(),t.hasOwnProperty(FD))return t[FD](this);r=fy(r);let o,s=Ia(this),i=io(void 0);try{if(!(r&Ye.SkipSelf)){let l=this.records.get(t);if(l===void 0){let u=k8(t)&&py(t);u&&this.injectableDefInScope(u)?l=Qc(P0(t),Gg):l=null,this.records.set(t,l)}if(l!=null)return this.hydrate(t,l)}let a=r&Ye.Self?SI():this.parent;return e=r&Ye.Optional&&e===wh?null:e,a.get(t,e)}catch(a){if(a.name==="NullInjectorError"){if((a[Yg]=a[Yg]||[]).unshift(Kr(t)),s)throw a;return J6(a,t,"R3InjectorError",this.source)}else throw a}finally{io(i),Ia(s)}}resolveInjectorInitializers(){let t=xt(null),e=Ia(this),r=io(void 0),o;try{let s=this.get(sp,op,Ye.Self);for(let i of s)i()}finally{Ia(e),io(r),xt(t)}}toString(){let t=[],e=this.records;for(let r of e.keys())t.push(Kr(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Pe(205,!1)}processProvider(t){t=ao(t);let e=$0(t)?t:ao(t&&t.provide),r=T8(t);if(!$0(t)&&t.multi===!0){let o=this.records.get(e);o||(o=Qc(void 0,Gg,!0),o.factory=()=>O0(o.multi),this.records.set(e,o)),e=t,o.multi.push(t)}this.records.set(e,r)}hydrate(t,e){let r=xt(null);try{return e.value===Gg&&(e.value=I8,e.value=e.factory()),typeof e.value=="object"&&e.value&&D8(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}finally{xt(r)}}injectableDefInScope(t){if(!t.providedIn)return!1;let e=ao(t.providedIn);return typeof e=="string"?e==="any"||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(t){let e=this._onDestroyHooks.indexOf(t);e!==-1&&this._onDestroyHooks.splice(e,1)}};function P0(n){let t=py(n),e=t!==null?t.factory:rp(n);if(e!==null)return e;if(n instanceof Qe)throw new Pe(204,!1);if(n instanceof Function)return S8(n);throw new Pe(204,!1)}function S8(n){if(n.length>0)throw new Pe(204,!1);let e=P6(n);return e!==null?()=>e.factory(n):()=>new n}function T8(n){if(Fk(n))return Qc(void 0,n.useValue);{let t=N8(n);return Qc(t,Gg)}}function N8(n,t,e){let r;if($0(n)){let o=ao(n);return rp(o)||P0(o)}else if(Fk(n))r=()=>ao(n.useValue);else if(C8(n))r=()=>n.useFactory(...O0(n.deps||[]));else if(w8(n))r=()=>it(ao(n.useExisting));else{let o=ao(n&&(n.useClass||n.provide));if(E8(n))r=()=>new o(...O0(n.deps));else return rp(o)||P0(o)}return r}function Qc(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function E8(n){return!!n.deps}function D8(n){return n!==null&&typeof n=="object"&&typeof n.ngOnDestroy=="function"}function k8(n){return typeof n=="function"||typeof n=="object"&&n instanceof Qe}function L0(n,t){for(let e of n)Array.isArray(e)?L0(e,t):e&&xk(e)?L0(e.\u0275providers,t):t(e)}function Xs(n,t){n instanceof Ih&&n.assertNotDestroyed();let e,r=Ia(n),o=io(void 0);try{return t()}finally{Ia(r),io(o)}}function A8(){return vk()!==void 0||Y6()!=null}function R8(n){return typeof n=="function"}var Ys=0,Ze=1,Be=2,tr=3,Bo=4,zo=5,Jg=6,ey=7,ds=8,ap=9,Hs=10,co=11,Sh=12,VD=13,Rh=14,hs=15,fu=16,Jc=17,qs=18,gy=19,$k=20,Sa=21,I0=22,lo=23,du=25,Pk=1;var hu=7,ty=8,lp=9,Xr=10,ny=function(n){return n[n.None=0]="None",n[n.HasTransplantedViews=2]="HasTransplantedViews",n}(ny||{});function uu(n){return Array.isArray(n)&&typeof n[Pk]=="object"}function Zs(n){return Array.isArray(n)&&n[Pk]===!0}function Lk(n){return(n.flags&4)!==0}function TI(n){return n.componentOffset>-1}function Bk(n){return(n.flags&1)===1}function _h(n){return!!n.template}function B0(n){return(n[Be]&512)!==0}var z0=class{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}};function zk(n,t,e,r){t!==null?t.applyValueToInputSignal(t,r):n[e]=r}function yy(){return Vk}function Vk(n){return n.type.prototype.ngOnChanges&&(n.setInput=O8),_8}yy.ngInherit=!0;function _8(){let n=Gk(this),t=n?.current;if(t){let e=n.previous;if(e===Ch)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function O8(n,t,e,r,o){let s=this.declaredInputs[r],i=Gk(n)||M8(n,{previous:Ch,current:null}),a=i.current||(i.current={}),l=i.previous,u=l[s];a[s]=new z0(u&&u.currentValue,e,l===Ch),zk(n,t,o,e)}var Uk="__ngSimpleChanges__";function Gk(n){return n[Uk]||null}function M8(n,t){return n[Uk]=t}var UD=null;var cs=function(n,t,e){UD?.(n,t,e)},F8="svg",$8="math";function ms(n){for(;Array.isArray(n);)n=n[Ys];return n}function P8(n,t){return ms(t[n])}function gs(n,t){return ms(t[n.index])}function L8(n,t){return n.data[t]}function dp(n,t){let e=t[n];return uu(e)?e:e[Ys]}function B8(n){return(n[Be]&4)===4}function NI(n){return(n[Be]&128)===128}function z8(n){return Zs(n[tr])}function GD(n,t){return t==null?null:n[t]}function Wk(n){n[Jc]=0}function jk(n){n[Be]&1024||(n[Be]|=1024,NI(n)&&xy(n))}function Th(n){return!!(n[Be]&9216||n[lo]?.dirty)}function V0(n){n[Hs].changeDetectionScheduler?.notify(7),n[Be]&64&&(n[Be]|=1024),Th(n)&&xy(n)}function xy(n){n[Hs].changeDetectionScheduler?.notify(0);let t=mu(n);for(;t!==null&&!(t[Be]&8192||(t[Be]|=8192,!NI(t)));)t=mu(t)}function Hk(n,t){if((n[Be]&256)===256)throw new Pe(911,!1);n[Sa]===null&&(n[Sa]=[]),n[Sa].push(t)}function V8(n,t){if(n[Sa]===null)return;let e=n[Sa].indexOf(t);e!==-1&&n[Sa].splice(e,1)}function mu(n){let t=n[tr];return Zs(t)?t[tr]:t}var dt={lFrame:tA(null),bindingsEnabled:!0,skipHydrationRootTNode:null};var qk=!1;function U8(){return dt.lFrame.elementDepthCount}function G8(){dt.lFrame.elementDepthCount++}function W8(){dt.lFrame.elementDepthCount--}function Kk(){return dt.bindingsEnabled}function j8(){return dt.skipHydrationRootTNode!==null}function H8(n){return dt.skipHydrationRootTNode===n}function q8(){dt.skipHydrationRootTNode=null}function Dn(){return dt.lFrame.lView}function bu(){return dt.lFrame.tView}function Oh(n){return dt.lFrame.contextLView=n,n[ds]}function Mh(n){return dt.lFrame.contextLView=null,n}function Vo(){let n=Xk();for(;n!==null&&n.type===64;)n=n.parent;return n}function Xk(){return dt.lFrame.currentTNode}function K8(){let n=dt.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}function by(n,t){let e=dt.lFrame;e.currentTNode=n,e.isParent=t}function Yk(){return dt.lFrame.isParent}function X8(){dt.lFrame.isParent=!1}function Zk(){return qk}function WD(n){qk=n}function Y8(n){return dt.lFrame.bindingIndex=n}function Z8(){return dt.lFrame.bindingIndex++}function Q8(){return dt.lFrame.inI18n}function J8(n,t){let e=dt.lFrame;e.bindingIndex=e.bindingRootIndex=n,U0(t)}function eq(){return dt.lFrame.currentDirectiveIndex}function U0(n){dt.lFrame.currentDirectiveIndex=n}function Qk(){return dt.lFrame.currentQueryIndex}function EI(n){dt.lFrame.currentQueryIndex=n}function tq(n){let t=n[Ze];return t.type===2?t.declTNode:t.type===1?n[zo]:null}function Jk(n,t,e){if(e&Ye.SkipSelf){let o=t,s=n;for(;o=o.parent,o===null&&!(e&Ye.Host);)if(o=tq(s),o===null||(s=s[Rh],o.type&10))break;if(o===null)return!1;t=o,n=s}let r=dt.lFrame=eA();return r.currentTNode=t,r.lView=n,!0}function DI(n){let t=eA(),e=n[Ze];dt.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function eA(){let n=dt.lFrame,t=n===null?null:n.child;return t===null?tA(n):t}function tA(n){let t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return n!==null&&(n.child=t),t}function nA(){let n=dt.lFrame;return dt.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}var rA=nA;function kI(){let n=nA();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function AI(){return dt.lFrame.selectedIndex}function gu(n){dt.lFrame.selectedIndex=n}function nq(){return dt.lFrame.currentNamespace}var oA=!0;function sA(){return oA}function iA(n){oA=n}function rq(n,t,e){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=t.type.prototype;if(r){let i=Vk(t);(e.preOrderHooks??=[]).push(n,i),(e.preOrderCheckHooks??=[]).push(n,i)}o&&(e.preOrderHooks??=[]).push(0-n,o),s&&((e.preOrderHooks??=[]).push(n,s),(e.preOrderCheckHooks??=[]).push(n,s))}function aA(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){let s=n.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=s;i&&(n.contentHooks??=[]).push(-e,i),a&&((n.contentHooks??=[]).push(e,a),(n.contentCheckHooks??=[]).push(e,a)),l&&(n.viewHooks??=[]).push(-e,l),u&&((n.viewHooks??=[]).push(e,u),(n.viewCheckHooks??=[]).push(e,u)),c!=null&&(n.destroyHooks??=[]).push(e,c)}}function Wg(n,t,e){lA(n,t,3,e)}function jg(n,t,e,r){(n[Be]&3)===e&&lA(n,t,e,r)}function S0(n,t){let e=n[Be];(e&3)===t&&(e&=16383,e+=1,n[Be]=e)}function lA(n,t,e,r){let o=r!==void 0?n[Jc]&65535:0,s=r??-1,i=t.length-1,a=0;for(let l=o;l<i;l++)if(typeof t[l+1]=="number"){if(a=t[l],r!=null&&a>=r)break}else t[l]<0&&(n[Jc]+=65536),(a<s||s==-1)&&(oq(n,e,t,l),n[Jc]=(n[Jc]&4294901760)+l+2),l++}function jD(n,t){cs(4,n,t);let e=xt(null);try{t.call(n)}finally{xt(e),cs(5,n,t)}}function oq(n,t,e,r){let o=e[r]<0,s=e[r+1],i=o?-e[r]:e[r],a=n[i];o?n[Be]>>14<n[Jc]>>16&&(n[Be]&3)===t&&(n[Be]+=16384,jD(a,s)):jD(a,s)}var np=-1,Nh=class{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}};function sq(n){return n instanceof Nh}function iq(n){return(n.flags&8)!==0}function aq(n){return(n.flags&16)!==0}function uA(n){return n!==np}function ry(n){return n&32767}function lq(n){return n>>16}function oy(n,t){let e=lq(n),r=t;for(;e>0;)r=r[Rh],e--;return r}var G0=!0;function HD(n){let t=G0;return G0=n,t}var uq=256,cA=uq-1,pA=5,cq=0,ps={};function pq(n,t,e){let r;typeof e=="string"?r=e.charCodeAt(0)||0:e.hasOwnProperty(vh)&&(r=e[vh]),r==null&&(r=e[vh]=cq++);let o=r&cA,s=1<<o;t.data[n+(o>>pA)]|=s}function fA(n,t){let e=dA(n,t);if(e!==-1)return e;let r=t[Ze];r.firstCreatePass&&(n.injectorIndex=t.length,T0(r.data,n),T0(t,null),T0(r.blueprint,null));let o=RI(n,t),s=n.injectorIndex;if(uA(o)){let i=ry(o),a=oy(o,t),l=a[Ze].data;for(let u=0;u<8;u++)t[s+u]=a[i+u]|l[i+u]}return t[s+8]=o,s}function T0(n,t){n.push(0,0,0,0,0,0,0,0,t)}function dA(n,t){return n.injectorIndex===-1||n.parent&&n.parent.injectorIndex===n.injectorIndex||t[n.injectorIndex+8]===null?-1:n.injectorIndex}function RI(n,t){if(n.parent&&n.parent.injectorIndex!==-1)return n.parent.injectorIndex;let e=0,r=null,o=t;for(;o!==null;){if(r=xA(o),r===null)return np;if(e++,o=o[Rh],r.injectorIndex!==-1)return r.injectorIndex|e<<16}return np}function fq(n,t,e){pq(n,t,e)}function hA(n,t,e){if(e&Ye.Optional||n!==void 0)return n;xI(t,"NodeInjector")}function mA(n,t,e,r){if(e&Ye.Optional&&r===void 0&&(r=null),!(e&(Ye.Self|Ye.Host))){let o=n[ap],s=io(void 0);try{return o?o.get(t,r,e&Ye.Optional):wk(t,r,e&Ye.Optional)}finally{io(s)}}return hA(r,t,e)}function gA(n,t,e,r=Ye.Default,o){if(n!==null){if(t[Be]&2048&&!(r&Ye.Self)){let i=gq(n,t,e,r,ps);if(i!==ps)return i}let s=yA(n,t,e,r,ps);if(s!==ps)return s}return mA(t,e,r,o)}function yA(n,t,e,r,o){let s=hq(e);if(typeof s=="function"){if(!Jk(t,n,r))return r&Ye.Host?hA(o,e,r):mA(t,e,r,o);try{let i;if(i=s(r),i==null&&!(r&Ye.Optional))xI(e);else return i}finally{rA()}}else if(typeof s=="number"){let i=null,a=dA(n,t),l=np,u=r&Ye.Host?t[hs][zo]:null;for((a===-1||r&Ye.SkipSelf)&&(l=a===-1?RI(n,t):t[a+8],l===np||!KD(r,!1)?a=-1:(i=t[Ze],a=ry(l),t=oy(l,t)));a!==-1;){let c=t[Ze];if(qD(s,a,c.data)){let p=dq(a,t,e,i,r,u);if(p!==ps)return p}l=t[a+8],l!==np&&KD(r,t[Ze].data[a+8]===u)&&qD(s,a,t)?(i=c,a=ry(l),t=oy(l,t)):a=-1}}return o}function dq(n,t,e,r,o,s){let i=t[Ze],a=i.data[n+8],l=r==null?TI(a)&&G0:r!=i&&(a.type&3)!==0,u=o&Ye.Host&&s===a,c=Hg(a,i,e,l,u);return c!==null?up(t,i,c,a):ps}function Hg(n,t,e,r,o){let s=n.providerIndexes,i=t.data,a=s&1048575,l=n.directiveStart,u=n.directiveEnd,c=s>>20,p=r?a:a+c,f=o?a+c:u;for(let d=p;d<f;d++){let h=i[d];if(d<l&&e===h||d>=l&&h.type===e)return d}if(o){let d=i[l];if(d&&_h(d)&&d.type===e)return l}return null}function up(n,t,e,r){let o=n[e],s=t.data;if(sq(o)){let i=o;i.resolving&&W6(G6(s[e]));let a=HD(i.canSeeViewProviders);i.resolving=!0;let l,u=i.injectImpl?io(i.injectImpl):null,c=Jk(n,r,Ye.Default);try{o=n[e]=i.factory(void 0,s,n,r),t.firstCreatePass&&e>=r.directiveStart&&rq(e,s[e],t)}finally{u!==null&&io(u),HD(a),i.resolving=!1,rA()}}return o}function hq(n){if(typeof n=="string")return n.charCodeAt(0)||0;let t=n.hasOwnProperty(vh)?n[vh]:void 0;return typeof t=="number"?t>=0?t&cA:mq:t}function qD(n,t,e){let r=1<<n;return!!(e[t+(n>>pA)]&r)}function KD(n,t){return!(n&Ye.Self)&&!(n&Ye.Host&&t)}var cu=class{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return gA(this._tNode,this._lView,t,fy(r),e)}};function mq(){return new cu(Vo(),Dn())}function _I(n){return yI(()=>{let t=n.prototype.constructor,e=t[Xg]||W0(t),r=Object.prototype,o=Object.getPrototypeOf(n.prototype).constructor;for(;o&&o!==r;){let s=o[Xg]||W0(o);if(s&&s!==e)return s;o=Object.getPrototypeOf(o)}return s=>new s})}function W0(n){return hk(n)?()=>{let t=W0(ao(n));return t&&t()}:rp(n)}function gq(n,t,e,r,o){let s=n,i=t;for(;s!==null&&i!==null&&i[Be]&2048&&!(i[Be]&512);){let a=yA(s,i,e,r|Ye.Self,ps);if(a!==ps)return a;let l=s.parent;if(!l){let u=i[$k];if(u){let c=u.get(e,ps,r);if(c!==ps)return c}l=xA(i),i=i[Rh]}s=l}return o}function xA(n){let t=n[Ze],e=t.type;return e===2?t.declTNode:e===1?n[zo]:null}function XD(n,t=null,e=null,r){let o=bA(n,t,e,r);return o.resolveInjectorInitializers(),o}function bA(n,t=null,e=null,r,o=new Set){let s=[e||op,b8(n)];return r=r||(typeof n=="object"?void 0:Kr(n)),new Ih(s,t||SI(),r||null,o)}var lu=class lu{static create(t,e){if(Array.isArray(t))return XD({name:""},e,t,"");{let r=t.name??"";return XD({name:r},t.parent,t.providers,r)}}};lu.THROW_IF_NOT_FOUND=wh,lu.NULL=new Qg,lu.\u0275prov=je({token:lu,providedIn:"any",factory:()=>it(Ik)}),lu.__NG_ELEMENT_ID__=-1;var yu=lu;var yq=new Qe("");yq.__NG_ELEMENT_ID__=n=>{let t=Vo();if(t===null)throw new Pe(204,!1);if(t.type&2)return t.value;if(n&Ye.Optional)return null;throw new Pe(204,!1)};var xq="ngOriginalError";function N0(n){return n[xq]}var Ks=class{constructor(){this._console=console}handleError(t){let e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&N0(t);for(;e&&N0(e);)e=N0(e);return e||null}},vA=new Qe("",{providedIn:"root",factory:()=>ge(Ks).handleError.bind(void 0)}),wA=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=bq,t.__NG_ENV_ID__=r=>r;let n=t;return n})(),j0=class extends wA{constructor(t){super(),this._lView=t}onDestroy(t){return Hk(this._lView,t),()=>V8(this._lView,t)}};function bq(){return new j0(Dn())}function vq(){return hp(Vo(),Dn())}function hp(n,t){return new vu(gs(n,t))}var vu=(()=>{let t=class t{constructor(r){this.nativeElement=r}};t.__NG_ELEMENT_ID__=vq;let n=t;return n})();function wq(n){return n instanceof vu?n.nativeElement:n}var mp=(()=>{let t=class t{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new jn(!1)}get _hasPendingTasks(){return this.hasPendingTasks.value}add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);let r=this.taskId++;return this.pendingTasks.add(r),r}remove(r){this.pendingTasks.delete(r),this.pendingTasks.size===0&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}};t.\u0275prov=je({token:t,providedIn:"root",factory:()=>new t});let n=t;return n})();var H0=class extends mr{constructor(t=!1){super(),this.destroyRef=void 0,this.pendingTasks=void 0,this.__isAsync=t,A8()&&(this.destroyRef=ge(wA,{optional:!0})??void 0,this.pendingTasks=ge(mp,{optional:!0})??void 0)}emit(t){let e=xt(null);try{super.next(t)}finally{xt(e)}}subscribe(t,e,r){let o=t,s=e||(()=>null),i=r;if(t&&typeof t=="object"){let l=t;o=l.next?.bind(l),s=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return t instanceof gn&&t.add(a),a}wrapInTimeout(t){return e=>{let r=this.pendingTasks?.add();setTimeout(()=>{t(e),r!==void 0&&this.pendingTasks?.remove(r)})}}},er=H0;function Cq(){return this._results[Symbol.iterator]()}var q0=class n{get changes(){return this._changes??=new er}constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._onDirty=void 0,this._results=[],this._changesDetected=!1,this._changes=void 0,this.length=0,this.first=void 0,this.last=void 0;let e=n.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=Cq)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){this.dirty=!1;let r=n8(t);(this._changesDetected=!t8(this._results,r,e))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}onDirty(t){this._onDirty=t}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}};function CA(n){return(n.flags&128)===128}var IA=new Map,Iq=0;function Sq(){return Iq++}function Tq(n){IA.set(n[gy],n)}function Nq(n){IA.delete(n[gy])}var YD="__ngContext__";function cp(n,t){uu(t)?(n[YD]=t[gy],Tq(t)):n[YD]=t}function SA(n){return NA(n[Sh])}function TA(n){return NA(n[Bo])}function NA(n){for(;n!==null&&!Zs(n);)n=n[Bo];return n}var K0;function EA(n){K0=n}function Eq(){if(K0!==void 0)return K0;if(typeof document<"u")return document;throw new Pe(210,!1)}var OI=new Qe("",{providedIn:"root",factory:()=>Dq}),Dq="ng",MI=new Qe(""),gp=new Qe("",{providedIn:"platform",factory:()=>"unknown"});var FI=new Qe("",{providedIn:"root",factory:()=>Eq().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var kq="h",Aq="b";var Rq=()=>null;function $I(n,t,e=!1){return Rq(n,t,e)}var DA=!1,_q=new Qe("",{providedIn:"root",factory:()=>DA});function kA(n){return n instanceof Function?n():n}var wu=function(n){return n[n.Important=1]="Important",n[n.DashCase=2]="DashCase",n}(wu||{}),Oq;function PI(n,t){return Oq(n,t)}function ep(n,t,e,r,o){if(r!=null){let s,i=!1;Zs(r)?s=r:uu(r)&&(i=!0,r=r[Ys]);let a=ms(r);n===0&&e!==null?o==null?MA(t,e,a):sy(t,e,a,o||null,!0):n===1&&e!==null?sy(t,e,a,o||null,!0):n===2?Xq(t,a,i):n===3&&t.destroyNode(a),s!=null&&Zq(t,n,s,e,o)}}function Mq(n,t){return n.createText(t)}function Fq(n,t,e){n.setValue(t,e)}function AA(n,t,e){return n.createElement(t,e)}function $q(n,t){RA(n,t),t[Ys]=null,t[zo]=null}function Pq(n,t,e,r,o,s){r[Ys]=o,r[zo]=t,vy(n,r,e,1,o,s)}function RA(n,t){t[Hs].changeDetectionScheduler?.notify(8),vy(n,t,t[co],2,null,null)}function Lq(n){let t=n[Sh];if(!t)return E0(n[Ze],n);for(;t;){let e=null;if(uu(t))e=t[Sh];else{let r=t[Xr];r&&(e=r)}if(!e){for(;t&&!t[Bo]&&t!==n;)uu(t)&&E0(t[Ze],t),t=t[tr];t===null&&(t=n),uu(t)&&E0(t[Ze],t),e=t&&t[Bo]}t=e}}function Bq(n,t,e,r){let o=Xr+r,s=e.length;r>0&&(e[o-1][Bo]=t),r<s-Xr?(t[Bo]=e[o],Ck(e,Xr+r,t)):(e.push(t),t[Bo]=null),t[tr]=e;let i=t[fu];i!==null&&e!==i&&_A(i,t);let a=t[qs];a!==null&&a.insertView(n),V0(t),t[Be]|=128}function _A(n,t){let e=n[lp],r=t[tr];if(uu(r))n[Be]|=ny.HasTransplantedViews;else{let o=r[tr][hs];t[hs]!==o&&(n[Be]|=ny.HasTransplantedViews)}e===null?n[lp]=[t]:e.push(t)}function LI(n,t){let e=n[lp],r=e.indexOf(t);e.splice(r,1)}function X0(n,t){if(n.length<=Xr)return;let e=Xr+t,r=n[e];if(r){let o=r[fu];o!==null&&o!==n&&LI(o,r),t>0&&(n[e-1][Bo]=r[Bo]);let s=Zg(n,Xr+t);$q(r[Ze],r);let i=s[qs];i!==null&&i.detachView(s[Ze]),r[tr]=null,r[Bo]=null,r[Be]&=-129}return r}function OA(n,t){if(!(t[Be]&256)){let e=t[co];e.destroyNode&&vy(n,t,e,3,null,null),Lq(t)}}function E0(n,t){if(t[Be]&256)return;let e=xt(null);try{t[Be]&=-129,t[Be]|=256,t[lo]&&n0(t[lo]),Vq(n,t),zq(n,t),t[Ze].type===1&&t[co].destroy();let r=t[fu];if(r!==null&&Zs(t[tr])){r!==t[tr]&&LI(r,t);let o=t[qs];o!==null&&o.detachView(n)}Nq(t)}finally{xt(e)}}function zq(n,t){let e=n.cleanup,r=t[ey];if(e!==null)for(let s=0;s<e.length-1;s+=2)if(typeof e[s]=="string"){let i=e[s+3];i>=0?r[i]():r[-i].unsubscribe(),s+=2}else{let i=r[e[s+1]];e[s].call(i)}r!==null&&(t[ey]=null);let o=t[Sa];if(o!==null){t[Sa]=null;for(let s=0;s<o.length;s++){let i=o[s];i()}}}function Vq(n,t){let e;if(n!=null&&(e=n.destroyHooks)!=null)for(let r=0;r<e.length;r+=2){let o=t[e[r]];if(!(o instanceof Nh)){let s=e[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],l=s[i+1];cs(4,a,l);try{l.call(a)}finally{cs(5,a,l)}}else{cs(4,o,s);try{s.call(o)}finally{cs(5,o,s)}}}}}function Uq(n,t,e){return Gq(n,t.parent,e)}function Gq(n,t,e){let r=t;for(;r!==null&&r.type&40;)t=r,r=t.parent;if(r===null)return e[Ys];{let{componentOffset:o}=r;if(o>-1){let{encapsulation:s}=n.data[r.directiveStart+o];if(s===fs.None||s===fs.Emulated)return null}return gs(r,e)}}function sy(n,t,e,r,o){n.insertBefore(t,e,r,o)}function MA(n,t,e){n.appendChild(t,e)}function ZD(n,t,e,r,o){r!==null?sy(n,t,e,r,o):MA(n,t,e)}function Wq(n,t,e,r){n.removeChild(t,e,r)}function BI(n,t){return n.parentNode(t)}function jq(n,t){return n.nextSibling(t)}function Hq(n,t,e){return Kq(n,t,e)}function qq(n,t,e){return n.type&40?gs(n,e):null}var Kq=qq,QD;function FA(n,t,e,r){let o=Uq(n,r,t),s=t[co],i=r.parent||t[zo],a=Hq(i,r,t);if(o!=null)if(Array.isArray(e))for(let l=0;l<e.length;l++)ZD(s,o,e[l],a,!1);else ZD(s,o,e,a,!1);QD!==void 0&&QD(s,r,t,e,o)}function qg(n,t){if(t!==null){let e=t.type;if(e&3)return gs(t,n);if(e&4)return Y0(-1,n[t.index]);if(e&8){let r=t.child;if(r!==null)return qg(n,r);{let o=n[t.index];return Zs(o)?Y0(-1,o):ms(o)}}else{if(e&32)return PI(t,n)()||ms(n[t.index]);{let r=$A(n,t);if(r!==null){if(Array.isArray(r))return r[0];let o=mu(n[hs]);return qg(o,r)}else return qg(n,t.next)}}}return null}function $A(n,t){if(t!==null){let r=n[hs][zo],o=t.projection;return r.projection[o]}return null}function Y0(n,t){let e=Xr+n+1;if(e<t.length){let r=t[e],o=r[Ze].firstChild;if(o!==null)return qg(r,o)}return t[hu]}function Xq(n,t,e){let r=BI(n,t);r&&Wq(n,r,t,e)}function zI(n,t,e,r,o,s,i){for(;e!=null;){let a=r[e.index],l=e.type;if(i&&t===0&&(a&&cp(ms(a),r),e.flags|=2),(e.flags&32)!==32)if(l&8)zI(n,t,e.child,r,o,s,!1),ep(t,n,o,a,s);else if(l&32){let u=PI(e,r),c;for(;c=u();)ep(t,n,o,c,s);ep(t,n,o,a,s)}else l&16?Yq(n,t,r,e,o,s):ep(t,n,o,a,s);e=i?e.projectionNext:e.next}}function vy(n,t,e,r,o,s){zI(e,r,n.firstChild,t,o,s,!1)}function Yq(n,t,e,r,o,s){let i=e[hs],l=i[zo].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++){let c=l[u];ep(t,n,o,c,s)}else{let u=l,c=i[tr];CA(r)&&(u.flags|=128),zI(n,t,u,c,o,s,!0)}}function Zq(n,t,e,r,o){let s=e[hu],i=ms(e);s!==i&&ep(t,n,r,s,o);for(let a=Xr;a<e.length;a++){let l=e[a];vy(l[Ze],l,n,t,r,s)}}function Qq(n,t,e){n.setAttribute(t,"style",e)}function PA(n,t,e){e===""?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function LA(n,t,e){let{mergedAttrs:r,classes:o,styles:s}=e;r!==null&&M0(n,t,r),o!==null&&PA(n,t,o),s!==null&&Qq(n,t,s)}var wy={};function BA(n=1){zA(bu(),Dn(),AI()+n,!1)}function zA(n,t,e,r){if(!r)if((t[Be]&3)===3){let s=n.preOrderCheckHooks;s!==null&&Wg(t,s,e)}else{let s=n.preOrderHooks;s!==null&&jg(t,s,0,e)}gu(e)}function VI(n,t=Ye.Default){let e=Dn();if(e===null)return it(n,t);let r=Vo();return gA(r,e,ao(n),t)}function VA(n,t,e,r,o,s){let i=xt(null);try{let a=null;o&ip.SignalBased&&(a=t[r][J1]),a!==null&&a.transformFn!==void 0&&(s=a.transformFn(s)),o&ip.HasDecoratorInputTransform&&(s=n.inputTransforms[r].call(t,s)),n.setInput!==null?n.setInput(t,a,s,e,r):zk(t,a,r,s)}finally{xt(i)}}function Jq(n,t){let e=n.hostBindingOpCodes;if(e!==null)try{for(let r=0;r<e.length;r++){let o=e[r];if(o<0)gu(~o);else{let s=o,i=e[++r],a=e[++r];J8(i,s);let l=t[s];a(2,l)}}}finally{gu(-1)}}function Cy(n,t,e,r,o,s,i,a,l,u,c){let p=t.blueprint.slice();return p[Ys]=o,p[Be]=r|4|128|8|64,(u!==null||n&&n[Be]&2048)&&(p[Be]|=2048),Wk(p),p[tr]=p[Rh]=n,p[ds]=e,p[Hs]=i||n&&n[Hs],p[co]=a||n&&n[co],p[ap]=l||n&&n[ap]||null,p[zo]=s,p[gy]=Sq(),p[Jg]=c,p[$k]=u,p[hs]=t.type==2?n[hs]:p,p}function UI(n,t,e,r,o){let s=n.data[t];if(s===null)s=e5(n,t,e,r,o),Q8()&&(s.flags|=32);else if(s.type&64){s.type=e,s.value=r,s.attrs=o;let i=K8();s.injectorIndex=i===null?-1:i.injectorIndex}return by(s,!0),s}function e5(n,t,e,r,o){let s=Xk(),i=Yk(),a=i?s:s&&s.parent,l=n.data[t]=l5(n,a,e,t,r,o);return n.firstChild===null&&(n.firstChild=l),s!==null&&(i?s.child==null&&l.parent!==null&&(s.child=l):s.next===null&&(s.next=l,l.prev=s)),l}function UA(n,t,e,r){if(e===0)return-1;let o=t.length;for(let s=0;s<e;s++)t.push(r),n.blueprint.push(r),n.data.push(null);return o}function GA(n,t,e,r,o){let s=AI(),i=r&2;try{gu(-1),i&&t.length>du&&zA(n,t,du,!1),cs(i?2:0,o),e(r,o)}finally{gu(s),cs(i?3:1,o)}}function WA(n,t,e){if(Lk(t)){let r=xt(null);try{let o=t.directiveStart,s=t.directiveEnd;for(let i=o;i<s;i++){let a=n.data[i];if(a.contentQueries){let l=e[i];a.contentQueries(1,l,i)}}}finally{xt(r)}}}function t5(n,t,e){Kk()&&(d5(n,t,e,gs(e,t)),(e.flags&64)===64&&KA(n,t,e))}function n5(n,t,e=gs){let r=t.localNames;if(r!==null){let o=t.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?e(t,n):n[i];n[o++]=a}}}function jA(n){let t=n.tView;return t===null||t.incompleteFirstPass?n.tView=HA(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts,n.id):t}function HA(n,t,e,r,o,s,i,a,l,u,c){let p=du+r,f=p+o,d=r5(p,f),h=typeof u=="function"?u():u;return d[Ze]={type:n,blueprint:d,template:e,queries:null,viewQuery:a,declTNode:t,data:d.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:f,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:l,consts:h,incompleteFirstPass:!1,ssrId:c}}function r5(n,t){let e=[];for(let r=0;r<t;r++)e.push(r<n?null:wy);return e}function o5(n,t,e,r){let s=r.get(_q,DA)||e===fs.ShadowDom,i=n.selectRootElement(t,s);return s5(i),i}function s5(n){i5(n)}var i5=()=>null;function a5(n,t,e,r){let o=YA(t);o.push(e),n.firstCreatePass&&ZA(n).push(r,o.length-1)}function l5(n,t,e,r,o,s){let i=t?t.injectorIndex:-1,a=0;return j8()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function JD(n,t,e,r,o){for(let s in t){if(!t.hasOwnProperty(s))continue;let i=t[s];if(i===void 0)continue;r??={};let a,l=ip.None;Array.isArray(i)?(a=i[0],l=i[1]):a=i;let u=s;if(o!==null){if(!o.hasOwnProperty(s))continue;u=o[s]}n===0?ek(r,e,u,a,l):ek(r,e,u,a)}return r}function ek(n,t,e,r,o){let s;n.hasOwnProperty(e)?(s=n[e]).push(t,r):s=n[e]=[t,r],o!==void 0&&s.push(o)}function u5(n,t,e){let r=t.directiveStart,o=t.directiveEnd,s=n.data,i=t.attrs,a=[],l=null,u=null;for(let c=r;c<o;c++){let p=s[c],f=e?e.get(p):null,d=f?f.inputs:null,h=f?f.outputs:null;l=JD(0,p.inputs,c,l,d),u=JD(1,p.outputs,c,u,h);let g=l!==null&&i!==null&&!wI(t)?C5(l,c,i):null;a.push(g)}l!==null&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=u}function c5(n,t,e,r){if(Kk()){let o=r===null?null:{"":-1},s=m5(n,e),i,a;s===null?i=a=null:[i,a]=s,i!==null&&qA(n,t,e,i,o,a),o&&g5(e,r,o)}e.mergedAttrs=vI(e.mergedAttrs,e.attrs)}function qA(n,t,e,r,o,s){for(let u=0;u<r.length;u++)fq(fA(e,t),n,r[u].type);x5(e,n.data.length,r.length);for(let u=0;u<r.length;u++){let c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=UA(n,t,r.length,null);for(let u=0;u<r.length;u++){let c=r[u];e.mergedAttrs=vI(e.mergedAttrs,c.hostAttrs),b5(n,e,t,l,c),y5(l,c,o),c.contentQueries!==null&&(e.flags|=4),(c.hostBindings!==null||c.hostAttrs!==null||c.hostVars!==0)&&(e.flags|=64);let p=c.type.prototype;!i&&(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&&((n.preOrderHooks??=[]).push(e.index),i=!0),!a&&(p.ngOnChanges||p.ngDoCheck)&&((n.preOrderCheckHooks??=[]).push(e.index),a=!0),l++}u5(n,e,s)}function p5(n,t,e,r,o){let s=o.hostBindings;if(s){let i=n.hostBindingOpCodes;i===null&&(i=n.hostBindingOpCodes=[]);let a=~t.index;f5(i)!=a&&i.push(a),i.push(e,r,s)}}function f5(n){let t=n.length;for(;t>0;){let e=n[--t];if(typeof e=="number"&&e<0)return e}return 0}function d5(n,t,e,r){let o=e.directiveStart,s=e.directiveEnd;TI(e)&&v5(t,e,n.data[o+e.componentOffset]),n.firstCreatePass||fA(e,t),cp(r,t);let i=e.initialInputs;for(let a=o;a<s;a++){let l=n.data[a],u=up(t,n,a,e);if(cp(u,t),i!==null&&w5(t,a-o,u,l,e,i),_h(l)){let c=dp(e.index,t);c[ds]=up(t,n,a,e)}}}function KA(n,t,e){let r=e.directiveStart,o=e.directiveEnd,s=e.index,i=eq();try{gu(s);for(let a=r;a<o;a++){let l=n.data[a],u=t[a];U0(a),(l.hostBindings!==null||l.hostVars!==0||l.hostAttrs!==null)&&h5(l,u)}}finally{gu(-1),U0(i)}}function h5(n,t){n.hostBindings!==null&&n.hostBindings(1,t)}function m5(n,t){let e=n.directiveRegistry,r=null,o=null;if(e)for(let s=0;s<e.length;s++){let i=e[s];if(c8(t,i.selectors,!1))if(r||(r=[]),_h(i))if(i.findHostDirectiveDefs!==null){let a=[];o=o||new Map,i.findHostDirectiveDefs(i,a,o),r.unshift(...a,i);let l=a.length;Z0(n,t,l)}else r.unshift(i),Z0(n,t,0);else o=o||new Map,i.findHostDirectiveDefs?.(i,r,o),r.push(i)}return r===null?null:[r,o]}function Z0(n,t,e){t.componentOffset=e,(n.components??=[]).push(t.index)}function g5(n,t,e){if(t){let r=n.localNames=[];for(let o=0;o<t.length;o+=2){let s=e[t[o+1]];if(s==null)throw new Pe(-301,!1);r.push(t[o],s)}}}function y5(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;_h(t)&&(e[""]=n)}}function x5(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}function b5(n,t,e,r,o){n.data[r]=o;let s=o.factory||(o.factory=rp(o.type,!0)),i=new Nh(s,_h(o),VI);n.blueprint[r]=i,e[r]=i,p5(n,t,r,UA(n,e,o.hostVars,wy),o)}function v5(n,t,e){let r=gs(t,n),o=jA(e),s=n[Hs].rendererFactory,i=16;e.signals?i=4096:e.onPush&&(i=64);let a=GI(n,Cy(n,o,null,i,r,t,null,s.createRenderer(r,e),null,null,null));n[t.index]=a}function w5(n,t,e,r,o,s){let i=s[t];if(i!==null)for(let a=0;a<i.length;){let l=i[a++],u=i[a++],c=i[a++],p=i[a++];VA(r,e,l,u,c,p)}}function C5(n,t,e){let r=null,o=0;for(;o<e.length;){let s=e[o];if(s===0){o+=4;continue}else if(s===5){o+=2;continue}if(typeof s=="number")break;if(n.hasOwnProperty(s)){r===null&&(r=[]);let i=n[s];for(let a=0;a<i.length;a+=3)if(i[a]===t){r.push(s,i[a+1],i[a+2],e[o+1]);break}}o+=2}return r}function I5(n,t,e,r){return[n,!0,0,t,null,r,null,e,null,null]}function XA(n,t){let e=n.contentQueries;if(e!==null){let r=xt(null);try{for(let o=0;o<e.length;o+=2){let s=e[o],i=e[o+1];if(i!==-1){let a=n.data[i];EI(s),a.contentQueries(2,t[i],i)}}}finally{xt(r)}}}function GI(n,t){return n[Sh]?n[VD][Bo]=t:n[Sh]=t,n[VD]=t,t}function Q0(n,t,e){EI(0);let r=xt(null);try{t(n,e)}finally{xt(r)}}function YA(n){return n[ey]??=[]}function ZA(n){return n.cleanup??=[]}function QA(n,t){let e=n[ap],r=e?e.get(Ks,null):null;r&&r.handleError(t)}function JA(n,t,e,r,o){for(let s=0;s<e.length;){let i=e[s++],a=e[s++],l=e[s++],u=t[i],c=n.data[i];VA(c,u,r,a,l,o)}}function S5(n,t,e){let r=P8(t,n);Fq(n[co],r,e)}function T5(n,t){let e=dp(t,n),r=e[Ze];N5(r,e);let o=e[Ys];o!==null&&e[Jg]===null&&(e[Jg]=$I(o,e[ap])),WI(r,e,e[ds])}function N5(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])}function WI(n,t,e){DI(t);try{let r=n.viewQuery;r!==null&&Q0(1,r,e);let o=n.template;o!==null&&GA(n,t,o,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),t[qs]?.finishViewCreation(n),n.staticContentQueries&&XA(n,t),n.staticViewQueries&&Q0(2,n.viewQuery,e);let s=n.components;s!==null&&E5(t,s)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[Be]&=-5,kI()}}function E5(n,t){for(let e=0;e<t.length;e++)T5(n,t[e])}function D5(n,t,e,r){let o=xt(null);try{let s=t.tView,a=n[Be]&4096?4096:16,l=Cy(n,s,e,a,null,t,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),u=n[t.index];l[fu]=u;let c=n[qs];return c!==null&&(l[qs]=c.createEmbeddedView(s)),WI(s,l,e),l}finally{xt(o)}}function tk(n,t){return!t||t.firstChild===null||CA(n)}function k5(n,t,e,r=!0){let o=t[Ze];if(Bq(o,t,n,e),r){let i=Y0(e,n),a=t[co],l=BI(a,n[hu]);l!==null&&Pq(o,n[zo],a,t,l,i)}let s=t[Jg];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function iy(n,t,e,r,o=!1){for(;e!==null;){let s=t[e.index];s!==null&&r.push(ms(s)),Zs(s)&&A5(s,r);let i=e.type;if(i&8)iy(n,t,e.child,r);else if(i&32){let a=PI(e,t),l;for(;l=a();)r.push(l)}else if(i&16){let a=$A(t,e);if(Array.isArray(a))r.push(...a);else{let l=mu(t[hs]);iy(l[Ze],l,a,r,!0)}}e=o?e.projectionNext:e.next}return r}function A5(n,t){for(let e=Xr;e<n.length;e++){let r=n[e],o=r[Ze].firstChild;o!==null&&iy(r[Ze],r,o,t)}n[hu]!==n[Ys]&&t.push(n[hu])}var eR=[];function R5(n){return n[lo]??_5(n)}function _5(n){let t=eR.pop()??Object.create(M5);return t.lView=n,t}function O5(n){n.lView[lo]!==n&&(n.lView=null,eR.push(n))}var M5=dn(Te({},JC),{consumerIsAlwaysLive:!0,consumerMarkedDirty:n=>{xy(n.lView)},consumerOnSignalRead(){this.lView[lo]=this}});function F5(n){let t=n[lo]??Object.create($5);return t.lView=n,t}var $5=dn(Te({},JC),{consumerIsAlwaysLive:!0,consumerMarkedDirty:n=>{let t=mu(n.lView);for(;t&&!tR(t[Ze]);)t=mu(t);t&&jk(t)},consumerOnSignalRead(){this.lView[lo]=this}});function tR(n){return n.type!==2}var P5=100;function nR(n,t=!0,e=0){let r=n[Hs],o=r.rendererFactory,s=!1;s||o.begin?.();try{L5(n,e)}catch(i){throw t&&QA(n,i),i}finally{s||(o.end?.(),r.inlineEffectRunner?.flush())}}function L5(n,t){let e=Zk();try{WD(!0),J0(n,t);let r=0;for(;Th(n);){if(r===P5)throw new Pe(103,!1);r++,J0(n,1)}}finally{WD(e)}}function B5(n,t,e,r){let o=t[Be];if((o&256)===256)return;let s=!1,i=!1;!s&&t[Hs].inlineEffectRunner?.flush(),DI(t);let a=!0,l=null,u=null;s||(tR(n)?(u=R5(t),l=e0(u)):eD()===null?(a=!1,u=F5(t),l=e0(u)):t[lo]&&(n0(t[lo]),t[lo]=null));try{Wk(t),Y8(n.bindingStartIndex),e!==null&&GA(n,t,e,2,r);let c=(o&3)===3;if(!s)if(c){let d=n.preOrderCheckHooks;d!==null&&Wg(t,d,null)}else{let d=n.preOrderHooks;d!==null&&jg(t,d,0,null),S0(t,0)}if(i||z5(t),rR(t,0),n.contentQueries!==null&&XA(n,t),!s)if(c){let d=n.contentCheckHooks;d!==null&&Wg(t,d)}else{let d=n.contentHooks;d!==null&&jg(t,d,1),S0(t,1)}Jq(n,t);let p=n.components;p!==null&&sR(t,p,0);let f=n.viewQuery;if(f!==null&&Q0(2,f,r),!s)if(c){let d=n.viewCheckHooks;d!==null&&Wg(t,d)}else{let d=n.viewHooks;d!==null&&jg(t,d,2),S0(t,2)}if(n.firstUpdatePass===!0&&(n.firstUpdatePass=!1),t[I0]){for(let d of t[I0])d();t[I0]=null}s||(t[Be]&=-73)}catch(c){throw s||xy(t),c}finally{u!==null&&(tD(u,l),a&&O5(u)),kI()}}function rR(n,t){for(let e=SA(n);e!==null;e=TA(e))for(let r=Xr;r<e.length;r++){let o=e[r];oR(o,t)}}function z5(n){for(let t=SA(n);t!==null;t=TA(t)){if(!(t[Be]&ny.HasTransplantedViews))continue;let e=t[lp];for(let r=0;r<e.length;r++){let o=e[r];jk(o)}}}function V5(n,t,e){let r=dp(t,n);oR(r,e)}function oR(n,t){NI(n)&&J0(n,t)}function J0(n,t){let r=n[Ze],o=n[Be],s=n[lo],i=!!(t===0&&o&16);if(i||=!!(o&64&&t===0),i||=!!(o&1024),i||=!!(s?.dirty&&t0(s)),i||=!1,s&&(s.dirty=!1),n[Be]&=-9217,i)B5(r,n,r.template,n[ds]);else if(o&8192){rR(n,1);let a=r.components;a!==null&&sR(n,a,1)}}function sR(n,t,e){for(let r=0;r<t.length;r++)V5(n,t[r],e)}function jI(n,t){let e=Zk()?64:1088;for(n[Hs].changeDetectionScheduler?.notify(t);n;){n[Be]|=e;let r=mu(n);if(B0(n)&&!r)return n;n=r}return null}var xu=class{get rootNodes(){let t=this._lView,e=t[Ze];return iy(e,t,e.firstChild,[])}constructor(t,e,r=!0){this._lView=t,this._cdRefInjectingView=e,this.notifyErrorHandler=r,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[ds]}set context(t){this._lView[ds]=t}get destroyed(){return(this._lView[Be]&256)===256}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let t=this._lView[tr];if(Zs(t)){let e=t[ty],r=e?e.indexOf(this):-1;r>-1&&(X0(t,r),Zg(e,r))}this._attachedToViewContainer=!1}OA(this._lView[Ze],this._lView)}onDestroy(t){Hk(this._lView,t)}markForCheck(){jI(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[Be]&=-129}reattach(){V0(this._lView),this._lView[Be]|=128}detectChanges(){this._lView[Be]|=1024,nR(this._lView,this.notifyErrorHandler)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Pe(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let t=B0(this._lView),e=this._lView[fu];e!==null&&!t&&LI(e,this._lView),RA(this._lView[Ze],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Pe(902,!1);this._appRef=t;let e=B0(this._lView),r=this._lView[fu];r!==null&&!e&&_A(r,this._lView),V0(this._lView)}},Eh=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=W5;let n=t;return n})(),U5=Eh,G5=class extends U5{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(t,e){return this.createEmbeddedViewImpl(t,e)}createEmbeddedViewImpl(t,e,r){let o=D5(this._declarationLView,this._declarationTContainer,t,{embeddedViewInjector:e,dehydratedView:r});return new xu(o)}};function W5(){return HI(Vo(),Dn())}function HI(n,t){return n.type&4?new G5(t,n,hp(n,t)):null}var Uve=new RegExp(`^(\\d+)*(${Aq}|${kq})*(.*)`);var j5=()=>null;function nk(n,t){return j5(n,t)}var Dh=class{},qI=new Qe("",{providedIn:"root",factory:()=>!1});var iR=new Qe(""),eI=class{},ay=class{};function H5(n){let t=Error(`No component factory found for ${Kr(n)}.`);return t[q5]=n,t}var q5="ngComponent";var tI=class{resolveComponentFactory(t){throw H5(t)}},nS=class nS{};nS.NULL=new tI;var pp=nS,fp=class{};var K5=(()=>{let t=class t{};t.\u0275prov=je({token:t,providedIn:"root",factory:()=>null});let n=t;return n})(),D0={};var rk=new Set;function KI(n){rk.has(n)||(rk.add(n),performance?.mark?.("mark_feature_usage",{detail:{feature:n}}))}function aR(n){let t=!0;return setTimeout(()=>{t&&(t=!1,n())}),typeof R0.requestAnimationFrame=="function"&&R0.requestAnimationFrame(()=>{t&&(t=!1,n())}),()=>{t=!1}}function ok(n){let t=!0;return queueMicrotask(()=>{t&&n()}),()=>{t=!1}}function sk(...n){}var yn=class n{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new er(!1),this.onMicrotaskEmpty=new er(!1),this.onStable=new er(!1),this.onError=new er(!1),typeof Zone>"u")throw new Pe(908,!1);Zone.assertZonePatched();let o=this;o._nesting=0,o._outer=o._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(o._inner=o._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(o._inner=o._inner.fork(Zone.longStackTraceZoneSpec)),o.shouldCoalesceEventChangeDetection=!r&&e,o.shouldCoalesceRunChangeDetection=r,o.callbackScheduled=!1,Z5(o)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get("isAngularZone")===!0}static assertInAngularZone(){if(!n.isInAngularZone())throw new Pe(909,!1)}static assertNotInAngularZone(){if(n.isInAngularZone())throw new Pe(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,t,X5,sk,sk);try{return s.runTask(i,e,r)}finally{s.cancelTask(i)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}},X5={};function XI(n){if(n._nesting==0&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function Y5(n){n.isCheckStableRunning||n.callbackScheduled||(n.callbackScheduled=!0,Zone.root.run(()=>{aR(()=>{n.callbackScheduled=!1,nI(n),n.isCheckStableRunning=!0,XI(n),n.isCheckStableRunning=!1})}),nI(n))}function Z5(n){let t=()=>{Y5(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,o,s,i,a)=>{if(Q5(a))return e.invokeTask(o,s,i,a);try{return ik(n),e.invokeTask(o,s,i,a)}finally{(n.shouldCoalesceEventChangeDetection&&s.type==="eventTask"||n.shouldCoalesceRunChangeDetection)&&t(),ak(n)}},onInvoke:(e,r,o,s,i,a,l)=>{try{return ik(n),e.invoke(o,s,i,a,l)}finally{n.shouldCoalesceRunChangeDetection&&!n.callbackScheduled&&!J5(a)&&t(),ak(n)}},onHasTask:(e,r,o,s)=>{e.hasTask(o,s),r===o&&(s.change=="microTask"?(n._hasPendingMicrotasks=s.microTask,nI(n),XI(n)):s.change=="macroTask"&&(n.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,r,o,s)=>(e.handleError(o,s),n.runOutsideAngular(()=>n.onError.emit(s)),!1)})}function nI(n){n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&n.callbackScheduled===!0?n.hasPendingMicrotasks=!0:n.hasPendingMicrotasks=!1}function ik(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function ak(n){n._nesting--,XI(n)}var rI=class{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new er,this.onMicrotaskEmpty=new er,this.onStable=new er,this.onError=new er}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,o){return t.apply(e,r)}};function Q5(n){return lR(n,"__ignore_ng_zone__")}function J5(n){return lR(n,"__scheduler_tick__")}function lR(n,t){return!Array.isArray(n)||n.length!==1?!1:n[0]?.data?.[t]===!0}var uR=(()=>{let t=class t{constructor(){this.handler=null,this.internalCallbacks=[]}execute(){this.executeInternalCallbacks(),this.handler?.execute()}executeInternalCallbacks(){let r=[...this.internalCallbacks];this.internalCallbacks.length=0;for(let o of r)o()}ngOnDestroy(){this.handler?.destroy(),this.handler=null,this.internalCallbacks.length=0}};t.\u0275prov=je({token:t,providedIn:"root",factory:()=>new t});let n=t;return n})();function oI(n,t,e){let r=e?n.styles:null,o=e?n.classes:null,s=0;if(t!==null)for(let i=0;i<t.length;i++){let a=t[i];if(typeof a=="number")s=a;else if(s==1)o=RD(o,a);else if(s==2){let l=a,u=t[++i];r=RD(r,l+": "+u+";")}}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=o:n.classesWithoutHost=o}var ly=class extends pp{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){let e=pu(t);return new kh(e,this.ngModule)}};function lk(n){let t=[];for(let e in n){if(!n.hasOwnProperty(e))continue;let r=n[e];r!==void 0&&t.push({propName:Array.isArray(r)?r[0]:r,templateName:e})}return t}function eK(n){let t=n.toLowerCase();return t==="svg"?F8:t==="math"?$8:null}var sI=class{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=fy(r);let o=this.injector.get(t,D0,r);return o!==D0||e===D0?o:this.parentInjector.get(t,e,r)}},kh=class extends ay{get inputs(){let t=this.componentDef,e=t.inputTransforms,r=lk(t.inputs);if(e!==null)for(let o of r)e.hasOwnProperty(o.propName)&&(o.transform=e[o.propName]);return r}get outputs(){return lk(this.componentDef.outputs)}constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=h8(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}create(t,e,r,o){let s=xt(null);try{o=o||this.ngModule;let i=o instanceof uo?o:o?.injector;i&&this.componentDef.getStandaloneInjector!==null&&(i=this.componentDef.getStandaloneInjector(i)||i);let a=i?new sI(t,i):t,l=a.get(fp,null);if(l===null)throw new Pe(407,!1);let u=a.get(K5,null),c=a.get(uR,null),p=a.get(Dh,null),f={rendererFactory:l,sanitizer:u,inlineEffectRunner:null,afterRenderEventManager:c,changeDetectionScheduler:p},d=l.createRenderer(null,this.componentDef),h=this.componentDef.selectors[0][0]||"div",g=r?o5(d,r,this.componentDef.encapsulation,a):AA(d,h,eK(h)),m=512;this.componentDef.signals?m|=4096:this.componentDef.onPush||(m|=16);let y=null;g!==null&&(y=$I(g,a,!0));let x=HA(0,null,null,1,0,null,null,null,null,null,null),v=Cy(null,x,null,m,null,null,f,d,a,null,y);DI(v);let w,S;try{let k=this.componentDef,A,_=null;k.findHostDirectiveDefs?(A=[],_=new Map,k.findHostDirectiveDefs(k,A,_),A.push(k)):A=[k];let F=tK(v,g),$=nK(F,g,k,A,v,f,d);S=L8(x,du),g&&sK(d,k,g,r),e!==void 0&&iK(S,this.ngContentSelectors,e),w=oK($,k,A,_,v,[aK]),WI(x,v,null)}finally{kI()}return new iI(this.componentType,w,hp(S,v),v,S)}finally{xt(s)}}},iI=class extends eI{constructor(t,e,r,o,s){super(),this.location=r,this._rootLView=o,this._tNode=s,this.previousInputValues=null,this.instance=e,this.hostView=this.changeDetectorRef=new xu(o,void 0,!1),this.componentType=t}setInput(t,e){let r=this._tNode.inputs,o;if(r!==null&&(o=r[t])){if(this.previousInputValues??=new Map,this.previousInputValues.has(t)&&Object.is(this.previousInputValues.get(t),e))return;let s=this._rootLView;JA(s[Ze],s,o,t,e),this.previousInputValues.set(t,e);let i=dp(this._tNode.index,s);jI(i,1)}}get injector(){return new cu(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}};function tK(n,t){let e=n[Ze],r=du;return n[r]=t,UI(e,r,2,"#host",null)}function nK(n,t,e,r,o,s,i){let a=o[Ze];rK(r,n,t,i);let l=null;t!==null&&(l=$I(t,o[ap]));let u=s.rendererFactory.createRenderer(t,e),c=16;e.signals?c=4096:e.onPush&&(c=64);let p=Cy(o,jA(e),null,c,o[n.index],n,s,u,null,null,l);return a.firstCreatePass&&Z0(a,n,r.length-1),GI(o,p),o[n.index]=p}function rK(n,t,e,r){for(let o of n)t.mergedAttrs=vI(t.mergedAttrs,o.hostAttrs);t.mergedAttrs!==null&&(oI(t,t.mergedAttrs,!0),e!==null&&LA(r,e,t))}function oK(n,t,e,r,o,s){let i=Vo(),a=o[Ze],l=gs(i,o);qA(a,o,i,e,null,r);for(let c=0;c<e.length;c++){let p=i.directiveStart+c,f=up(o,a,p,i);cp(f,o)}KA(a,o,i),l&&cp(l,o);let u=up(o,a,i.directiveStart+i.componentOffset,i);if(n[ds]=o[ds]=u,s!==null)for(let c of s)c(u,t);return WA(a,i,o),u}function sK(n,t,e,r){if(r)M0(n,e,["ng-version","18.0.3"]);else{let{attrs:o,classes:s}=m8(t.selectors[0]);o&&M0(n,e,o),s&&s.length>0&&PA(n,e,s.join(" "))}}function iK(n,t,e){let r=n.projection=[];for(let o=0;o<t.length;o++){let s=e[o];r.push(s!=null?Array.from(s):null)}}function aK(){let n=Vo();aA(Dn()[Ze],n)}var yp=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=lK;let n=t;return n})();function lK(){let n=Vo();return pR(n,Dn())}var uK=yp,cR=class extends uK{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return hp(this._hostTNode,this._hostLView)}get injector(){return new cu(this._hostTNode,this._hostLView)}get parentInjector(){let t=RI(this._hostTNode,this._hostLView);if(uA(t)){let e=oy(t,this._hostLView),r=ry(t),o=e[Ze].data[r+8];return new cu(o,e)}else return new cu(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){let e=uk(this._lContainer);return e!==null&&e[t]||null}get length(){return this._lContainer.length-Xr}createEmbeddedView(t,e,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=nk(this._lContainer,t.ssrId),a=t.createEmbeddedViewImpl(e||{},s,i);return this.insertImpl(a,o,tk(this._hostTNode,i)),a}createComponent(t,e,r,o,s){let i=t&&!R8(t),a;if(i)a=e;else{let h=e||{};a=h.index,r=h.injector,o=h.projectableNodes,s=h.environmentInjector||h.ngModuleRef}let l=i?t:new kh(pu(t)),u=r||this.parentInjector;if(!s&&l.ngModule==null){let g=(i?u:this.parentInjector).get(uo,null);g&&(s=g)}let c=pu(l.componentType??{}),p=nk(this._lContainer,c?.id??null),f=p?.firstChild??null,d=l.create(u,o,f,s);return this.insertImpl(d.hostView,a,tk(this._hostTNode,p)),d}insert(t,e){return this.insertImpl(t,e,!0)}insertImpl(t,e,r){let o=t._lView;if(z8(o)){let a=this.indexOf(t);if(a!==-1)this.detach(a);else{let l=o[tr],u=new cR(l,l[zo],l[tr]);u.detach(u.indexOf(t))}}let s=this._adjustIndex(e),i=this._lContainer;return k5(i,o,s,r),t.attachToViewContainerRef(),Ck(k0(i),s,t),t}move(t,e){return this.insert(t,e)}indexOf(t){let e=uk(this._lContainer);return e!==null?e.indexOf(t):-1}remove(t){let e=this._adjustIndex(t,-1),r=X0(this._lContainer,e);r&&(Zg(k0(this._lContainer),e),OA(r[Ze],r))}detach(t){let e=this._adjustIndex(t,-1),r=X0(this._lContainer,e);return r&&Zg(k0(this._lContainer),e)!=null?new xu(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function uk(n){return n[ty]}function k0(n){return n[ty]||(n[ty]=[])}function pR(n,t){let e,r=t[n.index];return Zs(r)?e=r:(e=I5(r,t,null,n),t[n.index]=e,GI(t,e)),pK(e,t,n,r),new cR(e,n,t)}function cK(n,t){let e=n[co],r=e.createComment(""),o=gs(t,n),s=BI(e,o);return sy(e,s,r,jq(e,o),!1),r}var pK=fK;function fK(n,t,e,r){if(n[hu])return;let o;e.type&8?o=ms(r):o=cK(t,e),n[hu]=o}var aI=class n{constructor(t){this.queryList=t,this.matches=null}clone(){return new n(this.queryList)}setDirty(){this.queryList.setDirty()}},lI=class n{constructor(t=[]){this.queries=t}createEmbeddedView(t){let e=t.queries;if(e!==null){let r=t.contentQueries!==null?t.contentQueries[0]:e.length,o=[];for(let s=0;s<r;s++){let i=e.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new n(o)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}finishViewCreation(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)YI(t,e).matches!==null&&this.queries[e].setDirty()}},uI=class{constructor(t,e,r=null){this.flags=e,this.read=r,typeof t=="string"?this.predicate=vK(t):this.predicate=t}},cI=class n{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){let o=e!==null?e.length:0,s=this.getByIndex(r).embeddedTView(t,o);s&&(s.indexInDeclarationView=r,e!==null?e.push(s):e=[s])}return e!==null?new n(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}},pI=class n{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new n(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let e=this._declarationNodeIndex,r=t.parent;for(;r!==null&&r.type&8&&r.index!==e;)r=r.parent;return e===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(t,e,dK(e,s)),this.matchTNodeWithReadOption(t,e,Hg(e,t,s,!1,!1))}else r===Eh?e.type&4&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Hg(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===vu||o===yp||o===Eh&&e.type&4)this.addMatch(e.index,-2);else{let s=Hg(e,t,o,!1,!1);s!==null&&this.addMatch(e.index,s)}else this.addMatch(e.index,r)}}addMatch(t,e){this.matches===null?this.matches=[t,e]:this.matches.push(t,e)}};function dK(n,t){let e=n.localNames;if(e!==null){for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1]}return null}function hK(n,t){return n.type&11?hp(n,t):n.type&4?HI(n,t):null}function mK(n,t,e,r){return e===-1?hK(t,n):e===-2?gK(n,t,r):up(n,n[Ze],e,t)}function gK(n,t,e){if(e===vu)return hp(t,n);if(e===Eh)return HI(t,n);if(e===yp)return pR(t,n)}function fR(n,t,e,r){let o=t[qs].queries[r];if(o.matches===null){let s=n.data,i=e.matches,a=[];for(let l=0;i!==null&&l<i.length;l+=2){let u=i[l];if(u<0)a.push(null);else{let c=s[u];a.push(mK(t,c,i[l+1],e.metadata.read))}}o.matches=a}return o.matches}function fI(n,t,e,r){let o=n.queries.getByIndex(e),s=o.matches;if(s!==null){let i=fR(n,t,o,e);for(let a=0;a<s.length;a+=2){let l=s[a];if(l>0)r.push(i[a/2]);else{let u=s[a+1],c=t[-l];for(let p=Xr;p<c.length;p++){let f=c[p];f[fu]===f[tr]&&fI(f[Ze],f,u,r)}if(c[lp]!==null){let p=c[lp];for(let f=0;f<p.length;f++){let d=p[f];fI(d[Ze],d,u,r)}}}}}return r}function yK(n,t){return n[qs].queries[t].queryList}function xK(n,t,e){let r=new q0((e&4)===4);return a5(n,t,r,r.destroy),(t[qs]??=new lI).queries.push(new aI(r))-1}function bK(n,t,e){let r=bu();return r.firstCreatePass&&(wK(r,new uI(n,t,e),-1),(t&2)===2&&(r.staticViewQueries=!0)),xK(r,Dn(),t)}function vK(n){return n.split(",").map(t=>t.trim())}function wK(n,t,e){n.queries===null&&(n.queries=new cI),n.queries.track(new pI(t,e))}function YI(n,t){return n.queries.getByIndex(t)}function CK(n,t){let e=n[Ze],r=YI(e,t);return r.crossesNgTemplate?fI(e,n,t,[]):fR(e,n,r,t)}var Ta=class{},Ah=class{};var dI=class extends Ta{constructor(t,e,r){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new ly(this);let o=Ak(t);this._bootstrapComponents=kA(o.bootstrap),this._r3Injector=bA(t,e,[{provide:Ta,useValue:this},{provide:pp,useValue:this.componentFactoryResolver},...r],Kr(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){let t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}},hI=class extends Ah{constructor(t){super(),this.moduleType=t}create(t){return new dI(this.moduleType,t,[])}};var uy=class extends Ta{constructor(t){super(),this.componentFactoryResolver=new ly(this),this.instance=null;let e=new Ih([...t.providers,{provide:Ta,useValue:this},{provide:pp,useValue:this.componentFactoryResolver}],t.parent||SI(),t.debugName,new Set(["environment"]));this.injector=e,t.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}};function ZI(n,t,e=null){return new uy({providers:n,parent:t,debugName:e,runEnvironmentInitializers:!0}).injector}function IK(n,t,e){let r=n[t];return Object.is(r,e)?!1:(n[t]=e,!0)}function SK(n){return(n.flags&32)===32}function TK(n,t,e,r){return IK(n,Z8(),e)?t+bk(e)+r:wy}function ck(n,t,e,r,o){let s=t.inputs,i=o?"class":"style";JA(n,e,s[i],i,r)}function NK(n,t,e,r,o,s){let i=t.consts,a=GD(i,o),l=UI(t,n,2,r,a);return c5(t,e,l,GD(i,s)),l.attrs!==null&&oI(l,l.attrs,!1),l.mergedAttrs!==null&&oI(l,l.mergedAttrs,!0),t.queries!==null&&t.queries.elementStart(t,l),l}function Cu(n,t,e,r){let o=Dn(),s=bu(),i=du+n,a=o[co],l=s.firstCreatePass?NK(i,s,o,t,e,r):s.data[i],u=EK(s,o,l,a,t,n);o[i]=u;let c=Bk(l);return by(l,!0),LA(a,u,l),!SK(l)&&sA()&&FA(s,o,u,l),U8()===0&&cp(u,o),G8(),c&&(t5(s,o,l),WA(s,l,o)),r!==null&&n5(o,l),Cu}function Iu(){let n=Vo();Yk()?X8():(n=n.parent,by(n,!1));let t=n;H8(t)&&q8(),W8();let e=bu();return e.firstCreatePass&&(aA(e,n),Lk(n)&&e.queries.elementEnd(n)),t.classesWithoutHost!=null&&iq(t)&&ck(e,t,Dn(),t.classesWithoutHost,!0),t.stylesWithoutHost!=null&&aq(t)&&ck(e,t,Dn(),t.stylesWithoutHost,!1),Iu}function Fh(n,t,e,r){return Cu(n,t,e,r),Iu(),Fh}var EK=(n,t,e,r,o,s)=>(iA(!0),AA(r,o,nq()));function dR(){return Dn()}var cy="en-US";var DK=cy;function kK(n){typeof n=="string"&&(DK=n.toLowerCase().replace(/_/g,"-"))}var AK=(n,t,e)=>{};function Su(n,t,e,r){let o=Dn(),s=bu(),i=Vo();return _K(s,o,o[co],i,n,t,r),Su}function RK(n,t,e,r){let o=n.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===e&&o[s+1]===r){let a=t[ey],l=o[s+2];return a.length>l?a[l]:null}typeof i=="string"&&(s+=2)}return null}function _K(n,t,e,r,o,s,i){let a=Bk(r),u=n.firstCreatePass&&ZA(n),c=t[ds],p=YA(t),f=!0;if(r.type&3||i){let g=gs(r,t),m=i?i(g):g,y=p.length,x=i?w=>i(ms(w[r.index])):r.index,v=null;if(!i&&a&&(v=RK(n,t,o,r.index)),v!==null){let w=v.__ngLastListenerFn__||v;w.__ngNextListenerFn__=s,v.__ngLastListenerFn__=s,f=!1}else{s=fk(r,t,c,s),AK(g,o,s);let w=e.listen(m,o,s);p.push(s,w),u&&u.push(o,x,y,y+1)}}else s=fk(r,t,c,s);let d=r.outputs,h;if(f&&d!==null&&(h=d[o])){let g=h.length;if(g)for(let m=0;m<g;m+=2){let y=h[m],x=h[m+1],S=t[y][x].subscribe(s),k=p.length;p.push(s,S),u&&u.push(o,r.index,k,-(k+1))}}}function pk(n,t,e,r){let o=xt(null);try{return cs(6,t,e),e(r)!==!1}catch(s){return QA(n,s),!1}finally{cs(7,t,e),xt(o)}}function fk(n,t,e,r){return function o(s){if(s===Function)return r;let i=n.componentOffset>-1?dp(n.index,t):t;jI(i,5);let a=pk(t,e,r,s),l=o.__ngNextListenerFn__;for(;l;)a=pk(t,e,l,s)&&a,l=l.__ngNextListenerFn__;return a}}function Iy(n,t,e){bK(n,t,e)}function $h(n){let t=Dn(),e=bu(),r=Qk();EI(r+1);let o=YI(e,r);if(n.dirty&&B8(t)===((o.metadata.flags&2)===2)){if(o.matches===null)n.reset([]);else{let s=CK(t,r);n.reset(s,wq),n.notifyOnChanges()}return!0}return!1}function Ph(){return yK(Dn(),Qk())}function Sy(n,t=""){let e=Dn(),r=bu(),o=n+du,s=r.firstCreatePass?UI(r,o,1,t,null):r.data[o],i=OK(r,e,s,t,n);e[o]=i,sA()&&FA(r,e,i,s),by(s,!1)}var OK=(n,t,e,r,o)=>(iA(!0),Mq(t[co],r));function QI(n,t,e){let r=Dn(),o=TK(r,n,t,e);return o!==wy&&S5(r,AI(),o),QI}var MK=(()=>{let t=class t{constructor(r){this._injector=r,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(r){if(!r.standalone)return null;if(!this.cachedInjectors.has(r)){let o=Ok(!1,r.type),s=o.length>0?ZI([o],this._injector,`Standalone[${r.type.name}]`):null;this.cachedInjectors.set(r,s)}return this.cachedInjectors.get(r)}ngOnDestroy(){try{for(let r of this.cachedInjectors.values())r!==null&&r.destroy()}finally{this.cachedInjectors.clear()}}};t.\u0275prov=je({token:t,providedIn:"environment",factory:()=>new t(it(uo))});let n=t;return n})();function Ty(n){KI("NgStandalone"),n.getStandaloneInjector=t=>t.get(MK).getOrCreateStandaloneInjector(n)}var Ny=(()=>{let t=class t{log(r){console.log(r)}warn(r){console.warn(r)}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"platform"});let n=t;return n})();var hR=new Qe("");function Lh(n){return!!n&&typeof n.then=="function"}function mR(n){return!!n&&typeof n.subscribe=="function"}var gR=new Qe(""),yR=(()=>{let t=class t{constructor(){this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,o)=>{this.resolve=r,this.reject=o}),this.appInits=ge(gR,{optional:!0})??[]}runInitializers(){if(this.initialized)return;let r=[];for(let s of this.appInits){let i=s();if(Lh(i))r.push(i);else if(mR(i)){let a=new Promise((l,u)=>{i.subscribe({complete:l,error:u})});r.push(a)}}let o=()=>{this.done=!0,this.resolve()};Promise.all(r).then(()=>{o()}).catch(s=>{this.reject(s)}),r.length===0&&o(),this.initialized=!0}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),JI=new Qe("");function FK(){nD(()=>{throw new Pe(600,!1)})}function $K(n){return n.isBoundToModule}var PK=10;function LK(n,t,e){try{let r=e();return Lh(r)?r.catch(o=>{throw t.runOutsideAngular(()=>n.handleError(o)),o}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}var xp=(()=>{let t=class t{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=ge(vA),this.afterRenderEffectManager=ge(uR),this.zonelessEnabled=ge(qI),this.externalTestViews=new Set,this.beforeRender=new mr,this.afterTick=new mr,this.componentTypes=[],this.components=[],this.isStable=ge(mp).hasPendingTasks.pipe(st(r=>!r)),this._injector=ge(uo)}get allViews(){return[...this.externalTestViews.keys(),...this._views]}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(r,o){let s=r instanceof ay;if(!this._injector.get(yR).done){let d=!s&&kk(r),h=!1;throw new Pe(405,h)}let a;s?a=r:a=this._injector.get(pp).resolveComponentFactory(r),this.componentTypes.push(a.componentType);let l=$K(a)?void 0:this._injector.get(Ta),u=o||a.selector,c=a.create(yu.NULL,[],u,l),p=c.location.nativeElement,f=c.injector.get(hR,null);return f?.registerApplication(p),c.onDestroy(()=>{this.detachView(c.hostView),A0(this.components,c),f?.unregisterApplication(p)}),this._loadComponent(c),c}tick(){this._tick(!0)}_tick(r){if(this._runningTick)throw new Pe(101,!1);let o=xt(null);try{this._runningTick=!0,this.detectChangesInAttachedViews(r)}catch(s){this.internalErrorHandler(s)}finally{this._runningTick=!1,xt(o),this.afterTick.next()}}detectChangesInAttachedViews(r){let o=null;this._injector.destroyed||(o=this._injector.get(fp,null,{optional:!0}));let s=0,i=this.afterRenderEffectManager;for(;s<PK;){let a=s===0;if(r||!a){this.beforeRender.next(a);for(let{_lView:l,notifyErrorHandler:u}of this._views)BK(l,u,a,this.zonelessEnabled)}else o?.begin?.(),o?.end?.();if(s++,i.executeInternalCallbacks(),!this.allViews.some(({_lView:l})=>Th(l))&&(i.execute(),!this.allViews.some(({_lView:l})=>Th(l))))break}}attachView(r){let o=r;this._views.push(o),o.attachToAppRef(this)}detachView(r){let o=r;A0(this._views,o),o.detachFromAppRef()}_loadComponent(r){this.attachView(r.hostView),this.tick(),this.components.push(r);let o=this._injector.get(JI,[]);[...this._bootstrapListeners,...o].forEach(s=>s(r))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(r=>r()),this._views.slice().forEach(r=>r.destroy())}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(r){return this._destroyListeners.push(r),()=>A0(this._destroyListeners,r)}destroy(){if(this._destroyed)throw new Pe(406,!1);let r=this._injector;r.destroy&&!r.destroyed&&r.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();function A0(n,t){let e=n.indexOf(t);e>-1&&n.splice(e,1)}function BK(n,t,e,r){if(!e&&!Th(n))return;nR(n,t,e&&!r?0:1)}var mI=class{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}},eS=(()=>{let t=class t{compileModuleSync(r){return new hI(r)}compileModuleAsync(r){return Promise.resolve(this.compileModuleSync(r))}compileModuleAndAllComponentsSync(r){let o=this.compileModuleSync(r),s=Ak(r),i=kA(s.declarations).reduce((a,l)=>{let u=pu(l);return u&&a.push(new kh(u)),a},[]);return new mI(o,i)}compileModuleAndAllComponentsAsync(r){return Promise.resolve(this.compileModuleAndAllComponentsSync(r))}clearCache(){}clearCacheFor(r){}getModuleId(r){}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();var zK=(()=>{let t=class t{constructor(){this.zone=ge(yn),this.changeDetectionScheduler=ge(Dh),this.applicationRef=ge(xp)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),VK=new Qe("",{factory:()=>!1});function xR({ngZoneFactory:n,ignoreChangesOutsideZone:t}){return n??=()=>new yn(vR()),[{provide:yn,useFactory:n},{provide:sp,multi:!0,useFactory:()=>{let e=ge(zK,{optional:!0});return()=>e.initialize()}},{provide:sp,multi:!0,useFactory:()=>{let e=ge(GK);return()=>{e.initialize()}}},{provide:vA,useFactory:UK},t===!0?{provide:iR,useValue:!0}:[]]}function UK(){let n=ge(yn),t=ge(Ks);return e=>n.runOutsideAngular(()=>t.handleError(e))}function bR(n){let t=n?.ignoreChangesOutsideZone,e=xR({ngZoneFactory:()=>{let r=vR(n);return r.shouldCoalesceEventChangeDetection&&KI("NgZone_CoalesceEvent"),new yn(r)},ignoreChangesOutsideZone:t});return hy([{provide:VK,useValue:!0},{provide:qI,useValue:!1},e])}function vR(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:n?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:n?.runCoalescing??!1}}var GK=(()=>{let t=class t{constructor(){this.subscription=new gn,this.initialized=!1,this.zone=ge(yn),this.pendingTasks=ge(mp)}initialize(){if(this.initialized)return;this.initialized=!0;let r=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(r=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{yn.assertNotInAngularZone(),queueMicrotask(()=>{r!==null&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(r),r=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{yn.assertInAngularZone(),r??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();var WK=(()=>{let t=class t{constructor(){this.appRef=ge(xp),this.taskService=ge(mp),this.ngZone=ge(yn),this.zonelessEnabled=ge(qI),this.disableScheduling=ge(iR,{optional:!0})??!1,this.zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run,this.schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}],this.subscriptions=new gn,this.cancelScheduledCallback=null,this.shouldRefreshViews=!1,this.useMicrotaskScheduler=!1,this.runningTick=!1,this.pendingRenderTaskId=null,this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof rI||!this.zoneIsDefined)}notify(r){if(!this.zonelessEnabled&&r===5)return;switch(r){case 3:case 2:case 0:case 4:case 5:case 1:{this.shouldRefreshViews=!0;break}case 8:case 7:case 6:case 9:default:}if(!this.shouldScheduleTick())return;let o=this.useMicrotaskScheduler?ok:aR;this.pendingRenderTaskId=this.taskService.add(),this.zoneIsDefined?Zone.root.run(()=>{this.cancelScheduledCallback=o(()=>{this.tick(this.shouldRefreshViews)})}):this.cancelScheduledCallback=o(()=>{this.tick(this.shouldRefreshViews)})}shouldScheduleTick(){return!(this.disableScheduling||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&yn.isInAngularZone())}tick(r){if(this.runningTick||this.appRef.destroyed)return;let o=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick(r)},void 0,this.schedulerTickApplyArgs)}catch(s){throw this.taskService.remove(o),s}finally{this.cleanup()}this.useMicrotaskScheduler=!0,ok(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(o)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.shouldRefreshViews=!1,this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let r=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(r)}}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();function jK(){return typeof $localize<"u"&&$localize.locale||cy}var tS=new Qe("",{providedIn:"root",factory:()=>ge(tS,Ye.Optional|Ye.SkipSelf)||jK()});var wR=new Qe("");var Kg=null;function HK(n=[],t){return yu.create({name:t,providers:[{provide:my,useValue:"platform"},{provide:wR,useValue:new Set([()=>Kg=null])},...n]})}function qK(n=[]){if(Kg)return Kg;let t=HK(n);return Kg=t,FK(),KK(t),t}function KK(n){n.get(MI,null)?.forEach(e=>e())}var Bh=(()=>{let t=class t{};t.__NG_ELEMENT_ID__=XK;let n=t;return n})();function XK(n){return YK(Vo(),Dn(),(n&16)===16)}function YK(n,t,e){if(TI(n)&&!e){let r=dp(n.index,t);return new xu(r,r)}else if(n.type&47){let r=t[hs];return new xu(r,t)}return null}function CR(n){try{let{rootComponent:t,appProviders:e,platformProviders:r}=n,o=qK(r),s=[xR({}),{provide:Dh,useExisting:WK},...e||[]],a=new uy({providers:s,parent:o,debugName:"",runEnvironmentInitializers:!1}).injector,l=a.get(yn);return l.run(()=>{a.resolveInjectorInitializers();let u=a.get(Ks,null),c;l.runOutsideAngular(()=>{c=l.onError.subscribe({next:d=>{u.handleError(d)}})});let p=()=>a.destroy(),f=o.get(wR);return f.add(p),a.onDestroy(()=>{c.unsubscribe(),f.delete(p)}),LK(u,l,()=>{let d=a.get(yR);return d.runInitializers(),d.donePromise.then(()=>{let h=a.get(tS,cy);kK(h||cy);let g=a.get(xp);return t!==void 0&&g.bootstrap(t),g})})})}catch(t){return Promise.reject(t)}}var kR=null;function bp(){return kR}function AR(n){kR??=n}var Dy=class{};var po=new Qe(""),RR=(()=>{let t=class t{historyGo(r){throw new Error("")}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(t9),providedIn:"platform"});let n=t;return n})();var t9=(()=>{let t=class t extends RR{constructor(){super(),this._doc=ge(po),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return bp().getBaseHref(this._doc)}onPopState(r){let o=bp().getGlobalEventTarget(this._doc,"window");return o.addEventListener("popstate",r,!1),()=>o.removeEventListener("popstate",r)}onHashChange(r){let o=bp().getGlobalEventTarget(this._doc,"window");return o.addEventListener("hashchange",r,!1),()=>o.removeEventListener("hashchange",r)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(r){this._location.pathname=r}pushState(r,o,s){this._history.pushState(r,o,s)}replaceState(r,o,s){this._history.replaceState(r,o,s)}forward(){this._history.forward()}back(){this._history.back()}historyGo(r=0){this._history.go(r)}getState(){return this._history.state}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>new t,providedIn:"platform"});let n=t;return n})();function _R(n,t){if(n.length==0)return t;if(t.length==0)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,e==2?n+t.substring(1):e==1?n+t:n+"/"+t}function IR(n){let t=n.match(/#|\?|$/),e=t&&t.index||n.length,r=e-(n[e-1]==="/"?1:0);return n.slice(0,r)+n.slice(e)}function Tu(n){return n&&n[0]!=="?"?"?"+n:n}var Ay=(()=>{let t=class t{historyGo(r){throw new Error("")}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(OR),providedIn:"root"});let n=t;return n})(),n9=new Qe(""),OR=(()=>{let t=class t extends Ay{constructor(r,o){super(),this._platformLocation=r,this._removeListenerFns=[],this._baseHref=o??this._platformLocation.getBaseHrefFromDOM()??ge(po).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(r){this._removeListenerFns.push(this._platformLocation.onPopState(r),this._platformLocation.onHashChange(r))}getBaseHref(){return this._baseHref}prepareExternalUrl(r){return _R(this._baseHref,r)}path(r=!1){let o=this._platformLocation.pathname+Tu(this._platformLocation.search),s=this._platformLocation.hash;return s&&r?`${o}${s}`:o}pushState(r,o,s,i){let a=this.prepareExternalUrl(s+Tu(i));this._platformLocation.pushState(r,o,a)}replaceState(r,o,s,i){let a=this.prepareExternalUrl(s+Tu(i));this._platformLocation.replaceState(r,o,a)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(r=0){this._platformLocation.historyGo?.(r)}};t.\u0275fac=function(o){return new(o||t)(it(RR),it(n9,8))},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();var zh=(()=>{let t=class t{constructor(r){this._subject=new er,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=r;let o=this._locationStrategy.getBaseHref();this._basePath=s9(IR(SR(o))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(r=!1){return this.normalize(this._locationStrategy.path(r))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(r,o=""){return this.path()==this.normalize(r+Tu(o))}normalize(r){return t.stripTrailingSlash(o9(this._basePath,SR(r)))}prepareExternalUrl(r){return r&&r[0]!=="/"&&(r="/"+r),this._locationStrategy.prepareExternalUrl(r)}go(r,o="",s=null){this._locationStrategy.pushState(s,"",r,o),this._notifyUrlChangeListeners(this.prepareExternalUrl(r+Tu(o)),s)}replaceState(r,o="",s=null){this._locationStrategy.replaceState(s,"",r,o),this._notifyUrlChangeListeners(this.prepareExternalUrl(r+Tu(o)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(r=0){this._locationStrategy.historyGo?.(r)}onUrlChange(r){return this._urlChangeListeners.push(r),this._urlChangeSubscription??=this.subscribe(o=>{this._notifyUrlChangeListeners(o.url,o.state)}),()=>{let o=this._urlChangeListeners.indexOf(r);this._urlChangeListeners.splice(o,1),this._urlChangeListeners.length===0&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(r="",o){this._urlChangeListeners.forEach(s=>s(r,o))}subscribe(r,o,s){return this._subject.subscribe({next:r,error:o,complete:s})}};t.normalizeQueryParams=Tu,t.joinWithSlash=_R,t.stripTrailingSlash=IR,t.\u0275fac=function(o){return new(o||t)(it(Ay))},t.\u0275prov=je({token:t,factory:()=>r9(),providedIn:"root"});let n=t;return n})();function r9(){return new zh(it(Ay))}function o9(n,t){if(!n||!t.startsWith(n))return t;let e=t.substring(n.length);return e===""||["/",";","?","#"].includes(e[0])?e:t}function SR(n){return n.replace(/\/index.html$/,"")}function s9(n){if(new RegExp("^(https?:)?//").test(n)){let[,e]=n.split(/\/\/[^\/]+/);return e}return n}function MR(n,t){t=encodeURIComponent(t);for(let e of n.split(";")){let r=e.indexOf("="),[o,s]=r==-1?[e,""]:[e.slice(0,r),e.slice(r+1)];if(o.trim()===t)return decodeURIComponent(s)}return null}var FR="browser",i9="server";function rS(n){return n===i9}var ky=class{};var iS=class extends Dy{constructor(){super(...arguments),this.supportsDOMEvents=!0}},aS=class n extends iS{static makeCurrent(){AR(new n)}onAndCancel(t,e,r){return t.addEventListener(e,r),()=>{t.removeEventListener(e,r)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return e=e||this.getDefaultDocument(),e.createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return e==="window"?window:e==="document"?t:e==="body"?t.body:null}getBaseHref(t){let e=l9();return e==null?null:u9(e)}resetBaseElement(){Vh=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return MR(document.cookie,t)}},Vh=null;function l9(){return Vh=Vh||document.querySelector("base"),Vh?Vh.getAttribute("href"):null}function u9(n){return new URL(n,document.baseURI).pathname}var c9=(()=>{let t=class t{build(){return new XMLHttpRequest}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})(),lS=new Qe(""),BR=(()=>{let t=class t{constructor(r,o){this._zone=o,this._eventNameToPlugin=new Map,r.forEach(s=>{s.manager=this}),this._plugins=r.slice().reverse()}addEventListener(r,o,s){return this._findPluginFor(o).addEventListener(r,o,s)}getZone(){return this._zone}_findPluginFor(r){let o=this._eventNameToPlugin.get(r);if(o)return o;if(o=this._plugins.find(i=>i.supports(r)),!o)throw new Pe(5101,!1);return this._eventNameToPlugin.set(r,o),o}};t.\u0275fac=function(o){return new(o||t)(it(lS),it(yn))},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})(),Ry=class{constructor(t){this._doc=t}},oS="ng-app-id",zR=(()=>{let t=class t{constructor(r,o,s,i={}){this.doc=r,this.appId=o,this.nonce=s,this.platformId=i,this.styleRef=new Map,this.hostNodes=new Set,this.styleNodesInDOM=this.collectServerRenderedStyles(),this.platformIsServer=rS(i),this.resetHostNodes()}addStyles(r){for(let o of r)this.changeUsageCount(o,1)===1&&this.onStyleAdded(o)}removeStyles(r){for(let o of r)this.changeUsageCount(o,-1)<=0&&this.onStyleRemoved(o)}ngOnDestroy(){let r=this.styleNodesInDOM;r&&(r.forEach(o=>o.remove()),r.clear());for(let o of this.getAllStyles())this.onStyleRemoved(o);this.resetHostNodes()}addHost(r){this.hostNodes.add(r);for(let o of this.getAllStyles())this.addStyleToHost(r,o)}removeHost(r){this.hostNodes.delete(r)}getAllStyles(){return this.styleRef.keys()}onStyleAdded(r){for(let o of this.hostNodes)this.addStyleToHost(o,r)}onStyleRemoved(r){let o=this.styleRef;o.get(r)?.elements?.forEach(s=>s.remove()),o.delete(r)}collectServerRenderedStyles(){let r=this.doc.head?.querySelectorAll(`style[${oS}="${this.appId}"]`);if(r?.length){let o=new Map;return r.forEach(s=>{s.textContent!=null&&o.set(s.textContent,s)}),o}return null}changeUsageCount(r,o){let s=this.styleRef;if(s.has(r)){let i=s.get(r);return i.usage+=o,i.usage}return s.set(r,{usage:o,elements:[]}),o}getStyleElement(r,o){let s=this.styleNodesInDOM,i=s?.get(o);if(i?.parentNode===r)return s.delete(o),i.removeAttribute(oS),i;{let a=this.doc.createElement("style");return this.nonce&&a.setAttribute("nonce",this.nonce),a.textContent=o,this.platformIsServer&&a.setAttribute(oS,this.appId),r.appendChild(a),a}}addStyleToHost(r,o){let s=this.getStyleElement(r,o),i=this.styleRef,a=i.get(o)?.elements;a?a.push(s):i.set(o,{elements:[s],usage:1})}resetHostNodes(){let r=this.hostNodes;r.clear(),r.add(this.doc.head)}};t.\u0275fac=function(o){return new(o||t)(it(po),it(OI),it(FI,8),it(gp))},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})(),sS={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},cS=/%COMP%/g,VR="%COMP%",p9=`_nghost-${VR}`,f9=`_ngcontent-${VR}`,d9=!0,h9=new Qe("",{providedIn:"root",factory:()=>d9});function m9(n){return f9.replace(cS,n)}function g9(n){return p9.replace(cS,n)}function UR(n,t){return t.map(e=>e.replace(cS,n))}var $R=(()=>{let t=class t{constructor(r,o,s,i,a,l,u,c=null){this.eventManager=r,this.sharedStylesHost=o,this.appId=s,this.removeStylesOnCompDestroy=i,this.doc=a,this.platformId=l,this.ngZone=u,this.nonce=c,this.rendererByCompId=new Map,this.platformIsServer=rS(l),this.defaultRenderer=new Uh(r,a,u,this.platformIsServer)}createRenderer(r,o){if(!r||!o)return this.defaultRenderer;this.platformIsServer&&o.encapsulation===fs.ShadowDom&&(o=dn(Te({},o),{encapsulation:fs.Emulated}));let s=this.getOrCreateRenderer(r,o);return s instanceof _y?s.applyToHost(r):s instanceof Gh&&s.applyStyles(),s}getOrCreateRenderer(r,o){let s=this.rendererByCompId,i=s.get(o.id);if(!i){let a=this.doc,l=this.ngZone,u=this.eventManager,c=this.sharedStylesHost,p=this.removeStylesOnCompDestroy,f=this.platformIsServer;switch(o.encapsulation){case fs.Emulated:i=new _y(u,c,o,this.appId,p,a,l,f);break;case fs.ShadowDom:return new uS(u,c,r,o,a,l,this.nonce,f);default:i=new Gh(u,c,o,p,a,l,f);break}s.set(o.id,i)}return i}ngOnDestroy(){this.rendererByCompId.clear()}};t.\u0275fac=function(o){return new(o||t)(it(BR),it(zR),it(OI),it(h9),it(po),it(gp),it(yn),it(FI))},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})(),Uh=class{constructor(t,e,r,o){this.eventManager=t,this.doc=e,this.ngZone=r,this.platformIsServer=o,this.data=Object.create(null),this.throwOnSyntheticProps=!0,this.destroyNode=null}destroy(){}createElement(t,e){return e?this.doc.createElementNS(sS[e]||e,t):this.doc.createElement(t)}createComment(t){return this.doc.createComment(t)}createText(t){return this.doc.createTextNode(t)}appendChild(t,e){(PR(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(PR(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r=typeof t=="string"?this.doc.querySelector(t):t;if(!r)throw new Pe(-5104,!1);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,o){if(o){e=o+":"+e;let s=sS[o];s?t.setAttributeNS(s,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){let o=sS[r];o?t.removeAttributeNS(o,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,o){o&(wu.DashCase|wu.Important)?t.style.setProperty(e,r,o&wu.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&wu.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t!=null&&(t[e]=r)}setValue(t,e){t.nodeValue=e}listen(t,e,r){if(typeof t=="string"&&(t=bp().getGlobalEventTarget(this.doc,t),!t))throw new Error(`Unsupported event target ${t} for event ${e}`);return this.eventManager.addEventListener(t,e,this.decoratePreventDefault(r))}decoratePreventDefault(t){return e=>{if(e==="__ngUnwrap__")return t;(this.platformIsServer?this.ngZone.runGuarded(()=>t(e)):t(e))===!1&&e.preventDefault()}}};function PR(n){return n.tagName==="TEMPLATE"&&n.content!==void 0}var uS=class extends Uh{constructor(t,e,r,o,s,i,a,l){super(t,s,i,l),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);let u=UR(o.id,o.styles);for(let c of u){let p=document.createElement("style");a&&p.setAttribute("nonce",a),p.textContent=c,this.shadowRoot.appendChild(p)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}},Gh=class extends Uh{constructor(t,e,r,o,s,i,a,l){super(t,s,i,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=o,this.styles=l?UR(l,r.styles):r.styles}applyStyles(){this.sharedStylesHost.addStyles(this.styles)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles)}},_y=class extends Gh{constructor(t,e,r,o,s,i,a,l){let u=o+"-"+r.id;super(t,e,r,s,i,a,l,u),this.contentAttr=m9(u),this.hostAttr=g9(u)}applyToHost(t){this.applyStyles(),this.setAttribute(t,this.hostAttr,"")}createElement(t,e){let r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}},y9=(()=>{let t=class t extends Ry{constructor(r){super(r)}supports(r){return!0}addEventListener(r,o,s){return r.addEventListener(o,s,!1),()=>this.removeEventListener(r,o,s)}removeEventListener(r,o,s){return r.removeEventListener(o,s)}};t.\u0275fac=function(o){return new(o||t)(it(po))},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})(),LR=["alt","control","meta","shift"],x9={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},b9={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey},v9=(()=>{let t=class t extends Ry{constructor(r){super(r)}supports(r){return t.parseEventName(r)!=null}addEventListener(r,o,s){let i=t.parseEventName(o),a=t.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>bp().onAndCancel(r,i.domEventName,a))}static parseEventName(r){let o=r.toLowerCase().split("."),s=o.shift();if(o.length===0||!(s==="keydown"||s==="keyup"))return null;let i=t._normalizeKey(o.pop()),a="",l=o.indexOf("code");if(l>-1&&(o.splice(l,1),a="code."),LR.forEach(c=>{let p=o.indexOf(c);p>-1&&(o.splice(p,1),a+=c+".")}),a+=i,o.length!=0||i.length===0)return null;let u={};return u.domEventName=s,u.fullKey=a,u}static matchEventFullKeyCode(r,o){let s=x9[r.key]||r.key,i="";return o.indexOf("code.")>-1&&(s=r.code,i="code."),s==null||!s?!1:(s=s.toLowerCase(),s===" "?s="space":s==="."&&(s="dot"),LR.forEach(a=>{if(a!==s){let l=b9[a];l(r)&&(i+=a+".")}}),i+=s,i===o)}static eventCallback(r,o,s){return i=>{t.matchEventFullKeyCode(i,r)&&s.runGuarded(()=>o(i))}}static _normalizeKey(r){return r==="esc"?"escape":r}};t.\u0275fac=function(o){return new(o||t)(it(po))},t.\u0275prov=je({token:t,factory:t.\u0275fac});let n=t;return n})();function GR(n,t){return CR(Te({rootComponent:n},w9(t)))}function w9(n){return{appProviders:[...N9,...n?.providers??[]],platformProviders:T9}}function C9(){aS.makeCurrent()}function I9(){return new Ks}function S9(){return EA(document),document}var T9=[{provide:gp,useValue:FR},{provide:MI,useValue:C9,multi:!0},{provide:po,useFactory:S9,deps:[]}];var N9=[{provide:my,useValue:"root"},{provide:Ks,useFactory:I9,deps:[]},{provide:lS,useClass:y9,multi:!0,deps:[po,yn,gp]},{provide:lS,useClass:v9,multi:!0,deps:[po]},$R,zR,BR,{provide:fp,useExisting:$R},{provide:ky,useClass:c9,deps:[]},[]];var WR=(()=>{let t=class t{constructor(r){this._doc=r}getTitle(){return this._doc.title}setTitle(r){this._doc.title=r||""}};t.\u0275fac=function(o){return new(o||t)(it(po))},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();var qe="primary",im=Symbol("RouteTitle"),mS=class{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){let e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){let e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}};function Tp(n){return new mS(n)}function D9(n,t,e){let r=e.path.split("/");if(r.length>n.length||e.pathMatch==="full"&&(t.hasChildren()||r.length<n.length))return null;let o={};for(let s=0;s<r.length;s++){let i=r[s],a=n[s];if(i[0]===":")o[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:o}}function k9(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!ys(n[e],t[e]))return!1;return!0}function ys(n,t){let e=n?gS(n):void 0,r=t?gS(t):void 0;if(!e||!r||e.length!=r.length)return!1;let o;for(let s=0;s<e.length;s++)if(o=e[s],!QR(n[o],t[o]))return!1;return!0}function gS(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}function QR(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;let e=[...n].sort(),r=[...t].sort();return e.every((o,s)=>r[s]===o)}else return n===t}function JR(n){return n.length>0?n[n.length-1]:null}function Ea(n){return m0(n)?n:Lh(n)?Nn(Promise.resolve(n)):We(n)}var A9={exact:t_,subset:n_},e_={exact:R9,subset:_9,ignored:()=>!0};function jR(n,t,e){return A9[e.paths](n.root,t.root,e.matrixParams)&&e_[e.queryParams](n.queryParams,t.queryParams)&&!(e.fragment==="exact"&&n.fragment!==t.fragment)}function R9(n,t){return ys(n,t)}function t_(n,t,e){if(!Eu(n.segments,t.segments)||!Fy(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(let r in t.children)if(!n.children[r]||!t_(n.children[r],t.children[r],e))return!1;return!0}function _9(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>QR(n[e],t[e]))}function n_(n,t,e){return r_(n,t,t.segments,e)}function r_(n,t,e,r){if(n.segments.length>e.length){let o=n.segments.slice(0,e.length);return!(!Eu(o,e)||t.hasChildren()||!Fy(o,e,r))}else if(n.segments.length===e.length){if(!Eu(n.segments,e)||!Fy(n.segments,e,r))return!1;for(let o in t.children)if(!n.children[o]||!n_(n.children[o],t.children[o],r))return!1;return!0}else{let o=e.slice(0,n.segments.length),s=e.slice(n.segments.length);return!Eu(n.segments,o)||!Fy(n.segments,o,r)||!n.children[qe]?!1:r_(n.children[qe],t,s,r)}}function Fy(n,t,e){return t.every((r,o)=>e_[e](n[o].parameters,r.parameters))}var Na=class{constructor(t=new St([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap??=Tp(this.queryParams),this._queryParamMap}toString(){return F9.serialize(this)}},St=class{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return $y(this)}},Nu=class{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap??=Tp(this.parameters),this._parameterMap}toString(){return s_(this)}};function O9(n,t){return Eu(n,t)&&n.every((e,r)=>ys(e.parameters,t[r].parameters))}function Eu(n,t){return n.length!==t.length?!1:n.every((e,r)=>e.path===t[r].path)}function M9(n,t){let e=[];return Object.entries(n.children).forEach(([r,o])=>{r===qe&&(e=e.concat(t(o,r)))}),Object.entries(n.children).forEach(([r,o])=>{r!==qe&&(e=e.concat(t(o,r)))}),e}var US=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>new Yh,providedIn:"root"});let n=t;return n})(),Yh=class{parse(t){let e=new xS(t);return new Na(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){let e=`/${Wh(t.root,!0)}`,r=L9(t.queryParams),o=typeof t.fragment=="string"?`#${$9(t.fragment)}`:"";return`${e}${r}${o}`}},F9=new Yh;function $y(n){return n.segments.map(t=>s_(t)).join("/")}function Wh(n,t){if(!n.hasChildren())return $y(n);if(t){let e=n.children[qe]?Wh(n.children[qe],!1):"",r=[];return Object.entries(n.children).forEach(([o,s])=>{o!==qe&&r.push(`${o}:${Wh(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}else{let e=M9(n,(r,o)=>o===qe?[Wh(n.children[qe],!1)]:[`${o}:${Wh(r,!1)}`]);return Object.keys(n.children).length===1&&n.children[qe]!=null?`${$y(n)}/${e[0]}`:`${$y(n)}/(${e.join("//")})`}}function o_(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Oy(n){return o_(n).replace(/%3B/gi,";")}function $9(n){return encodeURI(n)}function yS(n){return o_(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Py(n){return decodeURIComponent(n)}function HR(n){return Py(n.replace(/\+/g,"%20"))}function s_(n){return`${yS(n.path)}${P9(n.parameters)}`}function P9(n){return Object.entries(n).map(([t,e])=>`;${yS(t)}=${yS(e)}`).join("")}function L9(n){let t=Object.entries(n).map(([e,r])=>Array.isArray(r)?r.map(o=>`${Oy(e)}=${Oy(o)}`).join("&"):`${Oy(e)}=${Oy(r)}`).filter(e=>e);return t.length?`?${t.join("&")}`:""}var B9=/^[^\/()?;#]+/;function pS(n){let t=n.match(B9);return t?t[0]:""}var z9=/^[^\/()?;=#]+/;function V9(n){let t=n.match(z9);return t?t[0]:""}var U9=/^[^=?&#]+/;function G9(n){let t=n.match(U9);return t?t[0]:""}var W9=/^[^&#]+/;function j9(n){let t=n.match(W9);return t?t[0]:""}var xS=class{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),this.remaining===""||this.peekStartsWith("?")||this.peekStartsWith("#")?new St([],{}):new St([],this.parseChildren())}parseQueryParams(){let t={};if(this.consumeOptional("?"))do this.parseQueryParam(t);while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(this.remaining==="")return{};this.consumeOptional("/");let t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[qe]=new St(t,e)),r}parseSegment(){let t=pS(this.remaining);if(t===""&&this.peekStartsWith(";"))throw new Pe(4009,!1);return this.capture(t),new Nu(Py(t),this.parseMatrixParams())}parseMatrixParams(){let t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){let e=V9(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let o=pS(this.remaining);o&&(r=o,this.capture(r))}t[Py(e)]=Py(r)}parseQueryParam(t){let e=G9(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let i=j9(this.remaining);i&&(r=i,this.capture(r))}let o=HR(e),s=HR(r);if(t.hasOwnProperty(o)){let i=t[o];Array.isArray(i)||(i=[i],t[o]=i),i.push(s)}else t[o]=s}parseParens(t){let e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){let r=pS(this.remaining),o=this.remaining[r.length];if(o!=="/"&&o!==")"&&o!==";")throw new Pe(4010,!1);let s;r.indexOf(":")>-1?(s=r.slice(0,r.indexOf(":")),this.capture(s),this.capture(":")):t&&(s=qe);let i=this.parseChildren();e[s]=Object.keys(i).length===1?i[qe]:new St([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return this.peekStartsWith(t)?(this.remaining=this.remaining.substring(t.length),!0):!1}capture(t){if(!this.consumeOptional(t))throw new Pe(4011,!1)}};function i_(n){return n.segments.length>0?new St([],{[qe]:n}):n}function a_(n){let t={};for(let[r,o]of Object.entries(n.children)){let s=a_(o);if(r===qe&&s.segments.length===0&&s.hasChildren())for(let[i,a]of Object.entries(s.children))t[i]=a;else(s.segments.length>0||s.hasChildren())&&(t[r]=s)}let e=new St(n.segments,t);return H9(e)}function H9(n){if(n.numberOfChildren===1&&n.children[qe]){let t=n.children[qe];return new St(n.segments.concat(t.segments),t.children)}return n}function Zh(n){return n instanceof Na}function q9(n,t,e=null,r=null){let o=l_(n);return u_(o,t,e,r)}function l_(n){let t;function e(s){let i={};for(let l of s.children){let u=e(l);i[l.outlet]=u}let a=new St(s.url,i);return s===n&&(t=a),a}let r=e(n.root),o=i_(r);return t??o}function u_(n,t,e,r){let o=n;for(;o.parent;)o=o.parent;if(t.length===0)return fS(o,o,o,e,r);let s=K9(t);if(s.toRoot())return fS(o,o,new St([],{}),e,r);let i=X9(s,o,n),a=i.processChildren?qh(i.segmentGroup,i.index,s.commands):p_(i.segmentGroup,i.index,s.commands);return fS(o,i.segmentGroup,a,e,r)}function Ly(n){return typeof n=="object"&&n!=null&&!n.outlets&&!n.segmentPath}function Qh(n){return typeof n=="object"&&n!=null&&n.outlets}function fS(n,t,e,r,o){let s={};r&&Object.entries(r).forEach(([l,u])=>{s[l]=Array.isArray(u)?u.map(c=>`${c}`):`${u}`});let i;n===t?i=e:i=c_(n,t,e);let a=i_(a_(i));return new Na(a,s,o)}function c_(n,t,e){let r={};return Object.entries(n.children).forEach(([o,s])=>{s===t?r[o]=e:r[o]=c_(s,t,e)}),new St(n.segments,r)}var By=class{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&Ly(r[0]))throw new Pe(4003,!1);let o=r.find(Qh);if(o&&o!==JR(r))throw new Pe(4004,!1)}toRoot(){return this.isAbsolute&&this.commands.length===1&&this.commands[0]=="/"}};function K9(n){if(typeof n[0]=="string"&&n.length===1&&n[0]==="/")return new By(!0,0,n);let t=0,e=!1,r=n.reduce((o,s,i)=>{if(typeof s=="object"&&s!=null){if(s.outlets){let a={};return Object.entries(s.outlets).forEach(([l,u])=>{a[l]=typeof u=="string"?u.split("/"):u}),[...o,{outlets:a}]}if(s.segmentPath)return[...o,s.segmentPath]}return typeof s!="string"?[...o,s]:i===0?(s.split("/").forEach((a,l)=>{l==0&&a==="."||(l==0&&a===""?e=!0:a===".."?t++:a!=""&&o.push(a))}),o):[...o,s]},[]);return new By(e,t,r)}var Cp=class{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}};function X9(n,t,e){if(n.isAbsolute)return new Cp(t,!0,0);if(!e)return new Cp(t,!1,NaN);if(e.parent===null)return new Cp(e,!0,0);let r=Ly(n.commands[0])?0:1,o=e.segments.length-1+r;return Y9(e,o,n.numberOfDoubleDots)}function Y9(n,t,e){let r=n,o=t,s=e;for(;s>o;){if(s-=o,r=r.parent,!r)throw new Pe(4005,!1);o=r.segments.length}return new Cp(r,!1,o-s)}function Z9(n){return Qh(n[0])?n[0].outlets:{[qe]:n}}function p_(n,t,e){if(n??=new St([],{}),n.segments.length===0&&n.hasChildren())return qh(n,t,e);let r=Q9(n,t,e),o=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){let s=new St(n.segments.slice(0,r.pathIndex),{});return s.children[qe]=new St(n.segments.slice(r.pathIndex),n.children),qh(s,0,o)}else return r.match&&o.length===0?new St(n.segments,{}):r.match&&!n.hasChildren()?bS(n,t,e):r.match?qh(n,0,o):bS(n,t,e)}function qh(n,t,e){if(e.length===0)return new St(n.segments,{});{let r=Z9(e),o={};if(Object.keys(r).some(s=>s!==qe)&&n.children[qe]&&n.numberOfChildren===1&&n.children[qe].segments.length===0){let s=qh(n.children[qe],t,e);return new St(n.segments,s.children)}return Object.entries(r).forEach(([s,i])=>{typeof i=="string"&&(i=[i]),i!==null&&(o[s]=p_(n.children[s],t,i))}),Object.entries(n.children).forEach(([s,i])=>{r[s]===void 0&&(o[s]=i)}),new St(n.segments,o)}}function Q9(n,t,e){let r=0,o=t,s={match:!1,pathIndex:0,commandIndex:0};for(;o<n.segments.length;){if(r>=e.length)return s;let i=n.segments[o],a=e[r];if(Qh(a))break;let l=`${a}`,u=r<e.length-1?e[r+1]:null;if(o>0&&l===void 0)break;if(l&&u&&typeof u=="object"&&u.outlets===void 0){if(!KR(l,u,i))return s;r+=2}else{if(!KR(l,{},i))return s;r++}o++}return{match:!0,pathIndex:o,commandIndex:r}}function bS(n,t,e){let r=n.segments.slice(0,t),o=0;for(;o<e.length;){let s=e[o];if(Qh(s)){let l=J9(s.outlets);return new St(r,l)}if(o===0&&Ly(e[0])){let l=n.segments[t];r.push(new Nu(l.path,qR(e[0]))),o++;continue}let i=Qh(s)?s.outlets[qe]:`${s}`,a=o<e.length-1?e[o+1]:null;i&&a&&Ly(a)?(r.push(new Nu(i,qR(a))),o+=2):(r.push(new Nu(i,{})),o++)}return new St(r,{})}function J9(n){let t={};return Object.entries(n).forEach(([e,r])=>{typeof r=="string"&&(r=[r]),r!==null&&(t[e]=bS(new St([],{}),0,r))}),t}function qR(n){let t={};return Object.entries(n).forEach(([e,r])=>t[e]=`${r}`),t}function KR(n,t,e){return n==e.path&&ys(t,e.parameters)}var Kh="imperative",qn=function(n){return n[n.NavigationStart=0]="NavigationStart",n[n.NavigationEnd=1]="NavigationEnd",n[n.NavigationCancel=2]="NavigationCancel",n[n.NavigationError=3]="NavigationError",n[n.RoutesRecognized=4]="RoutesRecognized",n[n.ResolveStart=5]="ResolveStart",n[n.ResolveEnd=6]="ResolveEnd",n[n.GuardsCheckStart=7]="GuardsCheckStart",n[n.GuardsCheckEnd=8]="GuardsCheckEnd",n[n.RouteConfigLoadStart=9]="RouteConfigLoadStart",n[n.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",n[n.ChildActivationStart=11]="ChildActivationStart",n[n.ChildActivationEnd=12]="ChildActivationEnd",n[n.ActivationStart=13]="ActivationStart",n[n.ActivationEnd=14]="ActivationEnd",n[n.Scroll=15]="Scroll",n[n.NavigationSkipped=16]="NavigationSkipped",n}(qn||{}),fo=class{constructor(t,e){this.id=t,this.url=e}},Jh=class extends fo{constructor(t,e,r="imperative",o=null){super(t,e),this.type=qn.NavigationStart,this.navigationTrigger=r,this.restoredState=o}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}},Du=class extends fo{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=qn.NavigationEnd}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}},Zr=function(n){return n[n.Redirect=0]="Redirect",n[n.SupersededByNewNavigation=1]="SupersededByNewNavigation",n[n.NoDataFromResolver=2]="NoDataFromResolver",n[n.GuardRejected=3]="GuardRejected",n}(Zr||{}),vS=function(n){return n[n.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",n[n.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",n}(vS||{}),Qs=class extends fo{constructor(t,e,r,o){super(t,e),this.reason=r,this.code=o,this.type=qn.NavigationCancel}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}},ku=class extends fo{constructor(t,e,r,o){super(t,e),this.reason=r,this.code=o,this.type=qn.NavigationSkipped}},em=class extends fo{constructor(t,e,r,o){super(t,e),this.error=r,this.target=o,this.type=qn.NavigationError}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}},zy=class extends fo{constructor(t,e,r,o){super(t,e),this.urlAfterRedirects=r,this.state=o,this.type=qn.RoutesRecognized}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},wS=class extends fo{constructor(t,e,r,o){super(t,e),this.urlAfterRedirects=r,this.state=o,this.type=qn.GuardsCheckStart}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},CS=class extends fo{constructor(t,e,r,o,s){super(t,e),this.urlAfterRedirects=r,this.state=o,this.shouldActivate=s,this.type=qn.GuardsCheckEnd}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}},IS=class extends fo{constructor(t,e,r,o){super(t,e),this.urlAfterRedirects=r,this.state=o,this.type=qn.ResolveStart}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},SS=class extends fo{constructor(t,e,r,o){super(t,e),this.urlAfterRedirects=r,this.state=o,this.type=qn.ResolveEnd}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},TS=class{constructor(t){this.route=t,this.type=qn.RouteConfigLoadStart}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}},NS=class{constructor(t){this.route=t,this.type=qn.RouteConfigLoadEnd}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}},ES=class{constructor(t){this.snapshot=t,this.type=qn.ChildActivationStart}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},DS=class{constructor(t){this.snapshot=t,this.type=qn.ChildActivationEnd}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},kS=class{constructor(t){this.snapshot=t,this.type=qn.ActivationStart}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},AS=class{constructor(t){this.snapshot=t,this.type=qn.ActivationEnd}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}};var tm=class{},Np=class{constructor(t,e){this.url=t,this.navigationBehaviorOptions=e}};var RS=class{constructor(t){this.injector=t,this.outlet=null,this.route=null,this.children=new qy(this.injector),this.attachRef=null}},qy=(()=>{let t=class t{constructor(r){this.parentInjector=r,this.contexts=new Map}onChildOutletCreated(r,o){let s=this.getOrCreateContext(r);s.outlet=o,this.contexts.set(r,s)}onChildOutletDestroyed(r){let o=this.getContext(r);o&&(o.outlet=null,o.attachRef=null)}onOutletDeactivated(){let r=this.contexts;return this.contexts=new Map,r}onOutletReAttached(r){this.contexts=r}getOrCreateContext(r){let o=this.getContext(r);return o||(o=new RS(this.parentInjector),this.contexts.set(r,o)),o}getContext(r){return this.contexts.get(r)||null}};t.\u0275fac=function(o){return new(o||t)(it(uo))},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),Vy=class{constructor(t){this._root=t}get root(){return this._root.value}parent(t){let e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){let e=_S(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){let e=_S(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){let e=OS(t,this._root);return e.length<2?[]:e[e.length-2].children.map(o=>o.value).filter(o=>o!==t)}pathFromRoot(t){return OS(t,this._root).map(e=>e.value)}};function _S(n,t){if(n===t.value)return t;for(let e of t.children){let r=_S(n,e);if(r)return r}return null}function OS(n,t){if(n===t.value)return[t];for(let e of t.children){let r=OS(n,e);if(r.length)return r.unshift(t),r}return[]}var Yr=class{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}};function wp(n){let t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}var Uy=class extends Vy{constructor(t,e){super(t),this.snapshot=e,GS(this,t)}toString(){return this.snapshot.toString()}};function f_(n){let t=e7(n),e=new jn([new Nu("",{})]),r=new jn({}),o=new jn({}),s=new jn({}),i=new jn(""),a=new Ep(e,r,s,i,o,qe,n,t.root);return a.snapshot=t.root,new Uy(new Yr(a,[]),t)}function e7(n){let t={},e={},r={},o="",s=new Ip([],t,r,o,e,qe,n,null,{});return new Wy("",new Yr(s,[]))}var Ep=class{constructor(t,e,r,o,s,i,a,l){this.urlSubject=t,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=o,this.dataSubject=s,this.outlet=i,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(st(u=>u[im]))??We(void 0),this.url=t,this.params=e,this.queryParams=r,this.fragment=o,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe(st(t=>Tp(t))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe(st(t=>Tp(t))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}};function Gy(n,t,e="emptyOnly"){let r,{routeConfig:o}=n;return t!==null&&(e==="always"||o?.path===""||!t.component&&!t.routeConfig?.loadComponent)?r={params:Te(Te({},t.params),n.params),data:Te(Te({},t.data),n.data),resolve:Te(Te(Te(Te({},n.data),t.data),o?.data),n._resolvedData)}:r={params:Te({},n.params),data:Te({},n.data),resolve:Te(Te({},n.data),n._resolvedData??{})},o&&h_(o)&&(r.resolve[im]=o.title),r}var Ip=class{get title(){return this.data?.[im]}constructor(t,e,r,o,s,i,a,l,u){this.url=t,this.params=e,this.queryParams=r,this.fragment=o,this.data=s,this.outlet=i,this.component=a,this.routeConfig=l,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=Tp(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=Tp(this.queryParams),this._queryParamMap}toString(){let t=this.url.map(r=>r.toString()).join("/"),e=this.routeConfig?this.routeConfig.path:"";return`Route(url:'${t}', path:'${e}')`}},Wy=class extends Vy{constructor(t,e){super(e),this.url=t,GS(this,e)}toString(){return d_(this._root)}};function GS(n,t){t.value._routerState=n,t.children.forEach(e=>GS(n,e))}function d_(n){let t=n.children.length>0?` { ${n.children.map(d_).join(", ")} } `:"";return`${n.value}${t}`}function dS(n){if(n.snapshot){let t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,ys(t.queryParams,e.queryParams)||n.queryParamsSubject.next(e.queryParams),t.fragment!==e.fragment&&n.fragmentSubject.next(e.fragment),ys(t.params,e.params)||n.paramsSubject.next(e.params),k9(t.url,e.url)||n.urlSubject.next(e.url),ys(t.data,e.data)||n.dataSubject.next(e.data)}else n.snapshot=n._futureSnapshot,n.dataSubject.next(n._futureSnapshot.data)}function MS(n,t){let e=ys(n.params,t.params)&&O9(n.url,t.url),r=!n.parent!=!t.parent;return e&&!r&&(!n.parent||MS(n.parent,t.parent))}function h_(n){return typeof n.title=="string"||n.title===null}var t7=(()=>{let t=class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=qe,this.activateEvents=new er,this.deactivateEvents=new er,this.attachEvents=new er,this.detachEvents=new er,this.parentContexts=ge(qy),this.location=ge(yp),this.changeDetector=ge(Bh),this.inputBinder=ge(WS,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(r){if(r.name){let{firstChange:o,previousValue:s}=r.name;if(o)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(r){return this.parentContexts.getContext(r)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;let r=this.parentContexts.getContext(this.name);r?.route&&(r.attachRef?this.attach(r.attachRef,r.route):this.activateWith(r.route,r.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Pe(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Pe(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Pe(4012,!1);this.location.detach();let r=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(r.instance),r}attach(r,o){this.activated=r,this._activatedRoute=o,this.location.insert(r.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(r.instance)}deactivate(){if(this.activated){let r=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(r)}}activateWith(r,o){if(this.isActivated)throw new Pe(4013,!1);this._activatedRoute=r;let s=this.location,a=r.snapshot.component,l=this.parentContexts.getOrCreateContext(this.name).children,u=new FS(r,l,s.injector);this.activated=s.createComponent(a,{index:s.length,injector:u,environmentInjector:o}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}};t.\u0275fac=function(o){return new(o||t)},t.\u0275dir=CI({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[yy]});let n=t;return n})(),FS=class n{__ngOutletInjector(t){return new n(this.route,this.childContexts,t)}constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===Ep?this.route:t===qy?this.childContexts:this.parent.get(t,e)}},WS=new Qe("");function n7(n,t,e){let r=nm(n,t._root,e?e._root:void 0);return new Uy(r,t)}function nm(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){let r=e.value;r._futureSnapshot=t.value;let o=r7(n,t,e);return new Yr(r,o)}else{if(n.shouldAttach(t.value)){let s=n.retrieve(t.value);if(s!==null){let i=s.route;return i.value._futureSnapshot=t.value,i.children=t.children.map(a=>nm(n,a)),i}}let r=o7(t.value),o=t.children.map(s=>nm(n,s));return new Yr(r,o)}}function r7(n,t,e){return t.children.map(r=>{for(let o of e.children)if(n.shouldReuseRoute(r.value,o.value.snapshot))return nm(n,r,o);return nm(n,r)})}function o7(n){return new Ep(new jn(n.url),new jn(n.params),new jn(n.queryParams),new jn(n.fragment),new jn(n.data),n.outlet,n.component,n)}var rm=class{constructor(t,e){this.redirectTo=t,this.navigationBehaviorOptions=e}},m_="ngNavigationCancelingError";function jy(n,t){let{redirectTo:e,navigationBehaviorOptions:r}=Zh(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,o=g_(!1,Zr.Redirect);return o.url=e,o.navigationBehaviorOptions=r,o}function g_(n,t){let e=new Error(`NavigationCancelingError: ${n||""}`);return e[m_]=!0,e.cancellationCode=t,e}function s7(n){return y_(n)&&Zh(n.url)}function y_(n){return!!n&&n[m_]}var i7=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275cmp=dy({type:t,selectors:[["ng-component"]],standalone:!0,features:[Ty],decls:1,vars:0,template:function(o,s){o&1&&Fh(0,"router-outlet")},dependencies:[t7],encapsulation:2});let n=t;return n})();function a7(n,t){return n.providers&&!n._injector&&(n._injector=ZI(n.providers,t,`Route: ${n.path}`)),n._injector??t}function jS(n){let t=n.children&&n.children.map(jS),e=t?dn(Te({},n),{children:t}):Te({},n);return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==qe&&(e.component=i7),e}function Uo(n){return n.outlet||qe}function l7(n,t){let e=n.filter(r=>Uo(r)===t);return e.push(...n.filter(r=>Uo(r)!==t)),e}function am(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){let e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}var u7=(n,t,e,r)=>st(o=>(new $S(t,o.targetRouterState,o.currentRouterState,e,r).activate(n),o)),$S=class{constructor(t,e,r,o,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=o,this.inputBindingEnabled=s}activate(t){let e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),dS(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){let o=wp(e);t.children.forEach(s=>{let i=s.value.outlet;this.deactivateRoutes(s,o[i],r),delete o[i]}),Object.values(o).forEach(s=>{this.deactivateRouteAndItsChildren(s,r)})}deactivateRoutes(t,e,r){let o=t.value,s=e?e.value:null;if(o===s)if(o.component){let i=r.getContext(o.outlet);i&&this.deactivateChildRoutes(t,e,i.children)}else this.deactivateChildRoutes(t,e,r);else s&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){let r=e.getContext(t.value.outlet),o=r&&t.value.component?r.children:e,s=wp(t);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);if(r&&r.outlet){let i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:i,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){let r=e.getContext(t.value.outlet),o=r&&t.value.component?r.children:e,s=wp(t);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(t,e,r){let o=wp(e);t.children.forEach(s=>{this.activateRoutes(s,o[s.value.outlet],r),this.forwardEvent(new AS(s.value.snapshot))}),t.children.length&&this.forwardEvent(new DS(t.value.snapshot))}activateRoutes(t,e,r){let o=t.value,s=e?e.value:null;if(dS(o),o===s)if(o.component){let i=r.getOrCreateContext(o.outlet);this.activateChildRoutes(t,e,i.children)}else this.activateChildRoutes(t,e,r);else if(o.component){let i=r.getOrCreateContext(o.outlet);if(this.routeReuseStrategy.shouldAttach(o.snapshot)){let a=this.routeReuseStrategy.retrieve(o.snapshot);this.routeReuseStrategy.store(o.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),dS(a.route.value),this.activateChildRoutes(t,null,i.children)}else{let a=am(o.snapshot);i.attachRef=null,i.route=o,i.injector=a??i.injector,i.outlet&&i.outlet.activateWith(o,i.injector),this.activateChildRoutes(t,null,i.children)}}else this.activateChildRoutes(t,null,r)}},Hy=class{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}},Sp=class{constructor(t,e){this.component=t,this.route=e}};function c7(n,t,e){let r=n._root,o=t?t._root:null;return jh(r,o,e,[r.value])}function p7(n){let t=n.routeConfig?n.routeConfig.canActivateChild:null;return!t||t.length===0?null:{node:n,guards:t}}function kp(n,t){let e=Symbol(),r=t.get(n,e);return r===e?typeof n=="function"&&!mk(n)?n:t.get(n):r}function jh(n,t,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=wp(t);return n.children.forEach(i=>{f7(i,s[i.value.outlet],e,r.concat([i.value]),o),delete s[i.value.outlet]}),Object.entries(s).forEach(([i,a])=>Xh(a,e.getContext(i),o)),o}function f7(n,t,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=n.value,i=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(i&&s.routeConfig===i.routeConfig){let l=d7(i,s,s.routeConfig.runGuardsAndResolvers);l?o.canActivateChecks.push(new Hy(r)):(s.data=i.data,s._resolvedData=i._resolvedData),s.component?jh(n,t,a?a.children:null,r,o):jh(n,t,e,r,o),l&&a&&a.outlet&&a.outlet.isActivated&&o.canDeactivateChecks.push(new Sp(a.outlet.component,i))}else i&&Xh(t,a,o),o.canActivateChecks.push(new Hy(r)),s.component?jh(n,null,a?a.children:null,r,o):jh(n,null,e,r,o);return o}function d7(n,t,e){if(typeof e=="function")return e(n,t);switch(e){case"pathParamsChange":return!Eu(n.url,t.url);case"pathParamsOrQueryParamsChange":return!Eu(n.url,t.url)||!ys(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!MS(n,t)||!ys(n.queryParams,t.queryParams);case"paramsChange":default:return!MS(n,t)}}function Xh(n,t,e){let r=wp(n),o=n.value;Object.entries(r).forEach(([s,i])=>{o.component?t?Xh(i,t.children.getContext(s),e):Xh(i,null,e):Xh(i,t,e)}),o.component?t&&t.outlet&&t.outlet.isActivated?e.canDeactivateChecks.push(new Sp(t.outlet.component,o)):e.canDeactivateChecks.push(new Sp(null,o)):e.canDeactivateChecks.push(new Sp(null,o))}function lm(n){return typeof n=="function"}function h7(n){return typeof n=="boolean"}function m7(n){return n&&lm(n.canLoad)}function g7(n){return n&&lm(n.canActivate)}function y7(n){return n&&lm(n.canActivateChild)}function x7(n){return n&&lm(n.canDeactivate)}function b7(n){return n&&lm(n.canMatch)}function x_(n){return n instanceof Ws||n?.name==="EmptyError"}var My=Symbol("INITIAL_VALUE");function Dp(){return Po(n=>zg(n.map(t=>t.pipe(js(1),v0(My)))).pipe(st(t=>{for(let e of t)if(e!==!0){if(e===My)return My;if(e===!1||v7(e))return e}return!0}),$o(t=>t!==My),js(1)))}function v7(n){return Zh(n)||n instanceof rm}function w7(n,t){return En(e=>{let{targetSnapshot:r,currentSnapshot:o,guards:{canActivateChecks:s,canDeactivateChecks:i}}=e;return i.length===0&&s.length===0?We(dn(Te({},e),{guardsResult:!0})):C7(i,r,o,n).pipe(En(a=>a&&h7(a)?I7(r,s,n,t):We(a)),st(a=>dn(Te({},e),{guardsResult:a})))})}function C7(n,t,e,r){return Nn(n).pipe(En(o=>D7(o.component,o.route,e,t,r)),us(o=>o!==!0,!0))}function I7(n,t,e,r){return Nn(t).pipe(Yc(o=>Xc(T7(o.route.parent,r),S7(o.route,r),E7(n,o.path,e),N7(n,o.route,e))),us(o=>o!==!0,!0))}function S7(n,t){return n!==null&&t&&t(new kS(n)),We(!0)}function T7(n,t){return n!==null&&t&&t(new ES(n)),We(!0)}function N7(n,t,e){let r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||r.length===0)return We(!0);let o=r.map(s=>Vg(()=>{let i=am(t)??e,a=kp(s,i),l=g7(a)?a.canActivate(t,n):Xs(i,()=>a(t,n));return Ea(l).pipe(us())}));return We(o).pipe(Dp())}function E7(n,t,e){let r=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(i=>p7(i)).filter(i=>i!==null).map(i=>Vg(()=>{let a=i.guards.map(l=>{let u=am(i.node)??e,c=kp(l,u),p=y7(c)?c.canActivateChild(r,n):Xs(u,()=>c(r,n));return Ea(p).pipe(us())});return We(a).pipe(Dp())}));return We(s).pipe(Dp())}function D7(n,t,e,r,o){let s=t&&t.routeConfig?t.routeConfig.canDeactivate:null;if(!s||s.length===0)return We(!0);let i=s.map(a=>{let l=am(t)??o,u=kp(a,l),c=x7(u)?u.canDeactivate(n,t,e,r):Xs(l,()=>u(n,t,e,r));return Ea(c).pipe(us())});return We(i).pipe(Dp())}function k7(n,t,e,r){let o=t.canLoad;if(o===void 0||o.length===0)return We(!0);let s=o.map(i=>{let a=kp(i,n),l=m7(a)?a.canLoad(t,e):Xs(n,()=>a(t,e));return Ea(l)});return We(s).pipe(Dp(),b_(r))}function b_(n){return p0(Hn(t=>{if(typeof t!="boolean")throw jy(n,t)}),st(t=>t===!0))}function A7(n,t,e,r){let o=t.canMatch;if(!o||o.length===0)return We(!0);let s=o.map(i=>{let a=kp(i,n),l=b7(a)?a.canMatch(t,e):Xs(n,()=>a(t,e));return Ea(l)});return We(s).pipe(Dp(),b_(r))}var om=class{constructor(t){this.segmentGroup=t||null}},sm=class extends Error{constructor(t){super(),this.urlTree=t}};function vp(n){return Kc(new om(n))}function R7(n){return Kc(new Pe(4e3,!1))}function _7(n){return Kc(g_(!1,Zr.GuardRejected))}var PS=class{constructor(t,e){this.urlSerializer=t,this.urlTree=e}lineralizeSegments(t,e){let r=[],o=e.root;for(;;){if(r=r.concat(o.segments),o.numberOfChildren===0)return We(r);if(o.numberOfChildren>1||!o.children[qe])return R7(`${t.redirectTo}`);o=o.children[qe]}}applyRedirectCommands(t,e,r,o,s){if(typeof e!="string"){let a=e,{queryParams:l,fragment:u,routeConfig:c,url:p,outlet:f,params:d,data:h,title:g}=o,m=Xs(s,()=>a({params:d,data:h,queryParams:l,fragment:u,routeConfig:c,url:p,outlet:f,title:g}));if(m instanceof Na)throw new sm(m);e=m}let i=this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r);if(e[0]==="/")throw new sm(i);return i}applyRedirectCreateUrlTree(t,e,r,o){let s=this.createSegmentGroup(t,e.root,r,o);return new Na(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){let r={};return Object.entries(t).forEach(([o,s])=>{if(typeof s=="string"&&s[0]===":"){let a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(t,e,r,o){let s=this.createSegments(t,e.segments,r,o),i={};return Object.entries(e.children).forEach(([a,l])=>{i[a]=this.createSegmentGroup(t,l,r,o)}),new St(s,i)}createSegments(t,e,r,o){return e.map(s=>s.path[0]===":"?this.findPosParam(t,s,o):this.findOrReturn(s,r))}findPosParam(t,e,r){let o=r[e.path.substring(1)];if(!o)throw new Pe(4001,!1);return o}findOrReturn(t,e){let r=0;for(let o of e){if(o.path===t.path)return e.splice(r),o;r++}return t}},LS={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function O7(n,t,e,r,o){let s=HS(n,t,e);return s.matched?(r=a7(t,r),A7(r,t,e,o).pipe(st(i=>i===!0?s:Te({},LS)))):We(s)}function HS(n,t,e){if(t.path==="**")return M7(e);if(t.path==="")return t.pathMatch==="full"&&(n.hasChildren()||e.length>0)?Te({},LS):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};let o=(t.matcher||D9)(e,n,t);if(!o)return Te({},LS);let s={};Object.entries(o.posParams??{}).forEach(([a,l])=>{s[a]=l.path});let i=o.consumed.length>0?Te(Te({},s),o.consumed[o.consumed.length-1].parameters):s;return{matched:!0,consumedSegments:o.consumed,remainingSegments:e.slice(o.consumed.length),parameters:i,positionalParamSegments:o.posParams??{}}}function M7(n){return{matched:!0,parameters:n.length>0?JR(n).parameters:{},consumedSegments:n,remainingSegments:[],positionalParamSegments:{}}}function XR(n,t,e,r){return e.length>0&&P7(n,e,r)?{segmentGroup:new St(t,$7(r,new St(e,n.children))),slicedSegments:[]}:e.length===0&&L7(n,e,r)?{segmentGroup:new St(n.segments,F7(n,e,r,n.children)),slicedSegments:e}:{segmentGroup:new St(n.segments,n.children),slicedSegments:e}}function F7(n,t,e,r){let o={};for(let s of e)if(Ky(n,t,s)&&!r[Uo(s)]){let i=new St([],{});o[Uo(s)]=i}return Te(Te({},r),o)}function $7(n,t){let e={};e[qe]=t;for(let r of n)if(r.path===""&&Uo(r)!==qe){let o=new St([],{});e[Uo(r)]=o}return e}function P7(n,t,e){return e.some(r=>Ky(n,t,r)&&Uo(r)!==qe)}function L7(n,t,e){return e.some(r=>Ky(n,t,r))}function Ky(n,t,e){return(n.hasChildren()||t.length>0)&&e.pathMatch==="full"?!1:e.path===""}function B7(n,t,e,r){return Uo(n)!==r&&(r===qe||!Ky(t,e,n))?!1:HS(t,n,e).matched}function z7(n,t,e){return t.length===0&&!n.children[e]}var BS=class{};function V7(n,t,e,r,o,s,i="emptyOnly"){return new zS(n,t,e,r,o,i,s).recognize()}var U7=31,zS=class{constructor(t,e,r,o,s,i,a){this.injector=t,this.configLoader=e,this.rootComponentType=r,this.config=o,this.urlTree=s,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.applyRedirects=new PS(this.urlSerializer,this.urlTree),this.absoluteRedirectCount=0,this.allowRedirects=!0}noMatchError(t){return new Pe(4002,`'${t.segmentGroup}'`)}recognize(){let t=XR(this.urlTree.root,[],[],this.config).segmentGroup;return this.match(t).pipe(st(({children:e,rootSnapshot:r})=>{let o=new Yr(r,e),s=new Wy("",o),i=q9(r,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(i),{state:s,tree:i}}))}match(t){let e=new Ip([],Object.freeze({}),Object.freeze(Te({},this.urlTree.queryParams)),this.urlTree.fragment,Object.freeze({}),qe,this.rootComponentType,null,{});return this.processSegmentGroup(this.injector,this.config,t,qe,e).pipe(st(r=>({children:r,rootSnapshot:e})),wa(r=>{if(r instanceof sm)return this.urlTree=r.urlTree,this.match(r.urlTree.root);throw r instanceof om?this.noMatchError(r):r}))}processSegmentGroup(t,e,r,o,s){return r.segments.length===0&&r.hasChildren()?this.processChildren(t,e,r,s):this.processSegment(t,e,r,r.segments,o,!0,s).pipe(st(i=>i instanceof Yr?[i]:[]))}processChildren(t,e,r,o){let s=[];for(let i of Object.keys(r.children))i==="primary"?s.unshift(i):s.push(i);return Nn(s).pipe(Yc(i=>{let a=r.children[i],l=l7(e,i);return this.processSegmentGroup(t,l,a,i,o)}),b0((i,a)=>(i.push(...a),i)),Ca(null),x0(),En(i=>{if(i===null)return vp(r);let a=v_(i);return G7(a),We(a)}))}processSegment(t,e,r,o,s,i,a){return Nn(e).pipe(Yc(l=>this.processSegmentAgainstRoute(l._injector??t,e,l,r,o,s,i,a).pipe(wa(u=>{if(u instanceof om)return We(null);throw u}))),us(l=>!!l),wa(l=>{if(x_(l))return z7(r,o,s)?We(new BS):vp(r);throw l}))}processSegmentAgainstRoute(t,e,r,o,s,i,a,l){return B7(r,o,s,i)?r.redirectTo===void 0?this.matchSegmentAgainstRoute(t,o,r,s,i,l):this.allowRedirects&&a?this.expandSegmentAgainstRouteUsingRedirect(t,o,e,r,s,i,l):vp(o):vp(o)}expandSegmentAgainstRouteUsingRedirect(t,e,r,o,s,i,a){let{matched:l,parameters:u,consumedSegments:c,positionalParamSegments:p,remainingSegments:f}=HS(e,o,s);if(!l)return vp(e);typeof o.redirectTo=="string"&&o.redirectTo[0]==="/"&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>U7&&(this.allowRedirects=!1));let d=new Ip(s,u,Object.freeze(Te({},this.urlTree.queryParams)),this.urlTree.fragment,YR(o),Uo(o),o.component??o._loadedComponent??null,o,ZR(o)),h=Gy(d,a,this.paramsInheritanceStrategy);d.params=Object.freeze(h.params),d.data=Object.freeze(h.data);let g=this.applyRedirects.applyRedirectCommands(c,o.redirectTo,p,d,t);return this.applyRedirects.lineralizeSegments(o,g).pipe(En(m=>this.processSegment(t,r,e,m.concat(f),i,!1,a)))}matchSegmentAgainstRoute(t,e,r,o,s,i){let a=O7(e,r,o,t,this.urlSerializer);return r.path==="**"&&(e.children={}),a.pipe(Po(l=>l.matched?(t=r._injector??t,this.getChildConfig(t,r,o).pipe(Po(({routes:u})=>{let c=r._loadedInjector??t,{parameters:p,consumedSegments:f,remainingSegments:d}=l,h=new Ip(f,p,Object.freeze(Te({},this.urlTree.queryParams)),this.urlTree.fragment,YR(r),Uo(r),r.component??r._loadedComponent??null,r,ZR(r)),g=Gy(h,i,this.paramsInheritanceStrategy);h.params=Object.freeze(g.params),h.data=Object.freeze(g.data);let{segmentGroup:m,slicedSegments:y}=XR(e,f,d,u);if(y.length===0&&m.hasChildren())return this.processChildren(c,u,m,h).pipe(st(v=>new Yr(h,v)));if(u.length===0&&y.length===0)return We(new Yr(h,[]));let x=Uo(r)===s;return this.processSegment(c,u,m,y,x?qe:s,!0,h).pipe(st(v=>new Yr(h,v instanceof Yr?[v]:[])))}))):vp(e)))}getChildConfig(t,e,r){return e.children?We({routes:e.children,injector:t}):e.loadChildren?e._loadedRoutes!==void 0?We({routes:e._loadedRoutes,injector:e._loadedInjector}):k7(t,e,r,this.urlSerializer).pipe(En(o=>o?this.configLoader.loadChildren(t,e).pipe(Hn(s=>{e._loadedRoutes=s.routes,e._loadedInjector=s.injector})):_7(e))):We({routes:[],injector:t})}};function G7(n){n.sort((t,e)=>t.value.outlet===qe?-1:e.value.outlet===qe?1:t.value.outlet.localeCompare(e.value.outlet))}function W7(n){let t=n.value.routeConfig;return t&&t.path===""}function v_(n){let t=[],e=new Set;for(let r of n){if(!W7(r)){t.push(r);continue}let o=t.find(s=>r.value.routeConfig===s.value.routeConfig);o!==void 0?(o.children.push(...r.children),e.add(o)):t.push(r)}for(let r of e){let o=v_(r.children);t.push(new Yr(r.value,o))}return t.filter(r=>!e.has(r))}function YR(n){return n.data||{}}function ZR(n){return n.resolve||{}}function j7(n,t,e,r,o,s){return En(i=>V7(n,t,e,r,i.extractedUrl,o,s).pipe(st(({state:a,tree:l})=>dn(Te({},i),{targetSnapshot:a,urlAfterRedirects:l}))))}function H7(n,t){return En(e=>{let{targetSnapshot:r,guards:{canActivateChecks:o}}=e;if(!o.length)return We(e);let s=new Set(o.map(l=>l.route)),i=new Set;for(let l of s)if(!i.has(l))for(let u of w_(l))i.add(u);let a=0;return Nn(i).pipe(Yc(l=>s.has(l)?q7(l,r,n,t):(l.data=Gy(l,l.parent,n).resolve,We(void 0))),Hn(()=>a++),Zc(1),En(l=>a===i.size?We(e):qr))})}function w_(n){let t=n.children.map(e=>w_(e)).flat();return[n,...t]}function q7(n,t,e,r){let o=n.routeConfig,s=n._resolve;return o?.title!==void 0&&!h_(o)&&(s[im]=o.title),K7(s,n,t,r).pipe(st(i=>(n._resolvedData=i,n.data=Gy(n,n.parent,e).resolve,null)))}function K7(n,t,e,r){let o=gS(n);if(o.length===0)return We({});let s={};return Nn(o).pipe(En(i=>X7(n[i],t,e,r).pipe(us(),Hn(a=>{if(a instanceof rm)throw jy(new Yh,a);s[i]=a}))),Zc(1),y0(s),wa(i=>x_(i)?qr:Kc(i)))}function X7(n,t,e,r){let o=am(t)??r,s=kp(n,o),i=s.resolve?s.resolve(t,e):Xs(o,()=>s(t,e));return Ea(i)}function hS(n){return Po(t=>{let e=n(t);return e?Nn(e).pipe(st(()=>t)):We(t)})}var C_=(()=>{let t=class t{buildTitle(r){let o,s=r.root;for(;s!==void 0;)o=this.getResolvedTitleForRoute(s)??o,s=s.children.find(i=>i.outlet===qe);return o}getResolvedTitleForRoute(r){return r.data[im]}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(Y7),providedIn:"root"});let n=t;return n})(),Y7=(()=>{let t=class t extends C_{constructor(r){super(),this.title=r}updateTitle(r){let o=this.buildTitle(r);o!==void 0&&this.title.setTitle(o)}};t.\u0275fac=function(o){return new(o||t)(it(WR))},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),qS=new Qe("",{providedIn:"root",factory:()=>({})}),KS=new Qe(""),Z7=(()=>{let t=class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=ge(eS)}loadComponent(r){if(this.componentLoaders.get(r))return this.componentLoaders.get(r);if(r._loadedComponent)return We(r._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(r);let o=Ea(r.loadComponent()).pipe(st(I_),Hn(i=>{this.onLoadEndListener&&this.onLoadEndListener(r),r._loadedComponent=i}),bh(()=>{this.componentLoaders.delete(r)})),s=new qc(o,()=>new mr).pipe(Hc());return this.componentLoaders.set(r,s),s}loadChildren(r,o){if(this.childrenLoaders.get(o))return this.childrenLoaders.get(o);if(o._loadedRoutes)return We({routes:o._loadedRoutes,injector:o._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(o);let i=Q7(o,this.compiler,r,this.onLoadEndListener).pipe(bh(()=>{this.childrenLoaders.delete(o)})),a=new qc(i,()=>new mr).pipe(Hc());return this.childrenLoaders.set(o,a),a}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();function Q7(n,t,e,r){return Ea(n.loadChildren()).pipe(st(I_),En(o=>o instanceof Ah||Array.isArray(o)?We(o):Nn(t.compileModuleAsync(o))),st(o=>{r&&r(n);let s,i,a=!1;return Array.isArray(o)?(i=o,a=!0):(s=o.create(e).injector,i=s.get(KS,[],{optional:!0,self:!0}).flat()),{routes:i.map(jS),injector:s}}))}function J7(n){return n&&typeof n=="object"&&"default"in n}function I_(n){return J7(n)?n.default:n}var XS=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(eX),providedIn:"root"});let n=t;return n})(),eX=(()=>{let t=class t{shouldProcessUrl(r){return!0}extract(r){return r}merge(r,o){return r}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),tX=new Qe("");var nX=new Qe(""),rX=(()=>{let t=class t{get hasRequestedNavigation(){return this.navigationId!==0}constructor(){this.currentNavigation=null,this.currentTransition=null,this.lastSuccessfulNavigation=null,this.events=new mr,this.transitionAbortSubject=new mr,this.configLoader=ge(Z7),this.environmentInjector=ge(uo),this.urlSerializer=ge(US),this.rootContexts=ge(qy),this.location=ge(zh),this.inputBindingEnabled=ge(WS,{optional:!0})!==null,this.titleStrategy=ge(C_),this.options=ge(qS,{optional:!0})||{},this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlHandlingStrategy=ge(XS),this.createViewTransition=ge(tX,{optional:!0}),this.navigationErrorHandler=ge(nX,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>We(void 0),this.rootComponentType=null;let r=s=>this.events.next(new TS(s)),o=s=>this.events.next(new NS(s));this.configLoader.onLoadEndListener=o,this.configLoader.onLoadStartListener=r}complete(){this.transitions?.complete()}handleNavigationRequest(r){let o=++this.navigationId;this.transitions?.next(dn(Te(Te({},this.transitions.value),r),{id:o}))}setupNavigations(r,o,s){return this.transitions=new jn({id:0,currentUrlTree:o,currentRawUrl:o,extractedUrl:this.urlHandlingStrategy.extract(o),urlAfterRedirects:this.urlHandlingStrategy.extract(o),rawUrl:o,extras:{},resolve:()=>{},reject:()=>{},promise:Promise.resolve(!0),source:Kh,restoredState:null,currentSnapshot:s.snapshot,targetSnapshot:null,currentRouterState:s,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe($o(i=>i.id!==0),st(i=>dn(Te({},i),{extractedUrl:this.urlHandlingStrategy.extract(i.rawUrl)})),Po(i=>{let a=!1,l=!1;return We(i).pipe(Po(u=>{if(this.navigationId>i.id)return this.cancelNavigationTransition(i,"",Zr.SupersededByNewNavigation),qr;this.currentTransition=i,this.currentNavigation={id:u.id,initialUrl:u.rawUrl,extractedUrl:u.extractedUrl,trigger:u.source,extras:u.extras,previousNavigation:this.lastSuccessfulNavigation?dn(Te({},this.lastSuccessfulNavigation),{previousNavigation:null}):null};let c=!r.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl(),p=u.extras.onSameUrlNavigation??r.onSameUrlNavigation;if(!c&&p!=="reload"){let f="";return this.events.next(new ku(u.id,this.urlSerializer.serialize(u.rawUrl),f,vS.IgnoredSameUrlNavigation)),u.resolve(!1),qr}if(this.urlHandlingStrategy.shouldProcessUrl(u.rawUrl))return We(u).pipe(Po(f=>{let d=this.transitions?.getValue();return this.events.next(new Jh(f.id,this.urlSerializer.serialize(f.extractedUrl),f.source,f.restoredState)),d!==this.transitions?.getValue()?qr:Promise.resolve(f)}),j7(this.environmentInjector,this.configLoader,this.rootComponentType,r.config,this.urlSerializer,this.paramsInheritanceStrategy),Hn(f=>{i.targetSnapshot=f.targetSnapshot,i.urlAfterRedirects=f.urlAfterRedirects,this.currentNavigation=dn(Te({},this.currentNavigation),{finalUrl:f.urlAfterRedirects});let d=new zy(f.id,this.urlSerializer.serialize(f.extractedUrl),this.urlSerializer.serialize(f.urlAfterRedirects),f.targetSnapshot);this.events.next(d)}));if(c&&this.urlHandlingStrategy.shouldProcessUrl(u.currentRawUrl)){let{id:f,extractedUrl:d,source:h,restoredState:g,extras:m}=u,y=new Jh(f,this.urlSerializer.serialize(d),h,g);this.events.next(y);let x=f_(this.rootComponentType).snapshot;return this.currentTransition=i=dn(Te({},u),{targetSnapshot:x,urlAfterRedirects:d,extras:dn(Te({},m),{skipLocationChange:!1,replaceUrl:!1})}),this.currentNavigation.finalUrl=d,We(i)}else{let f="";return this.events.next(new ku(u.id,this.urlSerializer.serialize(u.extractedUrl),f,vS.IgnoredByUrlHandlingStrategy)),u.resolve(!1),qr}}),Hn(u=>{let c=new wS(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),st(u=>(this.currentTransition=i=dn(Te({},u),{guards:c7(u.targetSnapshot,u.currentSnapshot,this.rootContexts)}),i)),w7(this.environmentInjector,u=>this.events.next(u)),Hn(u=>{if(i.guardsResult=u.guardsResult,u.guardsResult&&typeof u.guardsResult!="boolean")throw jy(this.urlSerializer,u.guardsResult);let c=new CS(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot,!!u.guardsResult);this.events.next(c)}),$o(u=>u.guardsResult?!0:(this.cancelNavigationTransition(u,"",Zr.GuardRejected),!1)),hS(u=>{if(u.guards.canActivateChecks.length)return We(u).pipe(Hn(c=>{let p=new IS(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(p)}),Po(c=>{let p=!1;return We(c).pipe(H7(this.paramsInheritanceStrategy,this.environmentInjector),Hn({next:()=>p=!0,complete:()=>{p||this.cancelNavigationTransition(c,"",Zr.NoDataFromResolver)}}))}),Hn(c=>{let p=new SS(c.id,this.urlSerializer.serialize(c.extractedUrl),this.urlSerializer.serialize(c.urlAfterRedirects),c.targetSnapshot);this.events.next(p)}))}),hS(u=>{let c=p=>{let f=[];p.routeConfig?.loadComponent&&!p.routeConfig._loadedComponent&&f.push(this.configLoader.loadComponent(p.routeConfig).pipe(Hn(d=>{p.component=d}),st(()=>{})));for(let d of p.children)f.push(...c(d));return f};return zg(c(u.targetSnapshot.root)).pipe(Ca(null),js(1))}),hS(()=>this.afterPreactivation()),Po(()=>{let{currentSnapshot:u,targetSnapshot:c}=i,p=this.createViewTransition?.(this.environmentInjector,u.root,c.root);return p?Nn(p).pipe(st(()=>i)):We(i)}),st(u=>{let c=n7(r.routeReuseStrategy,u.targetSnapshot,u.currentRouterState);return this.currentTransition=i=dn(Te({},u),{targetRouterState:c}),this.currentNavigation.targetRouterState=c,i}),Hn(()=>{this.events.next(new tm)}),u7(this.rootContexts,r.routeReuseStrategy,u=>this.events.next(u),this.inputBindingEnabled),js(1),Hn({next:u=>{a=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Du(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects))),this.titleStrategy?.updateTitle(u.targetRouterState.snapshot),u.resolve(!0)},complete:()=>{a=!0}}),w0(this.transitionAbortSubject.pipe(Hn(u=>{throw u}))),bh(()=>{!a&&!l&&this.cancelNavigationTransition(i,"",Zr.SupersededByNewNavigation),this.currentTransition?.id===i.id&&(this.currentNavigation=null,this.currentTransition=null)}),wa(u=>{if(l=!0,y_(u))this.events.next(new Qs(i.id,this.urlSerializer.serialize(i.extractedUrl),u.message,u.cancellationCode)),s7(u)?this.events.next(new Np(u.url,u.navigationBehaviorOptions)):i.resolve(!1);else{let c=new em(i.id,this.urlSerializer.serialize(i.extractedUrl),u,i.targetSnapshot??void 0);try{let p=Xs(this.environmentInjector,()=>this.navigationErrorHandler?.(c));if(p instanceof rm){let{message:f,cancellationCode:d}=jy(this.urlSerializer,p);this.events.next(new Qs(i.id,this.urlSerializer.serialize(i.extractedUrl),f,d)),this.events.next(new Np(p.redirectTo,p.navigationBehaviorOptions))}else{this.events.next(c);let f=r.errorHandler(u);i.resolve(!!f)}}catch(p){this.options.resolveNavigationPromiseOnError?i.resolve(!1):i.reject(p)}}return qr}))}))}cancelNavigationTransition(r,o,s){let i=new Qs(r.id,this.urlSerializer.serialize(r.extractedUrl),o,s);this.events.next(i),r.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){return this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))).toString()!==this.currentTransition?.extractedUrl.toString()&&!this.currentTransition?.extras.skipLocationChange}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();function oX(n){return n!==Kh}var sX=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(iX),providedIn:"root"});let n=t;return n})(),VS=class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}},iX=(()=>{let t=class t extends VS{};t.\u0275fac=(()=>{let r;return function(s){return(r||(r=_I(t)))(s||t)}})(),t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),S_=(()=>{let t=class t{};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:()=>ge(aX),providedIn:"root"});let n=t;return n})(),aX=(()=>{let t=class t extends S_{constructor(){super(...arguments),this.location=ge(zh),this.urlSerializer=ge(US),this.options=ge(qS,{optional:!0})||{},this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.urlHandlingStrategy=ge(XS),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.currentUrlTree=new Na,this.rawUrlTree=this.currentUrlTree,this.currentPageId=0,this.lastSuccessfulId=-1,this.routerState=f_(null),this.stateMemento=this.createStateMemento()}getCurrentUrlTree(){return this.currentUrlTree}getRawUrlTree(){return this.rawUrlTree}restoredState(){return this.location.getState()}get browserPageId(){return this.canceledNavigationResolution!=="computed"?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}getRouterState(){return this.routerState}createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}registerNonRouterCurrentEntryChangeListener(r){return this.location.subscribe(o=>{o.type==="popstate"&&r(o.url,o.state)})}handleRouterEvent(r,o){if(r instanceof Jh)this.stateMemento=this.createStateMemento();else if(r instanceof ku)this.rawUrlTree=o.initialUrl;else if(r instanceof zy){if(this.urlUpdateStrategy==="eager"&&!o.extras.skipLocationChange){let s=this.urlHandlingStrategy.merge(o.finalUrl,o.initialUrl);this.setBrowserUrl(s,o)}}else r instanceof tm?(this.currentUrlTree=o.finalUrl,this.rawUrlTree=this.urlHandlingStrategy.merge(o.finalUrl,o.initialUrl),this.routerState=o.targetRouterState,this.urlUpdateStrategy==="deferred"&&(o.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,o))):r instanceof Qs&&(r.code===Zr.GuardRejected||r.code===Zr.NoDataFromResolver)?this.restoreHistory(o):r instanceof em?this.restoreHistory(o,!0):r instanceof Du&&(this.lastSuccessfulId=r.id,this.currentPageId=this.browserPageId)}setBrowserUrl(r,o){let s=this.urlSerializer.serialize(r);if(this.location.isCurrentPathEqualTo(s)||o.extras.replaceUrl){let i=this.browserPageId,a=Te(Te({},o.extras.state),this.generateNgRouterState(o.id,i));this.location.replaceState(s,"",a)}else{let i=Te(Te({},o.extras.state),this.generateNgRouterState(o.id,this.browserPageId+1));this.location.go(s,"",i)}}restoreHistory(r,o=!1){if(this.canceledNavigationResolution==="computed"){let s=this.browserPageId,i=this.currentPageId-s;i!==0?this.location.historyGo(i):this.currentUrlTree===r.finalUrl&&i===0&&(this.resetState(r),this.resetUrlToCurrentUrlTree())}else this.canceledNavigationResolution==="replace"&&(o&&this.resetState(r),this.resetUrlToCurrentUrlTree())}resetState(r){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,r.finalUrl??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(r,o){return this.canceledNavigationResolution==="computed"?{navigationId:r,\u0275routerPageId:o}:{navigationId:r}}};t.\u0275fac=(()=>{let r;return function(s){return(r||(r=_I(t)))(s||t)}})(),t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})(),Hh=function(n){return n[n.COMPLETE=0]="COMPLETE",n[n.FAILED=1]="FAILED",n[n.REDIRECTING=2]="REDIRECTING",n}(Hh||{});function lX(n,t){n.events.pipe($o(e=>e instanceof Du||e instanceof Qs||e instanceof em||e instanceof ku),st(e=>e instanceof Du||e instanceof ku?Hh.COMPLETE:(e instanceof Qs?e.code===Zr.Redirect||e.code===Zr.SupersededByNewNavigation:!1)?Hh.REDIRECTING:Hh.FAILED),$o(e=>e!==Hh.REDIRECTING),js(1)).subscribe(()=>{t()})}function uX(n){throw n}var cX={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},pX={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"},T_=(()=>{let t=class t{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}constructor(){this.disposed=!1,this.console=ge(Ny),this.stateManager=ge(S_),this.options=ge(qS,{optional:!0})||{},this.pendingTasks=ge(mp),this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.navigationTransitions=ge(rX),this.urlSerializer=ge(US),this.location=ge(zh),this.urlHandlingStrategy=ge(XS),this._events=new mr,this.errorHandler=this.options.errorHandler||uX,this.navigated=!1,this.routeReuseStrategy=ge(sX),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.config=ge(KS,{optional:!0})?.flat()??[],this.componentInputBindingEnabled=!!ge(WS,{optional:!0}),this.eventsSubscription=new gn,this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe({error:r=>{this.console.warn(r)}}),this.subscribeToNavigationEvents()}subscribeToNavigationEvents(){let r=this.navigationTransitions.events.subscribe(o=>{try{let s=this.navigationTransitions.currentTransition,i=this.navigationTransitions.currentNavigation;if(s!==null&&i!==null){if(this.stateManager.handleRouterEvent(o,i),o instanceof Qs&&o.code!==Zr.Redirect&&o.code!==Zr.SupersededByNewNavigation)this.navigated=!0;else if(o instanceof Du)this.navigated=!0;else if(o instanceof Np){let a=o.navigationBehaviorOptions,l=this.urlHandlingStrategy.merge(o.url,s.currentRawUrl),u=Te({info:s.extras.info,skipLocationChange:s.extras.skipLocationChange,replaceUrl:s.extras.replaceUrl||this.urlUpdateStrategy==="eager"||oX(s.source)},a);this.scheduleNavigation(l,Kh,null,u,{resolve:s.resolve,reject:s.reject,promise:s.promise})}}dX(o)&&this._events.next(o)}catch(s){this.navigationTransitions.transitionAbortSubject.next(s)}});this.eventsSubscription.add(r)}resetRootComponentType(r){this.routerState.root.component=r,this.navigationTransitions.rootComponentType=r}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),Kh,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((r,o)=>{setTimeout(()=>{this.navigateToSyncWithBrowser(r,"popstate",o)},0)})}navigateToSyncWithBrowser(r,o,s){let i={replaceUrl:!0},a=s?.navigationId?s:null;if(s){let u=Te({},s);delete u.navigationId,delete u.\u0275routerPageId,Object.keys(u).length!==0&&(i.state=u)}let l=this.parseUrl(r);this.scheduleNavigation(l,o,a,i)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(r){this.config=r.map(jS),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription&&(this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(r,o={}){let{relativeTo:s,queryParams:i,fragment:a,queryParamsHandling:l,preserveFragment:u}=o,c=u?this.currentUrlTree.fragment:a,p=null;switch(l){case"merge":p=Te(Te({},this.currentUrlTree.queryParams),i);break;case"preserve":p=this.currentUrlTree.queryParams;break;default:p=i||null}p!==null&&(p=this.removeEmptyProps(p));let f;try{let d=s?s.snapshot:this.routerState.snapshot.root;f=l_(d)}catch{(typeof r[0]!="string"||r[0][0]!=="/")&&(r=[]),f=this.currentUrlTree.root}return u_(f,r,p,c??null)}navigateByUrl(r,o={skipLocationChange:!1}){let s=Zh(r)?r:this.parseUrl(r),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,Kh,null,o)}navigate(r,o={skipLocationChange:!1}){return fX(r),this.navigateByUrl(this.createUrlTree(r,o),o)}serializeUrl(r){return this.urlSerializer.serialize(r)}parseUrl(r){try{return this.urlSerializer.parse(r)}catch{return this.urlSerializer.parse("/")}}isActive(r,o){let s;if(o===!0?s=Te({},cX):o===!1?s=Te({},pX):s=o,Zh(r))return jR(this.currentUrlTree,r,s);let i=this.parseUrl(r);return jR(this.currentUrlTree,i,s)}removeEmptyProps(r){return Object.entries(r).reduce((o,[s,i])=>(i!=null&&(o[s]=i),o),{})}scheduleNavigation(r,o,s,i,a){if(this.disposed)return Promise.resolve(!1);let l,u,c;a?(l=a.resolve,u=a.reject,c=a.promise):c=new Promise((f,d)=>{l=f,u=d});let p=this.pendingTasks.add();return lX(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(p))}),this.navigationTransitions.handleNavigationRequest({source:o,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:r,extras:i,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(f=>Promise.reject(f))}};t.\u0275fac=function(o){return new(o||t)},t.\u0275prov=je({token:t,factory:t.\u0275fac,providedIn:"root"});let n=t;return n})();function fX(n){for(let t=0;t<n.length;t++)if(n[t]==null)throw new Pe(4008,!1)}function dX(n){return!(n instanceof tm)&&!(n instanceof Np)}var hX=new Qe("");function N_(n,...t){return hy([{provide:KS,multi:!0,useValue:n},[],{provide:Ep,useFactory:mX,deps:[T_]},{provide:JI,multi:!0,useFactory:gX},t.map(e=>e.\u0275providers)])}function mX(n){return n.routerState.root}function gX(){let n=ge(yu);return t=>{let e=n.get(xp);if(t!==e.components[0])return;let r=n.get(T_),o=n.get(yX);n.get(xX)===1&&r.initialNavigation(),n.get(bX,null,Ye.Optional)?.setUpPreloading(),n.get(hX,null,Ye.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),o.closed||(o.next(),o.complete(),o.unsubscribe())}}var yX=new Qe("",{factory:()=>new mr}),xX=new Qe("",{providedIn:"root",factory:()=>1});var bX=new Qe("");var E_=[];var D_={providers:[bR({eventCoalescing:!0}),N_(E_)]};var Au=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},Js=class{refCount(t){return kr("refCount")}incRef(t){return kr("incRef")}timerAvailable(){return!0}time(t){return kr("time")}read(t){return kr("read")}readSync(t){return kr("readSync")}readToGPU(t,e){return kr("readToGPU")}numDataIds(){return kr("numDataIds")}disposeData(t,e){return kr("disposeData")}write(t,e,r){return kr("write")}move(t,e,r,o,s){return kr("move")}createTensorFromGPUData(t,e,r){return kr("createTensorFromGPUData")}memory(){return kr("memory")}floatPrecision(){return kr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return kr("dispose")}};function kr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function k_(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Xy(n,t,e)}function vX(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,Xy(n,e,r),Xy(t,e,r)}function Ap(n,t,e){return Math.max(n,Math.min(t,e))}function wX(n){return n%2===0?n:n+1}function Xy(n,t,e){let r=n[t];n[t]=n[e],n[e]=r}function CX(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function IX(n,t){let e=Math.random();return t*e+(1-e)*n}function SX(n,t){let e=0;for(let r=0;r<n.length;r++){let o=Number(n[r])-Number(t[r]);e+=o*o}return e}function D(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function Kt(n,t,e=""){D(Ar(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Qr(n){D(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function $e(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function TX(n){return n.length===0}function YS(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==null&&t[e]!==null&&n[e]!==t[e])return!1;return!0}function Ar(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function ei(n){return n%1===0}function NX(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{let t=Math.exp(2*n);return(t-1)/(t+1)}}function EX(n){let t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function DX(n){let t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return k_(t),t}function _u(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function kX(n,t=o=>0,e,r){return new Promise((o,s)=>{let i=0,a=()=>{if(n()){o();return}i++;let l=t(i);if(e!=null&&i>=e){s();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function AX(n,t){let e=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)e*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=n.slice();return o[r]=t/e,o}function an(n,t){let e=t.length;return n=n==null?t.map((r,o)=>o):[].concat(n),D(n.every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),D(n.every(r=>ei(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function ZS(n,t){let e=[],r=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:an(t,n).sort(),i=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[i]==null||s[i]>a)&&n[a]===1&&(e.push(n[a]),r.push(a)),s[i]<=a&&i++}n[a]!==1&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function QS(n,t){return Yy(n,t)}function Yy(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function JS(n,t){for(let e=0;e<n.length;e++){let r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function eT(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function RX(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function Rp(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function tT(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function _p(n){return typeof n=="string"||n instanceof String}function A_(n){return typeof n=="boolean"}function R_(n){return typeof n=="number"}function Da(n){return Array.isArray(n)?Da(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":R_(n)?"float32":_p(n)?"string":A_(n)?"bool":"float32"}function Op(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Mp(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function xs(n){let t=n.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function __(n,t,e,r=!1){let o=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=e[n+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<s;l++)o[l]=__(n+l*a,i,e,r)}return o}function Ru(n,t,e=!1){if(n.length===0)return t[0];let r=n.reduce((o,s)=>o*s)*(e?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return __(0,n,t,e)}function _X(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function um(n,t){let e=Fp(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Fp(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function OX(n,t){let e=n.reduce((r,o)=>r*o,1);if(t==null||t==="float32")return Ru(n,new Float32Array(e));if(t==="int32")return Ru(n,new Int32Array(e));if(t==="bool")return Ru(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Mt(n){n.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function MX(n,t,e){if(t===0)return 0;if(t===1)return n[0];let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=e[o]*n[o];return r}function FX(n,t,e){if(t===0)return[];if(t===1)return[n];let r=new Array(t);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(n/e[o]),n-=r[o]*e[o];return r[r.length-1]=n,r}function Ou(n){return n&&n.then&&typeof n.then=="function"}var O_="tfjsflags",cm=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=PX,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},this.urlFlags[t]!=null){let o=this.urlFlags[t];L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}getAsync(t){return z(this,null,function*(){return t in this.flags?this.flags[t]:(this.flags[t]=yield this.evaluateFlag(t),this.flags[t])})}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Ou(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let t=this.getQueryParams(this.global.location.search);O_ in t&&t[O_].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=BX(o,s)})}};function PX(n){let t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(LX(t,r[0],r[1]),r.join("="))),t}function LX(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function BX(n,t){let e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function L(){return nT}var nT=null;function M_(n){nT=n}var rT;function oT(){if(rT==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");rT=n}return rT}function zX(){let n=oT();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function pm(n,t){let e=zX();if(e.has(n))return e.get(n);{let r=t();return e.set(n,r),e.get(n)}}var ka="Abs",ti="Acos",ni="Acosh",Go="Add",Aa="AddN",$p="All",Pp="Any",Ra="ArgMax",_a="ArgMin",ri="Asin",oi="Asinh",si="Atan",ii="Atanh",ai="Atan2",Oa="AvgPool",Lp="AvgPoolGrad",Ma="AvgPool3D",Bp="AvgPool3DGrad",Fa="BatchMatMul",$a="BatchToSpaceND",zp="Bincount",Mu="BitwiseAnd",F_="BroadcastTo",Vp="BroadcastArgs",bs="Cast",li="Ceil",ui="ClipByValue",Up="Complex",Pa="ComplexAbs",La="Concat",Ba="Conv2D",Gp="Conv2DBackpropFilter",za="Conv2DBackpropInput",Va="Conv3D",Wp="Conv3DBackpropFilterV2",jp="Conv3DBackpropInputV2",ci="Cos",pi="Cosh",Hp="Cumprod",Ua="Cumsum",qp="CropAndResize",Kp="DenseBincount",Xp="DepthToSpace",Ga="DepthwiseConv2dNative",Yp="DepthwiseConv2dNativeBackpropFilter",Zp="DepthwiseConv2dNativeBackpropInput",Qp="Diag",Wa="Dilation2D",fm="Dilation2DBackpropInput",dm="Dilation2DBackpropFilter",$_="Draw",fi="RealDiv",Jp="Einsum",di="Elu",ef="EluGrad",hi="Erf",Fu="Equal",mi="Exp",ja="ExpandDims",gi="Expm1",tf="FFT",nf="Fill",rf="FlipLeftRight",yi="Floor",xi="FloorDiv",Ha="FusedBatchNorm",qa="GatherV2",of="GatherNd",$u="Greater",bi="GreaterEqual",vs="Identity",sf="IFFT",af="Imag",vi="IsFinite",wi="IsInf",Ci="IsNan",Ka="LeakyRelu",Pu="Less",Lu="LessEqual",lf="LinSpace",Ii="Log",Si="Log1p",Bu="LogicalAnd",zu="LogicalNot",Vu="LogicalOr";var P_="LogSoftmax";var Xa="LRN",uf="LRNGrad";var Ya="Max",Ti="Maximum",Za="MaxPool",cf="MaxPoolGrad",Qa="MaxPool3D",pf="MaxPool3DGrad",ff="MaxPoolWithArgmax",Ja="Mean",el="Min",Ni="Minimum",tl="MirrorPad",Ei="Mod",df="Multinomial",Di="Multiply",nl="Neg",Uu="NotEqual",hf="NonMaxSuppressionV3",mf="NonMaxSuppressionV4",gf="NonMaxSuppressionV5",rl="OnesLike",ol="OneHot",sl="Pack",il="PadV2";var ki="Pow",al="Prelu",ll="Prod",yf="RaggedGather",xf="RaggedRange",bf="RaggedTensorToTensor",vf="Range",wf="Real",Ai="Reciprocal",Ri="Relu",ul="Reshape",cl="ResizeNearestNeighbor",Cf="ResizeNearestNeighborGrad",pl="ResizeBilinear",If="ResizeBilinearGrad",_i="Relu6",fl="Reverse",Oi="Round",Mi="Rsqrt",Sf="ScatterNd",Tf="TensorScatterUpdate",Nf="SearchSorted",dl="Select",Fi="Selu",hl="Slice",$i="Sin",Pi="Sinh",Li="Sign",Bi="Sigmoid",zi="Softplus",Vi="Sqrt",ml="Sum",gl="SpaceToBatchND",yl="SplitV",xl="Softmax",Ef="SparseFillEmptyRows",Df="SparseReshape",kf="SparseSegmentMean",Af="SparseSegmentSum",Rf="SparseToDense",Ui="SquaredDifference",_f="Square",Gu="StaticRegexReplace",Of="StridedSlice",Mf="StringNGrams",Ff="StringSplit",$f="StringToHashBucketFast",Gi="Sub",Wi="Tan",ji="Tanh",ws="Tile",Pf="TopK",Lf="Transform",Cs="Transpose",Bf="Unique",bl="Unpack",vl="UnsortedSegmentSum";var wl="ZerosLike",Hi="Step",L_="FromPixels",zf="RotateWithOffset",Wu="_FusedMatMul",ju="FusedConv2D",Hu="FusedDepthwiseConv2D";function Is(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(...n)}function VX(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.log(...n)}var Zy=pm("kernelRegistry",()=>new Map),sT=pm("gradRegistry",()=>new Map);function iT(n,t){let e=V_(n,t);return Zy.get(e)}function aT(n){return sT.get(n)}function lT(n){let t=Zy.entries(),e=[];for(;;){let{done:r,value:o}=t.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===n&&e.push(i)}return e}function Qy(n){let{kernelName:t,backendName:e}=n,r=V_(t,e);Zy.has(r)&&Is(`The kernel '${t}' for backend '${e}' is already registered`),Zy.set(r,n)}function z_(n){let{kernelName:t}=n;sT.has(t)&&L().getBool("DEBUG")&&Is(`Overriding the gradient for '${t}'`),sT.set(t,n)}function V_(n,t){return`${t}_${n}`}var b={};yt(b,{arraysEqual:()=>Ar,arraysEqualWithNull:()=>YS,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Mt,assertNonNull:()=>Qr,assertShapesMatch:()=>Kt,bytesFromStringArray:()=>tT,bytesPerElement:()=>Rp,checkConversionForErrors:()=>JS,clamp:()=>Ap,computeStrides:()=>xs,convertBackendValuesAndArrayBuffer:()=>_X,createScalarValue:()=>KX,createShuffledIndices:()=>DX,decodeString:()=>jf,distSquared:()=>SX,encodeString:()=>Wf,fetch:()=>YX,fingerPrint64:()=>qX,flatten:()=>Il,getArrayFromDType:()=>Yy,getTypedArrayFromDType:()=>QS,hasEncodingLoss:()=>RX,hexToLong:()=>hm,indexToLoc:()=>FX,inferDtype:()=>Da,inferFromImplicitShape:()=>AX,isBoolean:()=>A_,isFunction:()=>Op,isInt:()=>ei,isNumber:()=>R_,isPromise:()=>Ou,isScalarShape:()=>TX,isString:()=>_p,isTypedArray:()=>Kn,isValidDtype:()=>eT,locToIndex:()=>MX,makeOnesTypedArray:()=>um,makeZerosNestedTypedArray:()=>OX,makeZerosTypedArray:()=>Fp,nearestDivisor:()=>Mp,nearestLargerEven:()=>wX,now:()=>Zu,parseAxisParam:()=>an,randUniform:()=>IX,repeatedTry:()=>kX,rightPad:()=>_u,shuffle:()=>k_,shuffleCombo:()=>vX,sizeFromShape:()=>$e,sizeToSquarishShape:()=>EX,squeezeShape:()=>ZS,sum:()=>CX,swap:()=>Xy,tanh:()=>NX,toNestedArray:()=>Ru,toTypedArray:()=>Gf});function Jy(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var fT=gh(Q_());var Yu=fT.default||fT;function hm(n){return Yu.fromString(n,!0,16)}var e2=hm("c3a5c85c97cb3127"),Xu=hm("b492b66fbe98f273"),nr=hm("9ae16a3b2f90404f");function pT(n){return n.xor(n.shru(47))}function t2(n,t,e){let r=n.slice(t,t+e);return Yu.fromBytes(Array.from(r),!0,!0)}function Ft(n,t){return t2(n,t,8)}function J_(n,t){return t2(n,t,4)}function kn(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Cl(n,t,e=hm("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let o=t.xor(r).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function GX(n,t,e,r,o,s){o=o.add(n),s=kn(s.add(o).add(r),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(kn(o,44)),[o.add(r),s.add(i)]}function tx(n,t,e,r){return GX(Ft(n,t),Ft(n,t+8),Ft(n,t+16),Ft(n,t+24),e,r)}function WX(n,t=n.length){if(t>=8){let e=nr.add(t*2),r=Ft(n,0).add(nr),o=Ft(n,t-8),s=kn(o,37).mul(e).add(r),i=kn(r,25).add(o).mul(e);return Cl(s,i,e)}if(t>=4){let e=nr.add(t*2),r=J_(n,0);return Cl(r.shl(3).add(t),J_(n,t-4),e)}if(t>0){let e=n[0],r=n[t>>1],o=n[t-1],s=e+(r<<8),i=t+(o<<2);return pT(nr.mul(s).xor(e2.mul(i))).mul(nr)}return nr}function jX(n,t=n.length){let e=nr.add(t*2),r=Ft(n,0).mul(Xu),o=Ft(n,8),s=Ft(n,t-8).mul(e),i=Ft(n,t-16).mul(nr);return Cl(kn(r.add(o),43).add(kn(s,30)).add(i),r.add(kn(o.add(nr),18)).add(s),e)}function HX(n,t=n.length){let e=nr.add(t*2),r=Ft(n,0).mul(nr),o=Ft(n,8),s=Ft(n,t-8).mul(e),i=Ft(n,t-16).mul(nr),a=kn(r.add(o),43).add(kn(s,30)).add(i),l=Cl(a,r.add(kn(o.add(nr),18)).add(s),e),u=Ft(n,16).mul(e),c=Ft(n,24),p=a.add(Ft(n,t-32)).mul(e),f=l.add(Ft(n,t-24)).mul(e);return Cl(kn(u.add(c),43).add(kn(p,30)).add(f),u.add(kn(c.add(r),18)).add(p),e)}function qX(n,t=n.length){let e=Yu.fromNumber(81,!0);if(t<=32)return t<=16?WX(n,t):jX(n,t);if(t<=64)return HX(n,t);let r=e,o=e.mul(Xu).add(113),s=pT(o.mul(nr).add(113)).mul(nr),i=[Yu.UZERO,Yu.UZERO],a=[Yu.UZERO,Yu.UZERO];r=r.mul(nr).add(Ft(n,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=kn(r.add(o).add(i[0]).add(Ft(n,l+8)),37).mul(Xu),o=kn(o.add(i[1]).add(Ft(n,l+48)),42).mul(Xu),r=r.xor(a[1]),o=o.add(i[0]).add(Ft(n,l+40)),s=kn(s.add(a[0]),33).mul(Xu),i=tx(n,l,i[1].mul(Xu),r.add(a[0])),a=tx(n,l+32,s.add(a[1]),o.add(Ft(n,l+16))),[s,r]=[r,s],l+=64;while(l!==u);let p=Xu.add(s.and(255).shl(1));return l=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=kn(r.add(o).add(i[0]).add(Ft(n,l+8)),37).mul(p),o=kn(o.add(i[1]).add(Ft(n,l+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Ft(n,l+40))),s=kn(s.add(a[0]),33).mul(p),i=tx(n,l,i[1].mul(p),r.add(a[0])),a=tx(n,l+32,s.add(a[1]),o.add(Ft(n,l+16))),[s,r]=[r,s],Cl(Cl(i[0],a[0],p).add(pT(o).mul(e2)).add(s),Cl(i[1],a[1],p).add(r),p)}function KX(n,t){return t==="string"?Wf(n):Gf([n],t)}function XX(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function Gf(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Il(n)),L().getBool("DEBUG")&&JS(n,t),XX(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){let e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)Math.round(n[r])!==0&&(e[r]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Zu(){return L().platform.now()}function YX(n,t){return L().platform.fetch(n,t)}function Wf(n,t="utf-8"){return t=t||"utf-8",L().platform.encode(n,t)}function jf(n,t="utf-8"){return t=t||"utf-8",L().platform.decode(n,t)}function Kn(n){return L().platform.isTypedArray!=null?L().platform.isTypedArray(n):Jy(n)}function Il(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ou(n)||n==null||Kn(n)&&e)t.push(n);else if(Array.isArray(n)||Kn(n))for(let r=0;r<n.length;++r)Il(n[r],t,e);else{let r=-1;for(let o of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)Il(n[o],t,e)}return t}var nx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new dT)}profileKernel(t,e,r){let o,s=()=>{o=r()},i,a=Zu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let u of o)u.dataSync();i=Promise.resolve({kernelMs:Zu()-a})}if(L().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<o.length;u++){let c=o[u];c.data().then(p=>{ZX(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:r,timeMs:o,inputs:s,extraInfo:i}=t;r.forEach(a=>{Promise.all([a.data(),o,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],s,l[2])})})}};function ZX(n,t,e){if(t!=="float32")return!1;for(let r=0;r<n.length;r++){let o=n[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var dT=class{logKernelProfile(t,e,r,o,s,i){let a=typeof o=="number"?_u(`${o}ms`,9):o.error,l=_u(t,25),u=e.rank,c=e.size,p=_u(e.shape.toString(),14),f="";for(let d in s){let h=s[d];if(h!=null){let g=h.shape||e.shape,m=g.length;f+=`${d}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${p}	%c${c}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function n2(n,t,e){let r={},o={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){let u=n[l],c=u.inputs;for(let p in c){let f=c[p],d=!1;for(let h=0;h<t.length;h++)if(r[f.id]){u.outputs.forEach(g=>r[g.id]=!0),d=!0,o[u.id]=!0;break}if(d)break}}let s={};s[e.id]=!0;let i={};for(let l=n.length-1;l>=0;l--){let u=n[l],c=u.inputs;for(let p=0;p<u.outputs.length;p++)if(s[u.outputs[p].id]){for(let f in c)s[c[f].id]=!0,i[u.id]=!0;break}}let a=[];for(let l=0;l<n.length;l++){let u=n[l];if(o[u.id]&&i[u.id]){let c={};for(let f in u.inputs){let d=u.inputs[f];r[d.id]&&(c[f]=d)}let p=Object.assign({},u);p.inputs=c,p.outputs=u.outputs,a.push(p)}}return a}function r2(n,t,e,r){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(l=>{let u=n[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);let u=e(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[l];if(!Ar(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{let p=n[c.id];n[c.id]=r(p,u),p.dispose()}}}}var o2=20,mm=3,hT=7;function s2(n,t,e,r){let o=xs(t),s=QX(n,t,e,o),i=t.length,a=rx(n,t,e,o,s),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function QX(n,t,e,r){let o=$e(t),s=r[r.length-1],i=new Array(s).fill(0),a=t.length,l=e==="complex64"?ym(n):n;if(a>1)for(let u=0;u<o/s;u++){let c=u*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],gm(l[c+p],0,e).length)}return i}function gm(n,t,e){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(hT))} + ${parseFloat(n[1].toFixed(hT))}j`:_p(n)?r=`'${n}'`:e==="bool"?r=i2(n):r=parseFloat(n.toFixed(hT)).toString(),_u(r,t)}function i2(n){return n===0?"false":"true"}function rx(n,t,e,r,o,s=!0){let i=e==="complex64"?2:1,a=t[0],l=t.length;if(l===0){if(e==="complex64"){let g=ym(n);return[gm(g[0],0,e)]}return e==="bool"?[i2(n[0])]:[n[0].toString()]}if(l===1){if(a>o2){let m=mm*i,y=Array.from(n.slice(0,m)),x=Array.from(n.slice((a-mm)*i,a*i));return e==="complex64"&&(y=ym(y),x=ym(x)),["["+y.map((v,w)=>gm(v,o[w],e)).join(", ")+", ..., "+x.map((v,w)=>gm(v,o[a-mm+w],e)).join(", ")+"]"]}return["["+(e==="complex64"?ym(n):Array.from(n)).map((m,y)=>gm(m,o[y],e)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),p=r[0]*i,f=[];if(a>o2){for(let g=0;g<mm;g++){let m=g*p,y=m+p;f.push(...rx(n.slice(m,y),u,e,c,o,!1))}f.push("...");for(let g=a-mm;g<a;g++){let m=g*p,y=m+p;f.push(...rx(n.slice(m,y),u,e,c,o,g===a-1))}}else for(let g=0;g<a;g++){let m=g*p,y=m+p;f.push(...rx(n.slice(m,y),u,e,c,o,g===a-1))}let d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let g=1;g<f.length-1;g++)f[g]=" "+f[g]+d;let h=`,
`;for(let g=2;g<l;g++)h+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":h),f}function ym(n){let t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}var tt=class{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=$e(t),r!=null){let o=r.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Yy(e,this.size),this.strides=xs(t)}set(t,...e){e.length===0&&(e=[0]),D(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let r=this.locToIndex(e);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=this.strides[o]*t[o];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return jo().makeTensor(this.values,this.shape,this.dtype)}},jo=null,Hf=null,JX=null;function a2(n){jo=n}function l2(n){Hf=n}function u2(n){JX=n}var Ke=class{constructor(t,e,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=$e(t),this.strides=xs(t),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return z(this,null,function*(){let t=yield this.data();return Hf.buffer(this.shape,this.dtype,t)})}bufferSync(){return Hf.buffer(this.shape,this.dtype,this.dataSync())}array(){return z(this,null,function*(){let t=yield this.data();return Ru(this.shape,t,this.dtype==="complex64")})}arraySync(){return Ru(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return z(this,null,function*(){this.throwIfDisposed();let t=jo().read(this.dataId);if(this.dtype==="string"){let e=yield t;try{return e.map(r=>jf(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})}dataToGPU(t){return this.throwIfDisposed(),jo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=jo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>jf(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){return z(this,null,function*(){this.throwIfDisposed();let t=yield jo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)})}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),jo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Hf.print(this,t)}clone(){return this.throwIfDisposed(),Hf.clone(this)}toString(t=!1){let e=this.dataSync();return s2(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Hf.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),jo().makeVariable(this,t,e,r)}};Object.defineProperty(Ke,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function M(){return pm("Tensor",()=>Ke)}M();var qi=class extends Ke{constructor(t,e,r,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Ar(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);jo().disposeTensor(this),this.dataId=t.dataId,jo().incRef(this,null)}dispose(){jo().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(qi,Symbol.hasInstance,{value:n=>n instanceof Ke&&n.assign!=null&&n.assign instanceof Function});var c2=function(n){return n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",n}(c2||{}),p2=function(n){return n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",n}(p2||{}),f2=function(n){return n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",n}(f2||{}),d2=function(n){return n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",n}(d2||{}),eY={float32:f2,int32:c2,bool:p2,complex64:d2};function nn(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return eY[n][t]}function Qu(n){return nn(n,"int32")}function ox(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function sx(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Le(n,t){if(n.dtype===t.dtype)return[n,t];let e=nn(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function h2(n,t){D(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function ix(n){let t=[];return m2(n,t,new Set),t}function m2(n,t,e){if(n==null)return;if(n instanceof Ke){t.push(n);return}if(!tY(n))return;let r=n;for(let o in r){let s=r[o];e.has(s)||(e.add(s),m2(s,t,e))}}function tY(n){return Array.isArray(n)||typeof n=="object"}function mT(n){return n.kernelName!=null}var ax=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},rY=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ax}ready(){return z(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r];if(yield this.initializeBackend(o).success){yield this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:r}=this.initializeBackend(e);if(r)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,o=1){return e in this.registryFactory?(Is(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:o},!0)}setBackend(e){return z(this,null,function*(){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(e);if(!(o?yield r:r))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new nx(this.backendInstance),!0})}setupRegisteredKernels(){lT(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){lT(e).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[e])})}initializeBackend(e){let r=this.registryFactory[e];if(r==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof Js)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Is(`Initialization of backend ${e} failed`),Is(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=o,{success:!0,asyncInit:!1}}catch(o){return Is(`Initialization of backend ${e} failed`),Is(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=e,e.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o=null;if(r==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");r=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,r,o){e();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){let r=E.runKernel(vs,{x:e}),o={x:e},s=a=>({x:()=>{let l="float32",u={x:a},c={dtype:l};return E.runKernel(bs,u,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(e,r,o){if(this.backendName==null&&this.backend,!(iT(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(u=>{i+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=s-r-i-a;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let u,c=mT(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(mT(e)){let{kernelName:g,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;let x=iT(g,this.backendName);D(x!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{let v=this.backend.numDataIds();u=x.kernelFunc({inputs:m,attrs:y,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,v,w);let S=w.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(s){let k=this.getTensorsForGradient(g,m,S);o=this.saveTensorsForBackwardMode(k)}return S}}else{let{forwardFunc:g}=e,m=y=>{s&&(o=y.map(x=>this.keep(this.clone(x))))};l=()=>{let y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));let x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,x),x}}let{inputs:p,attrs:f}=e,d=mT(e)?null:e.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=l():(h=this.profiler.profileKernel(c,p,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),r=h.outputs)}),s&&this.addTapeNode(c,p,r,d,o,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(g=>p[g]!=null?p[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(e,r,o){let s=aT(e);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],l;s.saveAllInputs?(D(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);let u=o.filter((c,p)=>a[p]);return l.concat(u)}return[]}makeTensor(e,r,o,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=e;o==="string"&&_p(e[0])&&(i=e.map(u=>Wf(u)));let a=s.write(i,r,o),l=new Ke(r,o,a,this.nextTensorId());if(this.trackTensor(l,s),o==="string"){let u=this.state.tensorInfo.get(a),c=tT(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,r,o,s){o=o||"float32";let i={dataId:e,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,r){let{dataId:o,shape:s,dtype:i}=e,a=new Ke(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));let i=new qi(e,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let o=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(o=e.size*Rp(e.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:o})),e instanceof qi||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let o=e.size*Rp(e.dtype);this.state.numBytes-=o}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let r=this.state.registeredVariables[e];this.disposeVariable(r)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){return z(this,null,function*(){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,r,o,s,i,a){let l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:o,saved:i},u=aT(e);u!=null&&(s=u.gradFunc),s!=null&&(l.gradient=c=>(c=c.map((p,f)=>{if(p==null){let d=o[f],h=Fp(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return p}),s(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){let r=ix(e),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,r,o,s=!1){if(D(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(i instanceof Ke,()=>"The result y returned by f() must be a tensor.");let a=n2(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let l={};l[i.id]=o??oY(i.shape),r2(l,a,c=>this.tidy(c),sY);let u=r.map(c=>l[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let p of c.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return D(Op(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{D(r.every(l=>l instanceof Ke),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((l,u)=>{s[u]=l});let i=(l,u)=>(o=e(...r,u),D(o.value instanceof Ke,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Op(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(l,u)=>{let c=o.gradFunc(l,u),p=Array.isArray(c)?c:[c];D(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(d=>d instanceof Ke),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let f={};return p.forEach((d,h)=>{f[h]=()=>d}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){return z(this,null,function*(){let r=Zu(),o=yield this.backend.time(e);return o.wallMs=Zu()-r,o})}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ax;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function oY(n){let t=um($e(n),"float32");return E.makeTensor(t,n,"float32")}function gT(){let n=oT();if(n._tfengine==null){let t=new cm(n);n._tfengine=new rY(t)}return M_(n._tfengine.ENV),a2(()=>n._tfengine),n._tfengine}var E=gT();function sY(n,t){let e={a:n,b:t};return E.runKernel(Go,e)}var Sl={};yt(Sl,{isBrowser:()=>xT,isMobile:()=>lY,mockIsMobile:()=>aY});function iY(){return typeof navigator<"u"&&navigator!=null}var yT;function aY(n){yT=n}function lY(n){if(yT!==void 0)return yT;if(n||iY()){if(n||(n=navigator),n.product==="ReactNative")return!0;let t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){let e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function xT(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var gr=L();gr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});gr.registerFlag("IS_BROWSER",()=>xT());gr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");gr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));gr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));gr.registerFlag("PROD",()=>!1);gr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>gr.getBool("DEBUG"));gr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);gr.registerFlag("IS_TEST",()=>!1);gr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>gr.getBool("DEBUG"));gr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);gr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);gr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function yr(n,t){let e=n;if(Kn(n))return t==="string"?[]:[n.length];if(ox(n)){let o=n.channels||"RGBA";return[n.height,n.width*o.length]}else if(sx(n))return[n.buffer.size/(t==null?4:Rp(t))];if(!Array.isArray(n))return[];let r=[];for(;Array.isArray(e)||Kn(e)&&t!=="string";)r.push(e.length),e=e[0];return Array.isArray(n)&&L().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&y2(n,r,[]),r}function y2(n,t,e){if(e=e||[],!Array.isArray(n)&&!Kn(n)){D(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}D(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),D(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);let r=t.slice(1);for(let o=0;o<n.length;++o)y2(n[o],r,e.concat(o))}function g2(n,t,e,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function I(n,t,e,r="numeric"){if(n instanceof M())return g2(r,n.dtype,t,e),n;let o=Da(n);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),g2(r,o,t,e),n==null||!Kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){let l=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}let s=yr(n,o);!Kn(n)&&!Array.isArray(n)&&(n=[n]);let a=o!=="string"?Gf(n,o):Il(n,[],!0);return E.makeTensor(a,s,o)}function Ju(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,i)=>I(s,`${t}[${i}]`,e,r))}var bT="__op";function T(n){let t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+bT;let o=(...s)=>{E.startScope(e);try{let i=r(...s);return Ou(i)&&console.error("Cannot return a Promise inside of tidy."),E.endScope(i),i}catch(i){throw E.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function uY(n,t){let e=I(n,"real","complex"),r=I(t,"imag","complex");Kt(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:e,imag:r};return E.runKernel(Up,o)}var xr=T({complex_:uY});function rr(n,t,e,r){if(r==null)r=Da(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(sx(n)||ox(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return E.backend.createTensorFromGPUData(n,t||e,r)}if(!Kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Mt(t);let o=$e(t),s=$e(e);D(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],l=i===e.length-1?a!==$e(t.slice(i)):!0;D(e[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Kn(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=r!=="string"?Gf(n,r):Il(n,[],!0),E.makeTensor(n,t,r)}function ln(n,t,e){let r=yr(n,e);return rr(n,t,r,e)}var Ki={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Pn=class n{static join(t){return new n(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>Kn(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){let o=t[r];r!==t.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=e+o.byteLength;this.shards.push({buffer:o,start:e,end:s}),e=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let o=e-t,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],p=t+a-u.start,f=a,h=Math.min(e,u.end)-u.start,g=new Uint8Array(u.buffer,p,h-p);if(i.set(g,f),a+=g.length,e<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(o){return t<o.start?-1:t>=o.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=cY(this.shards,e);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function cY(n,t){let e=0,r=n.length;for(;e<=r;){let o=Math.floor((r-e)/2)+e,s=t(n[o]);if(s===0)return o;s<0?r=o:e=o+1}return-1}function pY(n){L().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}u2(pY);function yo(){return E}function xm(){return E.memory()}function B(n,t){return E.tidy(n,t)}function Se(n){ix(n).forEach(e=>e.dispose())}function Et(n){return E.keep(n)}function x2(){return E.backendName}function lx(n,t,e=1){return E.registerBackend(n,t,e)}function ux(){return E.backend}var Tl=4;function w2(n,t){return z(this,null,function*(){let e=[],r=[],o=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<o.length;++i){let a=o[i],l=Array.isArray(n)?n[i].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);let u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(p=>z(this,null,function*(){let f=yield l.bytes(),d=f.reduce((m,y)=>m+y.length,0)+Tl*f.length,h=new Uint8Array(d),g=0;for(let m=0;m<f.length;m++){let y=f[m],x=new Uint8Array(new Uint32Array([y.length]).buffer);h.set(x,g),g+=Tl,h.set(y,g),g+=y.length}p(h)}));r.push(c)}else r.push(l.data());t!=null&&(u.group=t),e.push(u)}let s=yield Promise.all(r);return{data:hY(s),specs:e}})}function cx(n,t){let e=new Pn(n),r={},o=0;for(let s of t){let i=fY(s,(a,l)=>e.slice(o+a,o+l));r[s.name]=C2(s,e.slice(o,o+i)),o+=i}return r}function fY(n,t){let e=$e(n.shape),r;if("quantization"in n){let o=n.quantization;r=Ki[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Tl+new Uint32Array(t(o,o+Tl))[0];return o}else r=Ki[n.dtype];return e*r}function dY(n,t){return z(this,null,function*(){let e=$e(n.shape),r;if("quantization"in n){let o=n.quantization;r=Ki[o.dtype]}else if(n.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=Tl+new Uint32Array(yield t(o,o+Tl))[0];return o}else r=Ki[n.dtype];return e*r})}function C2(n,t){let e=n.name,r=n.dtype,o=n.shape,s=$e(o),i,a=0;if("quantization"in n){let l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=Ki[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let p=0;p<c.length;p++){let f=c[p];i[p]=f*l.scale+l.min}}else if(l.dtype==="float16")i=xY()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let p=0;p<c.length;p++){let f=c[p];i[p]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*u}else if(r==="string"){let l=$e(n.shape);i=[];for(let u=0;u<l;u++){let c=new Uint32Array(t.slice(a,a+Tl))[0];a+=Tl;let p=new Uint8Array(t.slice(a,a+c));i.push(p),a+=c}}else{let l=Ki[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let h=0;h<u.length;h++)u[h]=i[h*2],c[h]=i[h*2+1];let p=ln(u,o,"float32"),f=ln(c,o,"float32"),d=xr(p,f);return p.dispose(),f.dispose(),d}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*l}return ln(i,o,r)}function b2(n,t,e){return z(this,null,function*(){let r=new Uint8Array(t);for(;r.byteLength<e;){let{done:o,value:s}=yield n.read();if(o&&s==null){let a=e-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer})}function px(n,t){return z(this,null,function*(){let e={},r=n.getReader(),o=new ArrayBuffer(0);for(let s of t){let i=yield dY(s,(u,c)=>z(this,null,function*(){return o=yield b2(r,o,c),o.slice(u,c)}));o=yield b2(r,o,i);let a=o.slice(0,i);o=o.slice(i);let l=C2(s,a);if(e[s.name]=l,x2()==="webgpu"){let u=ux();"uploadToGPU"in u&&$e(l.shape)>=L().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return e})}function hY(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0,e=[];n.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),o=0;return e.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}var vT=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function v2(n){return vT?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function I2(n){if(vT)return Buffer.from(n).toString("base64");let t=new Uint8Array(n),e="";for(let r=0,o=t.length;r<o;r++)e+=String.fromCharCode(t[r]);return btoa(e)}function S2(n){if(vT){let r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}function T2(n){return Pn.join(n)}function wT(n){let t="/";for(n=n.trim();n.endsWith(t);)n=n.slice(0,n.length-1);let e=n.split(t);return e[e.length-1]}function fx(n,t){let e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function CT(n,t,e){let r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}function qf(n,t){return z(this,null,function*(){let e,r;return n.weightsManifest!=null&&([e,r]=yield t(n.weightsManifest)),CT(n,e,r)})}function Ss(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:v2(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:v2(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Pn(n.weightData).byteLength}}function bm(n){let t=[];for(let e of n)t.push(...e.weights);return t}function mY(){let n=e=>{let r=e<<13,o=0;for(;!(r&8388608);)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function gY(){let n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function yY(){let n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function xY(){let n=mY(),t=gY(),e=yY();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],l=n[e[a>>10]+(a&1023)]+t[a>>10];s[i]=l}return new Float32Array(o)}}var xn=class n{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerSaveRouter(t){n.getInstance().saveRouters.push(t)}static registerLoadRouter(t){n.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return n.getHandlers(t,"save")}static getLoadHandlers(t,e){return n.getHandlers(t,"load",e)}static getHandlers(t,e,r){let o=[];return(e==="load"?n.getInstance().loadRouters:n.getInstance().saveRouters).forEach(i=>{let a=i(t,r);a!==null&&o.push(a)}),o}},N2=n=>xn.registerSaveRouter(n),E2=n=>xn.registerLoadRouter(n),D2=n=>xn.getSaveHandlers(n),k2=(n,t)=>xn.getLoadHandlers(n,t);var IT="tensorflowjs",ST=1,ec="models_store",Nl="model_info_store";function A2(){if(!L().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function TT(n){let t=n.result;t.createObjectStore(ec,{keyPath:"modelPath"}),t.createObjectStore(Nl,{keyPath:"modelPath"})}var tc=(()=>{class n{constructor(e){if(this.indexedDB=A2(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)})}load(){return z(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(e,r){return new Promise((o,s)=>{let i=this.indexedDB.open(IT,ST);i.onupgradeneeded=()=>TT(i),i.onsuccess=()=>{let a=i.result;if(r==null){let l=a.transaction(ec,"readonly"),c=l.objectStore(ec).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(c.result.modelArtifacts)},c.onerror=p=>(a.close(),s(c.error)),l.oncomplete=()=>a.close()}else{r.weightData=Pn.join(r.weightData);let l=Ss(r),u=a.transaction(Nl,"readwrite"),c=u.objectStore(Nl),p;try{p=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(d){return s(d)}let f;p.onsuccess=()=>{f=a.transaction(ec,"readwrite");let d=f.objectStore(ec),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return s(g)}h.onsuccess=()=>o({modelArtifactsInfo:l}),h.onerror=g=>{c=u.objectStore(Nl);let m=c.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(h.error)),m.onerror=y=>(a.close(),s(h.error))}},p.onerror=d=>(a.close(),s(p.error)),u.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return n.URL_SCHEME="indexeddb://",n})();var R2=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tc.URL_SCHEME)?bY(n.slice(tc.URL_SCHEME.length)):null;xn.registerSaveRouter(R2);xn.registerLoadRouter(R2);function bY(n){return new tc(n)}function vY(n){return n.startsWith(tc.URL_SCHEME)?n.slice(tc.URL_SCHEME.length):n}var dx=class{constructor(){this.indexedDB=A2()}listModels(){return z(this,null,function*(){return new Promise((t,e)=>{let r=this.indexedDB.open(IT,ST);r.onupgradeneeded=()=>TT(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(Nl,"readonly"),a=s.objectStore(Nl).getAll();a.onsuccess=()=>{let l={};for(let u of a.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},a.onerror=l=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>e(r.error)})})}removeModel(t){return z(this,null,function*(){return t=vY(t),new Promise((e,r)=>{let o=this.indexedDB.open(IT,ST);o.onupgradeneeded=()=>TT(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Nl,"readwrite"),a=i.objectStore(Nl),l=a.get(t),u;l.onsuccess=()=>{if(l.result==null)return s.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{u=s.transaction(ec,"readwrite");let d=u.objectStore(ec).delete(t);d.onsuccess=()=>e(l.result.modelArtifactsInfo),d.onerror=h=>r(l.error)};c.onsuccess=p,c.onerror=f=>(p(),s.close(),r(l.error))}},l.onerror=c=>(s.close(),r(l.error)),i.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})})}};var Xi="/",Kf="tensorflowjs_models",_2="info",wY="model_topology",CY="weight_specs",IY="weight_data",SY="model_metadata";function O2(n){return{info:[Kf,n,_2].join(Xi),topology:[Kf,n,wY].join(Xi),weightSpecs:[Kf,n,CY].join(Xi),weightData:[Kf,n,IY].join(Xi),modelMetadata:[Kf,n,SY].join(Xi)}}function M2(n){for(let t of Object.values(n))window.localStorage.removeItem(t)}function TY(n){let t=n.split(Xi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Xi)}function NY(n){return n.startsWith(nc.URL_SCHEME)?n.slice(nc.URL_SCHEME.length):n}var nc=(()=>{class n{constructor(e){if(!L().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=O2(this.modelPath)}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),s=Ss(e),i=Pn.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,I2(i));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch{throw M2(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})}load(){return z(this,null,function*(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let l=JSON.parse(i);r.format=l.format,r.generatedBy=l.generatedBy,r.convertedBy=l.convertedBy,l.signature!=null&&(r.signature=l.signature),l.userDefinedMetadata!=null&&(r.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(r.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(r.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(r.trainingConfig=l.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=S2(a),r})}}return n.URL_SCHEME="localstorage://",n})();var F2=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(nc.URL_SCHEME)?EY(n.slice(nc.URL_SCHEME.length)):null;xn.registerSaveRouter(F2);xn.registerLoadRouter(F2);function EY(n){return new nc(n)}var hx=class{constructor(){D(L().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return z(this,null,function*(){let t={},e=Kf+Xi,r=Xi+_2;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(r)){let i=TY(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t})}removeModel(t){return z(this,null,function*(){t=NY(t);let e=O2(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let r=JSON.parse(this.LS.getItem(e.info));return M2(e),r})}};var Xf="://",Ho=class n{constructor(){this.managers={}}static getInstance(){return n.instance==null&&(n.instance=new n),n.instance}static registerManager(t,e){D(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Xf)&&(t=t.slice(0,t.indexOf(Xf))),D(t.length>0,()=>"scheme must not be an empty string.");let r=n.getInstance();D(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){let e=n.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(n.getInstance().managers)}};function mx(n){if(n.indexOf(Xf)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ho.getSchemes().join(",")}`);return{scheme:n.split(Xf)[0],path:n.split(Xf)[1]}}function $2(n,t,e=!1){return z(this,null,function*(){D(n!==t,()=>`Old path and new path are the same: '${n}'`);let r=xn.getLoadHandlers(n);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);let o=r[0],s=xn.getSaveHandlers(t);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],a=mx(n).scheme,l=mx(n).path,u=a===mx(n).scheme,c=yield o.load();e&&u&&(yield Ho.getManager(a).removeModel(l));let p=yield i.save(c);return e&&!u&&(yield Ho.getManager(a).removeModel(l)),p.modelArtifactsInfo})}function P2(){return z(this,null,function*(){let n=Ho.getSchemes(),t={};for(let e of n){let r=yield Ho.getManager(e).listModels();for(let o in r){let s=e+Xf+o;t[s]=r[o]}}return t})}function L2(n){return z(this,null,function*(){let t=mx(n);return Ho.getManager(t.scheme).removeModel(t.path)})}function B2(n,t){return z(this,null,function*(){return $2(n,t,!1)})}function z2(n,t){return z(this,null,function*(){return $2(n,t,!0)})}var NT=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!L().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return Jy(t)}};if(L().get("IS_BROWSER")){L().setPlatform("browser",new NT);try{Ho.registerManager(nc.URL_SCHEME,new hx)}catch{}try{Ho.registerManager(tc.URL_SCHEME,new dx)}catch{}}var kY={importFetch:()=>U2()},ET;var DT=class{constructor(){this.util=G2(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return L().global.fetch!=null?L().global.fetch(t,e):(ET==null&&(ET=kY.importFetch()),ET(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}};L().get("IS_NODE")&&!L().get("IS_BROWSER")&&L().setPlatform("node",new DT);function de(n,t="float32",e){return t=t||"float32",Mt(n),new tt(n,t,e)}function AY(n,t){let e=I(n,"x","cast");if(!eT(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:e},o={dtype:t};return E.runKernel(bs,r,o)}var Y=T({cast_:AY});function RY(n){let e={x:I(n,"x","clone","string_or_numeric")};return E.runKernel(vs,e)}var or=T({clone_:RY});function gx(n,t=!1){console.log(n.toString(t))}gT();var _Y={buffer:de,cast:Y,clone:or,print:gx};l2(_Y);function OY(n,t){let e=I(n,"a","add"),r=I(t,"b","add");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(Go,o)}var j=T({add_:OY});function MY(n,t){let e=I(n,"a","floorDiv"),r=I(t,"b","floorDiv");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(xi,o)}var Zf=T({floorDiv_:MY});function FY(n,t){let e=I(n,"a","div"),r=I(t,"b","div");if([e,r]=Le(e,r),e.dtype==="int32"&&r.dtype==="int32")return Zf(e,r);let o={a:e,b:r},s={};return E.runKernel(fi,o,s)}var ne=T({div_:FY});function $Y(n,t){let e=I(n,"a","mul"),r=I(t,"b","mul");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(Di,o)}var R=T({mul_:$Y});function PY(n){let t=I(n,"x","abs");if(t.dtype==="complex64"){let e={x:t};return E.runKernel(Pa,e)}else{let e={x:t};return E.runKernel(ka,e)}}var Tt=T({abs_:PY});function LY(n){let e={x:I(n,"x","acos")};return E.runKernel(ti,e)}var yx=T({acos_:LY});function BY(n){let e={x:I(n,"x","acosh")};return E.runKernel(ni,e)}var xx=T({acosh_:BY});function zY(n){D(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),D(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);let t=n.map((o,s)=>I(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Ar(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return E.runKernel(Aa,r)}var W2=T({addN_:zY});function VY(n,t=null,e=!1){let o={x:I(n,"x","all","bool")},s={axis:t,keepDims:e};return E.runKernel($p,o,s)}var Qf=T({all_:VY});function UY(n,t=null,e=!1){let o={x:I(n,"x","any","bool")},s={axis:t,keepDims:e};return E.runKernel(Pp,o,s)}var oc=T({any_:UY});function GY(n,t=0){let r={x:I(n,"x","argMax")},o={axis:t};return E.runKernel(Ra,r,o)}var Ts=T({argMax_:GY});function WY(n,t=0){let r={x:I(n,"x","argMin")},o={axis:t};return E.runKernel(_a,r,o)}var bx=T({argMin_:WY});function jY(n){let e={x:I(n,"x","asin")};return E.runKernel(ri,e)}var vx=T({asin_:jY});function HY(n){let e={x:I(n,"x","asinh")};return E.runKernel(oi,e)}var wx=T({asinh_:HY});function qY(n){let e={x:I(n,"x","atan")};return E.runKernel(si,e)}var Cx=T({atan_:qY});function KY(n,t){let e=I(n,"a","atan2"),r=I(t,"b","atan2");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(ai,o)}var Ix=T({atan2_:KY});function XY(n){let e={x:I(n,"x","atanh")};return E.runKernel(ii,e)}var Sx=T({atanh_:XY});function YY(n,t,e,r,o="NHWC",s){let i=n[3],a=[...t,i],l=H2(o);return sc(n,a,e,s,r,null,null,l)}function AT(n,t,e,r,o,s,i="channelsLast"){let[a,l]=vm(t),u;if(i==="channelsLast")u=[a,l,n[3],n[3]];else if(i==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return sc(n,u,e,r,o,s,!1,i)}function ZY(n,t,e,r,o,s,i="NDHWC"){let[a,l,u]=kT(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,l,u,n[4],n[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return j2(n,c,e,r,o,!1,p,s)}function sc(n,t,e,r,o,s,i=!1,a="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,p]=n;else if(a==="channelsFirst")[l,p,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,,h]=t,[g,m]=vm(e),[y,x]=vm(r),v=Jf(f,y),w=Jf(d,x),{padInfo:S,outHeight:k,outWidth:A}=eZ(o,u,c,g,m,v,w,s,a),_=i?h*p:h,F;return a==="channelsFirst"?F=[l,_,k,A]:a==="channelsLast"&&(F=[l,k,A,_]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:p,outHeight:k,outWidth:A,outChannels:_,padInfo:S,strideHeight:g,strideWidth:m,filterHeight:f,filterWidth:d,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:x,inShape:n,outShape:F,filterShape:t}}function j2(n,t,e,r,o,s=!1,i="channelsLast",a){let[l,u,c,p,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,p,f]=n;else if(i==="channelsFirst")[l,f,u,c,p]=n;else throw new Error(`Unknown dataFormat ${i}`);let[d,h,g,,m]=t,[y,x,v]=kT(e),[w,S,k]=kT(r),A=Jf(d,w),_=Jf(h,S),F=Jf(g,k),{padInfo:$,outDepth:V,outHeight:U,outWidth:W}=tZ(o,u,c,p,y,x,v,A,_,F,a),G=s?m*f:m,H;return i==="channelsFirst"?H=[l,G,V,U,W]:i==="channelsLast"&&(H=[l,V,U,W,G]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:p,inChannels:f,outDepth:V,outHeight:U,outWidth:W,outChannels:G,padInfo:$,strideDepth:y,strideHeight:x,strideWidth:v,filterDepth:d,filterHeight:h,filterWidth:g,effectiveFilterDepth:A,effectiveFilterHeight:_,effectiveFilterWidth:F,dilationDepth:w,dilationHeight:S,dilationWidth:k,inShape:n,outShape:H,filterShape:t}}function QY(n,t,e,r,o){r==null&&(r=RT(n,t,e));let s=n[0],i=n[1],a=wm((s-t+2*r)/e+1,o),l=wm((i-t+2*r)/e+1,o);return[a,l]}function JY(n,t,e,r,o,s){o==null&&(o=RT(n,t[0],r[0]));let i=[0,0,0,e];for(let a=0;a<3;a++)n[a]+2*o>=t[a]&&(i[a]=wm((n[a]-t[a]+2*o)/r[a]+1,s));return i}function RT(n,t,e,r=1){let o=Jf(t,r);return Math.floor((n[0]*(e-1)-e+o)/2)}function vm(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function kT(n){return typeof n=="number"?[n,n,n]:n}function Jf(n,t){return t<=1?n:n+(n-1)*(t-1)}function eZ(n,t,e,r,o,s,i,a,l){let u,c,p;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};let d=QY([t,e],s,r,n,a);c=d[0],p=d[1]}else if(n==="same"){c=Math.ceil(t/r),p=Math.ceil(e/o);let f=Math.max(0,(c-1)*r+s-t),d=Math.max(0,(p-1)*o+i-e),h=Math.floor(f/2),g=f-h,m=Math.floor(d/2),y=d-m;u={top:h,bottom:g,left:m,right:y,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),p=Math.ceil((e-i+1)/o);else if(typeof n=="object"){let f=l==="channelsLast"?n[1][0]:n[2][0],d=l==="channelsLast"?n[1][1]:n[2][1],h=l==="channelsLast"?n[2][0]:n[3][0],g=l==="channelsLast"?n[2][1]:n[3][1];u={top:f,bottom:d,left:h,right:g,type:f===0&&d===0&&h===0&&g===0?"VALID":"EXPLICIT"},c=wm((t-s+f+d)/r+1,a),p=wm((e-i+h+g)/o+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:p}}function tZ(n,t,e,r,o,s,i,a,l,u,c){let p,f,d,h;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};let m=JY([t,e,r,1],[a,l,u],1,[o,s,i],n,c);f=m[0],d=m[1],h=m[2]}else if(n==="same"){f=Math.ceil(t/o),d=Math.ceil(e/s),h=Math.ceil(r/i);let g=(f-1)*o+a-t,m=(d-1)*s+l-e,y=(h-1)*i+u-r,x=Math.floor(g/2),v=g-x,w=Math.floor(m/2),S=m-w,k=Math.floor(y/2),A=y-k;p={top:w,bottom:S,left:k,right:A,front:x,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:f,outHeight:d,outWidth:h}}function wm(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Jr(n){let[t,e,r]=vm(n);return t===1&&e===1&&r===1}function An(n,t){return Jr(n)||Jr(t)}function Ns(n){return vm(n).every(t=>t>0)}function H2(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function bt(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")D(ei(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(o=>{D(ei(o),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function nZ(n,t){let r={x:I(n,"x","reshape","string_or_numeric")},o={shape:t};return E.runKernel(ul,r,o)}var O=T({reshape_:nZ});function rZ(n,t,e,r,o){let s=I(n,"x","avgPool","float32"),i=1;D(An(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),bt("avgPool",r,o);let u={x:a},c={filterSize:t,strides:e,pad:r,dimRoundingMode:o},p=E.runKernel(Oa,u,c);return p=Y(p,s.dtype),l?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var El=T({avgPool_:rZ});function oZ(n,t,e,r,o,s="NDHWC"){let i=I(n,"x","avgPool3d","float32"),a=i,l=!1;i.rank===4&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),D(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),bt("avgPool3d",r,o);let u={x:a},c={filterSize:t,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=E.runKernel(Ma,u,c);return p=Y(p,a.dtype),l?O(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Tx=T({avgPool3d_:oZ});function sZ(n,t=0){D(n.length>=1,()=>"Pass at least one tensor to concat");let e=Ju(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return or(e[0]);let r=e,o={axis:t};return E.runKernel(La,r,o)}var Je=T({concat_:sZ});function iZ(n,t,e=!1,r=!1){let o=I(n,"a","matMul"),s=I(t,"b","matMul");[o,s]=Le(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:r};return E.runKernel(Fa,i,a)}var Oe=T({matMul_:iZ});function aZ(n){let e={x:I(n,"x","sigmoid","float32")};return E.runKernel(Bi,e)}var Xn=T({sigmoid_:aZ});function lZ(n,t,e){let r=I(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:t,size:e};return E.runKernel(hl,o,s)}var Ne=T({slice_:lZ});function uZ(n){let e={x:I(n,"x","tanh","float32")};return E.runKernel(ji,e)}var qo=T({tanh_:uZ});function cZ(n,t,e,r,o,s){let i=I(n,"forgetBias","basicLSTMCell"),a=I(t,"lstmKernel","basicLSTMCell"),l=I(e,"lstmBias","basicLSTMCell"),u=I(r,"data","basicLSTMCell"),c=I(o,"c","basicLSTMCell"),p=I(s,"h","basicLSTMCell"),f=Je([u,p],1),d=Oe(f,a),h=j(d,l),g=h.shape[0],m=h.shape[1]/4,y=[g,m],x=Ne(h,[0,0],y),v=Ne(h,[0,m],y),w=Ne(h,[0,m*2],y),S=Ne(h,[0,m*3],y),k=j(R(Xn(x),qo(v)),R(c,Xn(j(i,w)))),A=R(qo(k),Xn(S));return[k,A]}var q2=T({basicLSTMCell_:cZ});function pZ(n,t,e){let r=I(n,"x","batchToSpaceND"),o=t.reduce((a,l)=>a*l);D(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),D(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),D(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:r},i={blockShape:t,crops:e};return E.runKernel($a,s,i)}var Dl=T({batchToSpaceND_:pZ});function K2(n){let t;return n.rank===0||n.rank===1?t=O(n,[1,1,1,n.size]):n.rank===2?t=O(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function fZ(n,t,e,r,o,s){s==null&&(s=.001);let i=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;r!=null&&(c=I(r,"offset","batchNorm")),D(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let f={x:K2(i),scale:u,offset:c,mean:a,variance:l},d={varianceEpsilon:s},h=E.runKernel(Ha,f,d);return O(h,i.shape)}var Es=T({batchNorm_:fZ});function dZ(n,t,e,r,o,s){let i=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),D(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Es(i,a,l,c,u,s)}var Nx=T({batchNorm2d_:dZ});function hZ(n,t,e,r,o,s){let i=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),D(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Es(i,a,l,c,u,s)}var Ex=T({batchNorm3d_:hZ});function mZ(n,t,e,r,o,s){let i=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm"),u;o!=null&&(u=I(o,"scale","batchNorm"));let c;return r!=null&&(c=I(r,"offset","batchNorm")),D(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),D(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&D(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Es(i,a,l,c,u,s)}var Dx=T({batchNorm4d_:mZ});function gZ(n,t,e){let r=I(n,"x","bincount"),o=I(t,"weights","bincount");D(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:e};return E.runKernel(zp,s,i)}var kx=T({bincount_:gZ});function yZ(n,t){let e=I(n,"x","bitwiseAnd"),r=I(t,"y","bitwiseAnd");if(!Ar(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if(e.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);let o={a:e,b:r};return E.runKernel(Mu,o)}var X2=T({bitwiseAnd_:yZ});function xZ(n,t){let e=I(n,"s0","broadcastArgs","int32"),r=I(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:e,s1:r};return E.runKernel(Vp,o)}var Y2=T({broadcastArgs_:xZ});function bZ(n,t){let e=I(n,"broadcastTo","x"),r=e.shape;if(Mt(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=O(e,u)}let o=e.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(o[u]===t[u])s[u]=1;else if(e.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return or(e);let a={x:e},l={reps:s};return E.runKernel(ws,a,l)}var Ds=T({broadcastTo_:bZ});function vZ(n){let e={x:I(n,"x","ceil","float32")};return E.runKernel(li,e)}var Ax=T({ceil_:vZ});function xo(n,t,e){Mt(n),e=e||Da(t);let r={shape:n,value:t,dtype:e};return E.runKernel(nf,{},r)}function wZ(n,t,e){let r=I(n,"x","clipByValue");if(D(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return xo(r.shape,t,r.dtype);let o={x:r},s={clipValueMin:t,clipValueMax:e};return E.runKernel(ui,o,s)}var bn=T({clipByValue_:wZ});function CZ(n){return Je(n,0)}var Rx=T({concat1d_:CZ});function IZ(n,t){return Je(n,t)}var _x=T({concat2d_:IZ});function SZ(n,t){return Je(n,t)}var Ox=T({concat3d_:SZ});function TZ(n,t){return Je(n,t)}var Mx=T({concat4d_:TZ});function NZ(n,t,e,r,o="NHWC",s=[1,1],i){let a=I(n,"x","conv2d","float32"),l=I(t,"filter","conv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),bt("conv2d",r,i);let p=o==="NHWC"?u.shape[3]:u.shape[1];D(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),D(An(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),D(Ns(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Ns(e),()=>"Error in conv2D: Strides should be larger than 0.");let f={x:u,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=E.runKernel(Ba,f,d);return c?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var br=T({conv2d_:NZ});function EZ(n,t,e,r,o="NWC",s=1,i){let a=I(n,"x","conv1d"),l=I(t,"filter","conv1d"),u=a,c=!1;a.rank===2&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1]])),D(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),D(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),bt("conv1d",r,i),D(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(An(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),D(Ns(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Ns(e),()=>"Error in conv1D: Stride should be larger than 0."),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=O(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=O(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=br(f,p,[1,e],r,"NHWC",[1,s],i);return c?O(m,[m.shape[2],m.shape[3]]):O(m,[m.shape[0],m.shape[2],m.shape[3]])}var ed=T({conv1d_:EZ});function DZ(n,t,e,r,o,s="NHWC",i){D(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,u=!1;t.rank===3&&(u=!0,l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),D(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),D(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?l.shape[3]:l.shape[1];D(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),D(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),bt("conv2dDerInput",o,i);let f={dy:l,filter:e},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},h=E.runKernel(za,f,d);return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var td=T({conv2DBackpropInput_:DZ});function kZ(n,t,e,r,o,s){let i=I(n,"x","conv2dTranspose"),a=I(t,"filter","conv2dTranspose");return td(e,i,a,r,o,"NHWC",s)}var nd=T({conv2dTranspose_:kZ});function AZ(n,t,e,r,o="NDHWC",s=[1,1,1]){let i=I(n,"x","conv3d"),a=I(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),D(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),D(An(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),D(Ns(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Ns(e),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:a},p={strides:e,pad:r,dataFormat:o,dilations:s},f=E.runKernel(Va,c,p);return u?O(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Fx=T({conv3d_:AZ});function RZ(n,t,e,r,o){D(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let s=n,i=t,a=!1;t.rank===4&&(a=!0,i=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);let l=s[4],u=i.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),D(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),D(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),D(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:r,inputShape:s},f=E.runKernel(jp,c,p);return a?O(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var $x=T({conv3DBackpropInput_:RZ});function _Z(n,t,e,r,o){let s=I(n,"x","conv3dTranspose"),i=I(t,"filter","conv3dTranspose");return $x(e,s,i,r,o)}var Px=T({conv3dTranspose_:_Z});function OZ(n){let e={x:I(n,"x","cos","float32")};return E.runKernel(ci,e)}var kl=T({cos_:OZ});function MZ(n){let e={x:I(n,"x","cosh","float32")};return E.runKernel(pi,e)}var rd=T({cosh_:MZ});function FZ(n,t=0,e=!1,r=!1){let s={x:I(n,"x","cumprod")},i={axis:t,exclusive:e,reverse:r};return E.runKernel(Hp,s,i)}var ic=T({cumprod_:FZ});function $Z(n,t=0,e=!1,r=!1){let s={x:I(n,"x","cumsum")},i={axis:t,exclusive:e,reverse:r};return E.runKernel(Ua,s,i)}var od=T({cumsum_:$Z});function PZ(n,t,e,r=!1){let o=I(n,"x","denseBincount"),s=I(t,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(e>=0,()=>`size must be non-negative, but got ${e}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:r};return E.runKernel(Kp,i,a)}var Cm=T({denseBincount_:PZ});function LZ(n,t,e="NHWC"){let r=I(n,"x","depthToSpace","float32"),o=e==="NHWC"?r.shape[1]:r.shape[2],s=e==="NHWC"?r.shape[2]:r.shape[3],i=e==="NHWC"?r.shape[3]:r.shape[1];D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${r.shape}`),D(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),D(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},l={blockSize:t,dataFormat:e};return E.runKernel(Xp,a,l)}var Lx=T({depthToSpace_:LZ});function BZ(n,t,e,r,o="NHWC",s=[1,1],i){let a=I(n,"x","depthwiseConv2d","float32"),l=I(t,"filter","depthwiseConv2d","float32"),u=a,c=!1;a.rank===3&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p=o==="NHWC"?u.shape[3]:u.shape[1];D(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),bt("depthwiseConv2d",r,i);let f={x:u,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=E.runKernel(Ga,f,d);return c?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ks=T({depthwiseConv2d_:BZ});function zZ(n){let e={x:I(n,"x","diag")};return E.runKernel(Qp,e)}var Z2=T({diag_:zZ});function VZ(n,t,e,r,o=[1,1],s="NHWC"){let i=I(n,"x","dilation2d"),a=I(t,"filter","dilation2d");D(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),D(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),D(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);let c={x:l,filter:a},p={strides:e,pad:r,dilations:o},f=E.runKernel(Wa,c,p);return u?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Bx=T({dilation2d_:VZ});var Or={};yt(Or,{assertAndGetBroadcastShape:()=>De,getBroadcastDims:()=>Q2,getReductionAxes:()=>ht});function Q2(n,t){let e=n.length,r=[];for(let o=0;o<e;o++){let s=e-1-o,i=n[s]||1;(t[t.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function ht(n,t){let e=[];for(let r=0;r<t.length;r++){let o=n[n.length-r-1],s=t.length-r-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function De(n,t){let e=Math.max(n.length,t.length),r=new Array(e);for(let o=0;o<e;o++){let s=n[n.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)r[e-o-1]=i;else if(i===1)r[e-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(a)}else r[e-o-1]=s}return r}function UZ(n,t){let e=I(n,"a","equal","string_or_numeric"),r=I(t,"b","equal","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Fu,o)}var Yn=T({equal_:UZ});function GZ(n,t,e){let r=I(t,"a","where"),o=I(e,"b","where"),s=I(n,"condition","where","bool"),i=De(De(s.shape,r.shape),o.shape),a=Ds(s,i),l=Ds(r,i),u=Ds(o,i),c={condition:a,t:l,e:u};return E.runKernel(dl,c)}var vt=T({where_:GZ});function WZ(n){let e={x:I(n,"x","zerosLike")};return E.runKernel(wl,e)}var ye=T({zerosLike_:WZ});function jZ(n,t){let e=I(n,"a","div"),r=I(t,"b","div");[e,r]=Le(e,r);let o=ne(e,r),s=ye(o),i=Yn(r,s);return vt(i,s,o)}var zx=T({divNoNan_:jZ});function HZ(n,t){let e=I(n,"t1","dot"),r=I(t,"t2","dot");D((e.rank===1||e.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=r.rank===1?r.size:r.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&r.rank===1){let i=O(e,[1,-1]),a=O(r,[-1,1]),l=Oe(i,a);return O(l,[])}else if(e.rank===1&&r.rank===2){let i=O(e,[1,-1]),a=O(r,[r.shape[0],r.shape[1]]),l=Oe(i,a);return O(l,[l.size])}else if(e.rank===2&&r.rank===1){let i=O(r,[-1,1]),a=Oe(e,i);return O(a,[a.size])}else{let i=O(r,[r.shape[0],r.shape[1]]);return Oe(e,i)}}var Vx=T({dot_:HZ});function qZ(n,...t){let e=t.map((o,s)=>I(o,`tensors${s}`,"einsum")),r={equation:n};return E.runKernel(Jp,e,r)}var Al=T({einsum_:qZ});function KZ(n){let e={x:I(n,"x","elu","float32")};return E.runKernel(di,e)}var As=T({elu_:KZ});function XZ(n,t){let e=I(n,"x","ensureShape","string_or_numeric");if(!YS(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}var J2=T({ensureShape_:XZ});function YZ(n){let t=I(n,"x","erf");D(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Y(t,"float32"));let e={x:t};return E.runKernel(hi,e)}var sd=T({erf_:YZ});function _T(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function eO(n,t,e){let r=n.length+t.length,o=[],s=0,i=0;for(let a=0;a<r;a++)e.indexOf(a)===-1?o.push(n[s++]):o.push(t[i++]);return o}function OT(n,t){let e=[],r=n.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&e.push(n[s]);let o=t.map(s=>n[s]);return[e,o]}function bo(n,t){let e=t.map(r=>1);return eO(n,e,t)}function ZZ(n,t,e){D(_T(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function MT(n,t){if(_T(n,t))return null;let e=[];for(let r=0;r<t;++r)n.indexOf(r)===-1&&e.push(r);return n.forEach(r=>e.push(r)),e}function Im(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function QZ(n,t){let e=[];for(let r=t-n;r<t;++r)e.push(r);return e}function JZ(n,t=null,e=!1){let o={x:I(n,"x","max")},s={reductionIndices:t,keepDims:e};return E.runKernel(Ya,o,s)}var vn=T({max_:JZ});function eQ(n,t=null,e=!1){let o={x:I(n,"x","min")},s={axis:t,keepDims:e};return E.runKernel(el,o,s)}var Yi=T({min_:eQ});function tQ(n,t){let e=I(n,"base","pow"),r=I(t,"exp","pow");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(ki,o)}var Ln=T({pow_:tQ});function se(n,t){if((Kn(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Kn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return rr(n,[],[],t)}function nQ(n){let e={x:I(n,"x","sqrt","float32")};return E.runKernel(Vi,e)}var pt=T({sqrt_:nQ});function rQ(n){let t=I(n,"x","square"),e={};return E.runKernel("Square",{x:t},e)}var _e=T({square_:rQ});function oQ(n,t=null,e=!1){let r=I(n,"x","sum");r.dtype==="bool"&&(r=Y(r,"int32"));let o={x:r},s={axis:t,keepDims:e};return E.runKernel(ml,o,s)}var ie=T({sum_:oQ});function sQ(n,t="euclidean",e=null,r=!1){n=I(n,"x","norm");let o=tO(n,t,e),s=o.shape;if(r){let i=an(e,n.shape);s=bo(o.shape,i)}return O(o,s)}function tO(n,t,e=null){if(n.rank===0)return Tt(n);if(n.rank!==1&&e===null)return tO(O(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ie(Tt(n),e);if(t===1/0)return vn(Tt(n),e);if(t===-1/0)return Yi(Tt(n),e);if(t==="euclidean"||t===2)return pt(ie(Ln(Tt(n),se(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return vn(ie(Tt(n),e[0]),e[1]-1);if(t===1/0)return vn(ie(Tt(n),e[1]),e[0]);if(t===-1/0)return Yi(ie(Tt(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return pt(ie(_e(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var Zi=T({norm_:sQ});function iQ(n,t=null,e=!1){return Zi(n,"euclidean",t,e)}var Ux=T({euclideanNorm_:iQ});function aQ(n){let e={x:I(n,"x","exp")};return E.runKernel(mi,e)}var Ht=T({exp_:aQ});function lQ(n,t=0){let e=I(n,"x","expandDims","string_or_numeric");D(t<=e.rank,()=>"Axis must be <= rank of the tensor");let r={input:e},o={dim:t};return E.runKernel(ja,r,o)}var Xt=T({expandDims_:lQ});function uQ(n){let e={x:I(n,"x","expm1")};return E.runKernel(gi,e)}var Gx=T({expm1_:uQ});function cQ(n,t){let e=I(n,"x","tile","string_or_numeric");D(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let r={x:e},o={reps:t};return E.runKernel(ws,r,o)}var Rn=T({tile_:cQ});function pQ(n,t,e,r="float32"){t==null&&(t=n);let o=de([n,t],r),s=n<=t?n:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=O(o.toTensor(),[n,t]);if(e==null)return i;if(e.length===1)return Rn(Xt(i,0),[e[0],1,1]);if(e.length===2)return Rn(Xt(Xt(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return Rn(Xt(Xt(Xt(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var ac=T({eye_:pQ});function fQ(n){let e={x:I(n,"x","floor","float32")};return E.runKernel(yi,e)}var Rs=T({floor_:fQ});function dQ(n,t,e=0,r=0){let o=I(n,"x","gather"),s=I(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:r};return E.runKernel(qa,i,a)}var _s=T({gather_:dQ});function hQ(n,t){let e=I(n,"a","greater","string_or_numeric"),r=I(t,"b","greater","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel($u,o)}var $t=T({greater_:hQ});function mQ(n,t){let e=I(n,"a","greaterEqual","string_or_numeric"),r=I(t,"b","greaterEqual","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(bi,o)}var sr=T({greaterEqual_:mQ});function gQ(n){let e={input:I(n,"input","imag")};return E.runKernel(af,e)}var Rl=T({imag_:gQ});function yQ(n){let e={x:I(n,"x","isFinite")};return E.runKernel(vi,e)}var Wx=T({isFinite_:yQ});function xQ(n){let e={x:I(n,"x","isInf")};return E.runKernel(wi,e)}var jx=T({isInf_:xQ});function bQ(n){let e={x:I(n,"x","isNaN")};return E.runKernel(Ci,e)}var Hx=T({isNaN_:bQ});function vQ(n,t=.2){let r={x:I(n,"x","leakyRelu")},o={alpha:t};return E.runKernel(Ka,r,o)}var _l=T({leakyRelu_:vQ});function wQ(n,t){let e=I(n,"a","less","string_or_numeric"),r=I(t,"b","less","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Pu,o)}var Qi=T({less_:wQ});function CQ(n,t){let e=I(n,"a","lessEqual","string_or_numeric"),r=I(t,"b","lessEqual","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Lu,o)}var Mr=T({lessEqual_:CQ});function nO(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");let r={start:n,stop:t,num:e};return E.runKernel(lf,{},r)}function IQ(n,t=5,e=1,r=1,o=.5){let s=I(n,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(ei(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=O(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:e,alpha:r,beta:o},c=E.runKernel(Xa,l,u);return a?O(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var qx=T({localResponseNormalization_:IQ});function SQ(n){let e={x:I(n,"x","log","float32")};return E.runKernel(Ii,e)}var wn=T({log_:SQ});function TQ(n){let e={x:I(n,"x","log1p")};return E.runKernel(Si,e)}var Ol=T({log1p_:TQ});function $T(n,t){D(Op(n),()=>"The f passed in variableGrads(f) must be a function"),D(t==null||Array.isArray(t)&&t.every(u=>u instanceof qi),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let u in E.registeredVariables)t.push(E.registeredVariables[u])}let r=e?t.filter(u=>!u.trainable):null,o=t.length;t=t.filter(u=>u.trainable),D(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=E.gradients(n,t,null,s);D(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function vr(n){return E.customGrad(n)}function NQ(n){let e={x:I(n,"x","neg")};return E.runKernel(nl,e)}var Fe=T({neg_:NQ});function EQ(n){let e={x:I(n,"x","softplus")};return E.runKernel(zi,e)}var Ko=T({softplus_:EQ});function DQ(n){let t=I(n,"x","logSigmoid");return vr(r=>({value:Fe(Ko(Fe(r))),gradFunc:i=>R(i,Xn(Fe(r)))}))(t)}var Kx=T({logSigmoid_:DQ});function kQ(n,t){let e=I(n,"a","sub"),r=I(t,"b","sub");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(Gi,o)}var te=T({sub_:kQ});function AQ(n,t=-1){let e=I(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return vr((o,s)=>{let a=vn(o,t,!0),l=te(o,a),u=te(Y(l,"float32"),wn(ie(Ht(l),t,!0)));return s([u]),{value:u,gradFunc:(p,f)=>{let[d]=f,h=!0,g=Ht(d);return te(p,R(ie(p,t,h),g))}}})(e)}var id=T({logSoftmax_:AQ});function RQ(n,t=null,e=!1){let r=I(n,"x","logSumExp"),o=an(t,r.shape),s=vn(r,o,!0),i=te(r,s),a=Ht(i),l=ie(a,o),u=wn(l),c=j(O(s,u.shape),u);if(e){let p=bo(c.shape,o);return O(c,p)}return c}var Ml=T({logSumExp_:RQ});function _Q(n,t){let e=I(n,"a","logicalAnd","bool"),r=I(t,"b","logicalAnd","bool");De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Bu,o)}var Bn=T({logicalAnd_:_Q});function OQ(n){let e={x:I(n,"x","logicalNot","bool")};return E.runKernel(zu,e)}var Fl=T({logicalNot_:OQ});function MQ(n,t){let e=I(n,"a","logicalOr","bool"),r=I(t,"b","logicalOr","bool");De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Vu,o)}var ad=T({logicalOr_:MQ});function FQ(n,t){let e=I(n,"a","logicalXor","bool"),r=I(t,"b","logicalXor","bool");return De(e.shape,r.shape),Bn(ad(n,t),Fl(Bn(n,t)))}var Xx=T({logicalXor_:FQ});var Yx=2147483648;function $Q(n,t,e="left"){let r=I(n,"sortedSequence","searchSorted"),o=I(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=O(r,[-1,s]),l=O(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if($e(l.shape)>=Yx)throw new Error(`values tensor size must less than ${Yx}`);if(a.shape[1]>=Yx)throw new Error(`trailing dim_size must less than ${Yx} for int32 output type, was ${a.shape[1]}`);let u={sortedSequence:a,values:l},c={side:e};return E.runKernel(Nf,u,c)}var Sm=T({searchSorted_:$Q});function rO(n,t){return Sm(n,t,"left")}function PQ(n,t,e,r,o){let s=I(n,"x","maxPool"),i=1,a=s,l=!1;s.rank===3&&(l=!0,a=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),D(An(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),bt("maxPool",r,o);let u={x:a},c={filterSize:t,strides:e,pad:r,dimRoundingMode:o},p=E.runKernel(Za,u,c);return l?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var $l=T({maxPool_:PQ});function LQ(n,t=[1,1,1],e,r,o,s="NDHWC"){let i=I(n,"x","maxPool3d"),a=i,l=!1;i.rank===4&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),bt("maxPool3d",r,o);let u={x:a},c={filterSize:t,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=E.runKernel(Qa,u,c);return l?O(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Zx=T({maxPool3d_:LQ});function BQ(n,t,e,r,o=!1){let i={x:I(n,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:r,includeBatchInIndex:o},l=E.runKernel(ff,i,a);return{result:l[0],indexes:l[1]}}var oO=T({maxPoolWithArgmax_:BQ});function zQ(n,t){let e=I(n,"a","maximum"),r=I(t,"b","maximum");[e,r]=Le(e,r),e.dtype==="bool"&&(e=Y(e,"int32"),r=Y(r,"int32")),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Ti,o)}var wr=T({maximum_:zQ});function VQ(n,t=null,e=!1){let o={x:I(n,"x","mean")},s={axis:t,keepDims:e};return E.runKernel(Ja,o,s)}var wt=T({mean_:VQ});function nt(n,t="float32"){if(Mt(n),t==="complex64"){let r=nt(n,"float32"),o=nt(n,"float32");return xr(r,o)}let e=Fp($e(n),t);return E.makeTensor(e,n,t)}function Pt(n,t="float32"){if(Mt(n),t==="complex64"){let r=Pt(n,"float32"),o=nt(n,"float32");return xr(r,o)}let e=um($e(n),t);return E.makeTensor(e,n,t)}function sO(n,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=I(n,"x","meshgrid",n instanceof Ke?n.dtype:"float32");if(t===void 0)return[r];let o=I(t,"y","meshgrid",t instanceof Ke?t.dtype:"float32"),s=$e(r.shape),i=$e(o.shape);return e==="xy"?(r=O(r,[1,-1]),o=O(o,[-1,1]),[Oe(Pt([i,1],r.dtype),r),Oe(o,Pt([1,s],o.dtype))]):(r=O(r,[-1,1]),o=O(o,[1,-1]),[Oe(r,Pt([1,i],r.dtype)),Oe(Pt([s,1],o.dtype),o)])}function UQ(n,t){let e=I(n,"a","minimum"),r=I(t,"b","minimum");[e,r]=Le(e,r),e.dtype==="bool"&&(e=Y(e,"int32"),r=Y(r,"int32")),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Ni,o)}var to=T({minimum_:UQ});function GQ(n,t,e){D(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let r=I(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<r.rank;a++)D(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(t[a][0]>=0&&t[a][0]<=r.shape[a]-o&&t[a][1]>=0&&t[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:e},i={x:r};return E.runKernel(tl,i,s)}var Qx=T({mirrorPad_:GQ});function WQ(n,t){let e=I(n,"a","mod"),r=I(t,"b","mod");[e,r]=Le(e,r);let o={a:e,b:r};return E.runKernel(Ei,o)}var Jx=T({mod_:WQ});function jQ(n,t=null,e=!1){n=I(n,"x","moments");let r=an(t,n.shape),o=wt(n,r,e),s=o.shape;e||(s=bo(o.shape,r));let i=_e(te(Y(n,"float32"),O(o,s))),a=wt(i,r,e);return{mean:o,variance:a}}var lc=T({moments_:jQ});function HQ(n,t,e,r){let o=I(t,"data","multiRNNCell"),s=Ju(e,"c","multiRNNCell"),i=Ju(r,"h","multiRNNCell"),a=o,l=[];for(let p=0;p<n.length;p++){let f=n[p](a,s[p],i[p]);l.push(f[0]),l.push(f[1]),a=f[1]}let u=[],c=[];for(let p=0;p<l.length;p+=2)u.push(l[p]),c.push(l[p+1]);return[u,c]}var iO=T({multiRNNCell_:HQ});function qQ(n,t,e,r=!1){let o=I(n,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let l={logits:i===1?O(o,[1,-1]):o},u={numSamples:t,seed:e,normalized:r},c=E.runKernel(df,l,u);return i===1?O(c,[c.size]):c}var aO=T({multinomial_:qQ});function KQ(n,t){let e=I(n,"a","notEqual","string_or_numeric"),r=I(t,"b","notEqual","string_or_numeric");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r};return E.runKernel(Uu,o)}var Xo=T({notEqual_:KQ});function XQ(n,t,e=1,r=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:I(n,"indices","oneHot","int32")},a={dtype:o,depth:t,onValue:e,offValue:r};return E.runKernel(ol,i,a)}var uc=T({oneHot_:XQ});function YQ(n){let e={x:I(n,"x","onesLike")};return E.runKernel(rl,e)}var hn=T({onesLike_:YQ});function ZQ(n,t){let e=I(n,"v1","outerProduct"),r=I(t,"v2","outerProduct");D(e.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);let o=O(e,[-1,1]),s=O(r,[1,-1]);return Oe(o,s)}var lO=T({outerProduct_:ZQ});function QQ(n,t,e=0){let r=I(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:r};return E.runKernel(il,s,o)}var ir=T({pad_:QQ});function JQ(n,t,e=0){return D(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ir(n,[t],e)}var uO=T({pad1d_:JQ});function eJ(n,t,e=0){return D(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ir(n,t,e)}var cO=T({pad2d_:eJ});function tJ(n,t,e=0){return D(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ir(n,t,e)}var pO=T({pad3d_:tJ});function nJ(n,t,e=0){return D(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ir(n,t,e)}var fO=T({pad4d_:nJ});function rJ(n,t,e){let r=I(n,"x","spaceToBatchND");D(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),D(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),D(r.shape.reduce((i,a,l)=>l>0&&l<=t.length?i&&(a+e[l-1][0]+e[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:r},s={blockShape:t,paddings:e};return E.runKernel(gl,o,s)}var Pl=T({spaceToBatchND_:rJ});function oJ(n,t,e,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=I(n,"x","maxPool"),l=a,u=!1;a.rank===3&&(u=!0,l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(An(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=AT(l.shape,t,s,o,r),p=[c.dilationHeight,c.dilationWidth],f;r==="same"?f=iJ([c.filterHeight,c.filterWidth],p):f=[[0,0],[0,0]];let d=p[0]===1&&p[1]===1,[h,g]=sJ([c.inHeight,c.inWidth],p,f),m=d?r:"valid",y=d?l:Pl(l,p,h),v=(e==="avg"?()=>El(y,t,s,m,i):()=>$l(y,t,s,m,i))(),w=d?v:Dl(v,p,g);return u?O(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function sJ(n,t,e){let r=e.map(c=>c[0]),o=e.map(c=>c[1]),s=n.concat(r,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),l=t.map((c,p)=>[r[p],a[p]]),u=t.map((c,p)=>[0,i[p]]);return[l,u]}function iJ(n,t){let r=n.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var eb=T({pool_:oJ});function aJ(n,t){let e=I(n,"x","prelu"),r=I(t,"alpha","prelu"),o={x:e,alpha:r};return E.runKernel(al,o)}var Ll=T({prelu_:aJ});function lJ(n,t=null,e=!1){let r=I(n,"x","prod");r.dtype==="bool"&&(r=Y(r,"int32"));let o={x:r},s={axis:t,keepDims:e};return E.runKernel(ll,o,s)}var tb=T({prod_:lJ});function uJ(n,t,e,r){let o=n.map((c,p)=>I(c,`tensors${p}`,"raggedGather","int32")),s=I(t,"paramsDenseValues","raggedGather"),i=I(e,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},u=E.runKernel(yf,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var dO=T({raggedGather_:uJ});function cJ(n,t,e){let r=I(n,"starts","raggedRange"),o=I(t,"limits","raggedRange",r.dtype),s=I(e,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=E.runKernel(xf,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var hO=T({raggedRange_:cJ});function pJ(n,t,e,r,o){let s=I(n,"shape","raggedTensorToTensor","int32"),i=I(t,"values","raggedTensorToTensor"),a=I(e,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((p,f)=>I(p,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:s,values:i,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:o};return E.runKernel(bf,u,c)}var mO=T({raggedTensorToTensor_:pJ});function fJ(n,t,e){Mt(n);let r=$e(n),o=null;if(e==null||e==="float32")o=new Float32Array(r);else if(e==="int32")o=new Int32Array(r);else if(e==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<r;s++)o[s]=t();return E.makeTensor(o,n,e)}var gO=T({rand_:fJ});var sb=gh(Tm());var pc=class{constructor(t,e,r,o,s){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=sb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},rb=class{constructor(t,e,r,o){this.alpha=t,this.beta=1/e,this.dtype=r;let s=o||Math.random();this.randu=sb.alea(s.toString()),this.randn=new pc(0,1,r,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,r=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},ob=class{constructor(t=0,e=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=sb.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function bJ(n,t,e=1,r="float32",o){if(Mt(n),e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new rb(t,e,r,o),i=de(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var OO=T({randomGamma_:bJ});function vJ(n,t=0,e=1,r,o){if(Mt(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new pc(t,e,r,!1,o),i=de(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var fc=T({randomNormal_:vJ});function wJ(n,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return fc(n,0,1,t,e)}var MO=T({randomStandardNormal_:wJ});function CJ(n,t=0,e=1,r="float32",o){Mt(n);let s=de(n,r),i=new ob(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Fr=T({randomUniform_:CJ});function IJ(n,t,e,r){return Fr(n,t,e,"int32",r)}var FO=T({randomUniformInt_:IJ});function Os(n,t,e=1,r="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:n,stop:t,step:e,dtype:r};return E.runKernel(vf,{},o)}function SJ(n){let e={input:I(n,"input","real")};return E.runKernel(wf,e)}var Ji=T({real_:SJ});function TJ(n){let e={x:I(n,"x","reciprocal")};return E.runKernel(Ai,e)}var ib=T({reciprocal_:TJ});function NJ(n){let e={x:I(n,"x","relu")};return E.runKernel(Ri,e)}var _n=T({relu_:NJ});function EJ(n){let e={x:I(n,"x","relu6")};return E.runKernel(_i,e)}var ld=T({relu6_:EJ});function DJ(n,t){let r={x:I(n,"x","reverse")},o={dims:t};return E.runKernel(fl,r,o)}var un=T({reverse_:DJ});function kJ(n){let t=I(n,"x","reverse");return D(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),un(t,0)}var $O=T({reverse1d_:kJ});function AJ(n,t){let e=I(n,"x","reverse");return D(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),un(e,t)}var PO=T({reverse2d_:AJ});function RJ(n,t){let e=I(n,"x","reverse");return D(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),un(e,t)}var LO=T({reverse3d_:RJ});function _J(n,t){let e=I(n,"x","reverse");return D(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),un(e,t)}var BO=T({reverse4d_:_J});function OJ(n){let e={x:I(n,"x","round")};return E.runKernel(Oi,e)}var ud=T({round_:OJ});function MJ(n){let e={x:I(n,"x","rsqrt","float32")};return E.runKernel(Mi,e)}var cd=T({rsqrt_:MJ});function FJ(n){let e={x:I(n,"x","selu")};return E.runKernel(Fi,e)}var pd=T({selu_:FJ});function $J(n,t,e,r,o,s=[1,1],i="NHWC"){let a=I(n,"x","separableConv2d"),l=I(t,"depthwiseFilter","separableConv2d"),u=I(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),D(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let f=l.shape[2],d=l.shape[3];D(u.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${u.shape[2]}.`);let h=ks(c,l,r,o,i,s),m=br(h,u,1,"valid",i);return p?O(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var fd=T({separableConv2d_:$J});function PJ(n,t){return z(this,null,function*(){let e=I(n,"x","setdiff1d"),r=I(t,"y","setdiff1d");D(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),D(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),D(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=yield e.data(),s=yield r.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let l=new tt([a],e.dtype),u=new tt([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(l.values[p]=o[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]})}var zO=PJ;function LJ(n){let e={x:I(n,"x","sign")};return E.runKernel(Li,e)}var ab=T({sign_:LJ});function BJ(n){let e={x:I(n,"x","sin","float32")};return E.runKernel($i,e)}var dd=T({sin_:BJ});function zJ(n){let e={x:I(n,"x","sinh")};return E.runKernel(Pi,e)}var hd=T({sinh_:zJ});function VJ(n,t,e){let r=I(n,"x","slice1d");return D(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ne(r,[t],[e])}var md=T({slice1d_:VJ});function UJ(n,t,e){let r=I(n,"x","slice2d");return D(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ne(r,t,e)}var Nm=T({slice2d_:UJ});function GJ(n,t,e){let r=I(n,"x","slice3d");return D(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ne(r,t,e)}var gd=T({slice3d_:GJ});function WJ(n,t,e){let r=I(n,"x","slice4d");return D(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ne(r,t,e)}var dc=T({slice4d_:WJ});function jJ(n,t=-1){let e=I(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let r={logits:e},o={dim:t};return E.runKernel(xl,r,o)}var Bl=T({softmax_:jJ});function HJ(n){D(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);let t={input:n};return E.runKernel(tf,t)}var zl=T({fft_:HJ});function qJ(n){D(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);let t={input:n};return E.runKernel(sf,t)}var ea=T({ifft_:qJ});function KJ(n){let t=n.shape[n.shape.length-1],e=n.size/t,r;if(t<=2){let o=O(n,[e,t]);r=ea(o)}else{let o=[e,2*(t-1)],s=O(Ji(n),[e,t]),i=O(Rl(n),[e,t]),a=un(Ne(s,[0,1],[e,t-2]),1),l=R(un(Ne(i,[0,1],[e,t-2]),1),se(-1)),u=Je([s,a],1),c=Je([i,l],1),p=O(xr(u,c),[o[0],o[1]]);r=ea(p)}if(r=Ji(r),n.rank===3&&n.shape[0]!==0){let o=r,s=n.shape[0];r=O(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var yd=T({irfft_:KJ});function XJ(n,t,e=0){let o={x:I(n,"x","split")},s={numOrSizeSplits:t,axis:e};return E.runKernel(yl,o,s)}var cn=T({split_:XJ});function YJ(n,t){D(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1],r=n.size/e,o;if(t!=null&&t<e){let h=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=t,o=Ne(n,h,g),e=t}else if(t!=null&&t>e){let h=n.shape.map(g=>g);h[n.shape.length-1]=t-e,o=Je([n,nt(h)],n.shape.length-1),e=t}else o=n;let s=ye(o),i=O(xr(o,s),[r,e]),a=zl(i),l=Math.floor(e/2)+1,u=Ji(a),c=Rl(a),p=cn(u,[l,e-l],u.shape.length-1),f=cn(c,[l,e-l],c.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=l,O(xr(p[0],f[0]),d)}var Vl=T({rfft_:YJ});function ZJ(n,t){let e=I(n,"a","squaredDifference"),r=I(t,"b","squaredDifference");[e,r]=Le(e,r),De(e.shape,r.shape);let o={a:e,b:r},s={};return E.runKernel(Ui,o,s)}var xd=T({squaredDifference_:ZJ});function QJ(n,t){let e=I(n,"x","squeeze","string_or_numeric");return O(e,ZS(e.shape,t).newShape)}var $r=T({squeeze_:QJ});function JJ(n,t=0){let e=Ju(n,"tensors","stack","string_or_numeric");D(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&D(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let r=e,o={axis:t};return E.runKernel(sl,r,o)}var Lt=T({stack_:JJ});function eee(n,t=0){let r={x:I(n,"x","step")},o={alpha:t};return E.runKernel(Hi,r,o)}var vo=T({step_:eee});function tee(n,t,e,r,o=0,s=0,i=0,a=0,l=0){let c={x:I(n,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return E.runKernel(Of,c,p)}var lb=T({stridedSlice_:tee});function nee(n){let e={x:I(n,"x","tan","float32")};return E.runKernel(Wi,e)}var ub=T({tan_:nee});function Bt(n,t){Qr(n);let e=yr(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return rr(n,null,e,t)}function ta(n,t,e){if(Qr(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=yr(n,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return rr(n,t,r,e)}function VO(n,t,e){if(Qr(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=yr(n,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return rr(n,t,r,e)}function UO(n,t,e){if(Qr(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=yr(n,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return rr(n,t,r,e)}function GO(n,t,e){if(Qr(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=yr(n,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return rr(n,t,r,e)}function WO(n,t,e){if(Qr(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=yr(n,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,rr(n,t,r,e)}function jO(n,t,e){let r=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(n.length<r+(e.rank-o))throw new Error(s+` Output shape length < ${r+(e.rank-o)}`);if(e.rank!==o+n.length-r)throw new Error(s+` update.rank != ${o+n.length-r}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==n[i+r])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${n[i+o]})`)}function Em(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}jO(e,t,n)}function ree(n,t,e){let r=t.shape.length,o=r>1?t.shape[r-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,l=$e(t.shape)/a,u=[...xs(e.slice(0,o)),1],c=$e(e);return{sliceRank:o,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function oee(n,t,e){let r=I(n,"tensor","tensorScatterupdate"),o=I(t,"indices","tensorScatterupdate","int32"),s=I(e,"updates","tensorScatterupdate");if(Em(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return E.runKernel(Tf,i,a)}var qO=T({tensorScatterUpdate_:oee});function see(n,t=1,e=!0){let r=I(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:r},i={k:t,sorted:e},[a,l]=E.runKernel(Pf,s,i);return{values:a,indices:l}}var cb=T({topk_:see});function iee(n,t=0,e=1,r,o){if(Mt(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new pc(t,e,r,!0,o),i=de(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var bd=T({truncatedNormal_:iee});function aee(n,t=0){let e=I(n,"x","unique","string_or_numeric");D(e.rank>0,()=>"The input tensor must be at least 1D");let r={x:e},o={axis:t},[s,i]=E.runKernel(Bf,r,o);return{values:s,indices:i}}var pb=T({unique_:aee});function lee(n,t,e){let r=I(n,"x","unsortedSegmentSum"),o=I(t,"segmentIds","unsortedSegmentSum","int32");D(ei(e),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:e};return E.runKernel(vl,s,i)}var vd=T({unsortedSegmentSum_:lee});function uee(n,t=0){let e=I(n,"x","unstack","string_or_numeric");D(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let r={value:e},o={axis:t};return E.runKernel(bl,r,o)}var pn=T({unstack_:uee});function KO(n,t){return Sm(n,t,"right")}function fb(n,t=!0,e,r){return E.makeVariable(n,t,e,r)}function db(n,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let r=de(n,"int32"),o=de([e.length,n.length],"int32");for(let s=0;s<e.length;s++){let i=r.indexToLoc(e[s]),a=s*n.length;o.values.set(i,a)}return o.toTensor()}function cee(n){return z(this,null,function*(){let t=I(n,"condition","whereAsync","bool"),e=yield t.data(),r=db(t.shape,e);return n!==t&&t.dispose(),r})}var hb=cee;function pee(n,t,e){return z(this,null,function*(){let r=I(n,"tensor","boolMask"),o=I(t,"mask","boolMask","bool"),s=e??0,i=o.rank,a=r.shape;D(i>0,()=>"mask cannot be scalar"),Kt(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=s;g<s+i;g++)l*=a[g];let u=a.slice(0,s).concat([l],a.slice(s+i)),c=O(r,u),p=O(o,[-1]),f=yield hb(p),d=$r(f,[1]),h=_s(c,d,s);return n!==r&&r.dispose(),t!==o&&o.dispose(),d.dispose(),c.dispose(),p.dispose(),f.dispose(),h})}var fee=pee;function dee(n,t,e){let r=I(n,"x","transpose");if(t==null&&(t=r.shape.map((i,a)=>a).reverse()),D(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{D(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:t};return r.dtype==="complex64"?B(()=>{let i=Ji(r),a=Rl(r);return i=E.runKernel(Cs,{x:i},s),a=E.runKernel(Cs,{x:a},s),e&&(a=Fe(a)),xr(i,a)}):E.runKernel(Cs,o,s)}var Me=T({transpose_:dee});function hee(n,t,e,r,o=!0){let s=I(n,"v","movingAverage"),i=I(t,"x","movingAverage"),a=I(e,"decay","movingAverage");h2(s,i),D(Ar(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=se(1),u=te(l,a),c=R(te(i,s),u);if(o){D(r!=null,()=>"When using zeroDebias: true, step is required.");let p=I(r,"step","movingAverage");c=ne(c,te(l,Ln(a,p)))}return j(s,c)}var mee=T({movingAverage_:hee});function gee(n,t,e){Mt(e);let r=I(n,"indices","scatterND","int32"),o=I(t,"updates","scatterND");Em(o,r,e);let s={indices:r,updates:o},i={shape:e};return E.runKernel(Sf,s,i)}var yee=T({scatterND_:gee});function XO(n,t,e,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);let o=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function bee(n,t,e,r=0){Mt(e);let o=I(n,"sparseIndices","sparseToDense","int32"),s=I(t,"sparseValues","sparseToDense","string_or_numeric"),i=I(r,"defaultValue","sparseToDense",s.dtype);XO(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},l={outputShape:e};return E.runKernel(Rf,a,l)}var vee=T({sparseToDense_:bee});function wee(n,t){let e=I(t,"indices","gatherND","int32"),o={params:I(n,"x","gatherND","string_or_numeric"),indices:e};return E.runKernel(of,o)}var Cee=T({gatherND_:wee});function YO(n,t){if(t==null)return n.shape.slice();if(Ar(n.shape,t))return t;if(n.shape.length===t.length){let e=[];for(let r=0;r<n.shape.length;r++)t[r]==null&&n.shape[r]!=null?e.push(n.shape[r]):e.push(t[r]);return e}return t}function Iee(n,t,e,r){let o=I(n,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Ke?o.clone():o;let s=YO(o,e),i=1-t,a=ne(Rs(j(Fr(s,0,1,"float32",r),i)),i);return R(o,a)}var GT=T({dropout_:Iee});function WT(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Dm(n,t,e){let r=1-n%2,o=new Float32Array(n);for(let s=0;s<n;++s){let i=2*Math.PI*s/(n+r-1);o[s]=t-e*Math.cos(i)}return Bt(o,"float32")}function See(n,t,e=1){return z(this,null,function*(){let r=I(n,"predictions","inTopK"),o=I(t,"targets","inTopK");D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),Kt(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];D(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=yield r.data(),a=yield o.data(),[l,u]=[i.length/s,s],c=QS("bool",l);for(let p=0;p<l;p++){let f=p*u,d=i.subarray(f,f+u),h=[];for(let g=0;g<d.length;g++)h.push({value:d[g],index:g});h.sort((g,m)=>m.value-g.value),c[p]=0;for(let g=0;g<e;g++)if(h[g].index===a[p]){c[p]=1;break}}return n!==r&&r.dispose(),t!==o&&o.dispose(),ln(c,o.shape,"bool")})}var Tee=See;var Ul={};yt(Ul,{conv2d:()=>ZO,depthwiseConv2d:()=>QO,matMul:()=>JO});function Nee(n,t,e,r,o,s="NHWC",i){let a=n;n.rank===3&&(a=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),D(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let u=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?l.shape[3]:l.shape[1];D(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),D(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),bt("conv2dDerFilter",o,i);let p={x:a,dy:l},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return E.runKernel(Gp,p,f)}var wd=T({conv2DBackpropFilter_:Nee});function hc(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return R(n,vo(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function mc(n,t){let e=t,r=ht(n.shape,t.shape);return r.length>0&&(e=ie(e,r)),O(e,n.shape)}function gc(n,t,e,r){if(t==="linear")return n;if(t==="relu")return _n(n);if(t==="elu")return As(n);if(t==="relu6")return ld(n);if(t==="prelu")return Ll(n,e);if(t==="leakyrelu")return _l(n,r);if(t==="sigmoid")return Xn(n);throw new Error(`Unknown fused activation ${t}.`)}var yc=(n,t)=>!(n>0)||t==="linear";function Eee({x:n,filter:t,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",yc(E.state.gradientDepth,l)===!1){D(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=br(n,t,e,r,o,s,i);return a!=null&&(k=j(k,a)),gc(k,l,u,c)}let p=I(n,"x","conv2d","float32"),f=I(t,"filter","conv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=O(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),bt("fused conv2d",r,i);let g=o==="NHWC"?d.shape[3]:d.shape[1];D(f.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${f.shape[2]}.`),D(An(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m=sc(d.shape,f.shape,e,s,r,i),y;a!=null&&(y=I(a,"bias","fused conv2d"),[y]=Le(y,p),o==="NHWC"?De(m.outShape,y.shape):(D(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),D(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let x;if(u!=null){let k=u.shape;if(D(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)D(k[0]===1||k[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${m.outChannels}).`);else if(k.length===3)try{De(k,m.outShape)}catch{let _=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(_)}x=I(u,"prelu weights","fused conv2d")}let v=(k,A)=>{D(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[_,F,$,V]=A,U=hc(k,$,l);D(Jr(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let W=td(F.shape,U,_,e,r),G=wd(F,U,_.shape,e,r),H=[W,G];if(V!=null){let K=mc(V,U);H.push(K)}return H},w={x:d,filter:f,bias:y,preluActivationWeights:x},S={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?vr((A,_,F)=>{let $=E.runKernel(ju,w,S);return F([_,A,$]),h&&($=O($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:v}})(d,f):vr((A,_,F,$)=>{let V=E.runKernel(ju,w,S);return $([_,A,V,F]),h&&(V=O(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:v}})(d,f,y)}var ZO=T({fusedConv2d_:Eee});function Dee(n,t,e,r,o,s=[1,1],i){let a=n;n.rank===3&&(a=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;l.rank===3&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:a,dy:l},c={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return E.runKernel(Yp,u,c)}var mb=T({depthwiseConv2dNativeBackpropFilter_:Dee});function kee(n,t,e,r,o,s=[1,1],i){let a=t,l=!1;t.rank===3&&(l=!0,a=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:a,filter:e},c={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:n},p=E.runKernel(Zp,u,c);return l?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var gb=T({depthwiseConv2dNativeBackpropInput_:kee});function Aee({x:n,filter:t,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(yc(E.state.gradientDepth,l)===!1){let S=ks(n,t,e,r,o,s,i);return a!=null&&(S=j(S,a)),gc(S,l,u,c)}let p=I(n,"x","depthwiseConv2d","float32"),f=I(t,"filter","depthwiseConv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=O(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),D(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),D(An(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),bt("fused depthwiseConv2d",r,i);let g=sc(d.shape,f.shape,e,s,r,i,!0),m;a!=null&&(m=I(a,"bias","fused conv2d"),[m]=Le(m,p),De(g.outShape,m.shape));let y;u!=null&&(y=I(u,"prelu weights","fused depthwiseConv2d"));let x=(S,k)=>{D(Jr(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[A,_,F,$]=k,V=hc(S,F,l),U=gb(_.shape,V,A,e,r,s,i),W=mb(_,V,A.shape,e,r,s,i);if($!=null){let G=mc(m,V);return[U,W,G]}return[U,W]},v={x:d,filter:f,bias:m,preluActivationWeights:y},w={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return a==null?vr((k,A,_)=>{let F=E.runKernel(Hu,v,w);return _([A,k,F]),h&&(F=O(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(d,f):vr((k,A,_,F)=>{let $=E.runKernel(Hu,v,w);return F([A,k,$,_]),h&&($=O($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(d,f,m)}var QO=T({fusedDepthwiseConv2d_:Aee});function Ree({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(yc(E.state.gradientDepth,s)===!1){let V=Oe(n,t,e,r);return o!=null&&(V=j(V,o)),gc(V,s,i,a)}let l=I(n,"a","fused matMul"),u=I(t,"b","fused matMul");[l,u]=Le(l,u);let c=e?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=e?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=$e(h),y=$e(g);D(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);let v=De(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,d]),w=e?O(l,[m,c,f]):O(l,[m,f,c]),S=r?O(u,[y,d,p]):O(u,[y,p,d]),k;o!=null&&(k=I(o,"bias","fused matMul"),[k]=Le(k,l),De(v,k.shape));let A;i!=null&&(A=I(i,"prelu weights","fused matMul"));let _=(V,U)=>{let[W,G,H,K]=U,Q=hc(O(V,H.shape),H,s),X,J;if(!e&&!r?(X=Oe(Q,G,!1,!0),J=Oe(W,Q,!0,!1)):!e&&r?(X=Oe(Q,G,!1,!1),J=Oe(Q,W,!0,!1)):e&&!r?(X=Oe(G,Q,!1,!0),J=Oe(W,Q,!1,!1)):(X=Oe(G,Q,!0,!0),J=Oe(Q,W,!0,!0)),o!=null){let re=mc(K,Q);return[X,J,re]}else return[X,J]},F={a:w,b:S,bias:k,preluActivationWeights:A},$={transposeA:e,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?vr((U,W,G)=>{let H=E.runKernel(Wu,F,$);return G([U,W,H]),{value:O(H,v),gradFunc:_}})(w,S):vr((U,W,G,H)=>{let K=E.runKernel(Wu,F,$);return H([U,W,K,G]),{value:O(K,v),gradFunc:_}})(w,S,k)}var JO=T({fusedMatMul_:Ree});function _ee(n){return Dm(n,.54,.46)}var eM=T({hammingWindow_:_ee});function Oee(n){return Dm(n,.5,.5)}var yb=T({hannWindow_:Oee});function Mee(n,t,e,r=!1,o=0){let s=0,i=[];for(;s+t<=n.size;)i.push(Ne(n,s,t)),s+=e;if(r)for(;s<n.size;){let a=s+t-n.size,l=Je([Ne(n,s,t-a),xo([a],o)]);i.push(l),s+=e}return i.length===0?ta([],[0,t]):O(Je(i),[i.length,t])}var xb=T({frame_:Mee});function Fee(n,t,e,r,o=yb){r==null&&(r=WT(t));let s=xb(n,t,e),i=R(s,o(t));return Vl(i,r)}var tM=T({stft_:Fee});function $ee(n,t,e,r,o="bilinear",s=0){let i=I(n,"image","cropAndResize"),a=I(t,"boxes","cropAndResize","float32"),l=I(e,"boxInd","cropAndResize","int32"),u=a.shape[0];D(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),D(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),D(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:l},p={method:o,extrapolationValue:s,cropSize:r};return E.runKernel(qp,c,p)}var nM=T({cropAndResize_:$ee});function Pee(n){let t=I(n,"image","flipLeftRight","float32");D(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return E.runKernel(rf,e,{})}var rM=T({flipLeftRight_:Pee});function Lee(n){let t=I(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,Rn(t,o)}var oM=T({grayscaleToRGB_:Lee});function Bee(n){let t=I(n,"image","RGBToGrayscale"),e=t.rank-1,r=t.shape[e];D(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),D(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=t.dtype,s=Y(t,"float32"),i=Bt([.2989,.587,.114]),a;switch(t.rank){case 2:a=Al("ij,j->i",s,i);break;case 3:a=Al("ijk,k->ij",s,i);break;case 4:a=Al("ijkl,l->ijk",s,i);break;case 5:a=Al("ijklm,m->ijkl",s,i);break;case 6:a=Al("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Xt(a,-1),Y(a,o)}var sM=T({rgbToGrayscale_:Bee});function zee(n,t,e=0,r=.5){let o=I(n,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:r};return E.runKernel(zf,s,i)}var iM=T({rotateWithOffset_:zee});function wo(n,t,e,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=n.shape[0];return e=Math.min(e,i),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),D(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),D(t.rank===1,()=>"scores must be a 1D tensor"),D(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}function Vee(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY){let s=I(n,"boxes","nonMaxSuppression","float32"),i=I(t,"scores","nonMaxSuppression","float32"),a=wo(s,i,e,r,o);e=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let l={maxOutputSize:e,iouThreshold:r,scoreThreshold:o};return E.runKernel(hf,{boxes:s,scores:i},l)}var aM=T({nonMaxSuppression_:Vee});function lM(n,t,e){let r=Uee(n,t,e),o=r<0?-(r+1):r;n.splice(o,0,t)}function Uee(n,t,e){return Wee(n,t,e||Gee)}function Gee(n,t){return n>t?1:n<t?-1:0}function Wee(n,t,e){let r=0,o=n.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=e(t,n[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}function bb(n,t,e,r,o){return jT(n,t,e,r,o,0)}function vb(n,t,e,r,o,s){return jT(n,t,e,r,o,0,!1,s,!0)}function wb(n,t,e,r,o,s){return jT(n,t,e,r,o,s,!0)}function jT(n,t,e,r,o,s,i=!1,a=!1,l=!1){let u=[];for(let m=0;m<t.length;m++)t[m]>o&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(uM);let c=s>0?-.5/s:0,p=[],f=[];for(;p.length<e&&u.length>0;){let m=u.pop(),{score:y,boxIndex:x,suppressBeginIndex:v}=m;if(y<o)break;let w=!1;for(let S=p.length-1;S>=v;--S){let k=jee(n,x,p[S]);if(k>=r){w=!0;break}if(m.score=m.score*Hee(r,c,k),m.score<=o)break}m.suppressBeginIndex=p.length,w||(m.score===y?(p.push(x),f.push(m.score)):m.score>o&&lM(u,m,uM))}let d=p.length,h=e-d;a&&h>0&&(p.push(...new Array(h).fill(0)),f.push(...new Array(h).fill(0)));let g={selectedIndices:p};return i&&(g.selectedScores=f),l&&(g.validOutputs=d),g}function jee(n,t,e){let r=n.subarray(t*4,t*4+4),o=n.subarray(e*4,e*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),d=(a-s)*(l-i),h=(p-u)*(f-c);if(d<=0||h<=0)return 0;let g=Math.max(s,u),m=Math.max(i,c),y=Math.min(a,p),x=Math.min(l,f),v=Math.max(y-g,0)*Math.max(x-m,0);return v/(d+h-v)}function Hee(n,t,e){let r=Math.exp(t*e*e);return e<=n?r:0}function uM(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function qee(s,i,a){return z(this,arguments,function*(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY){let l=I(n,"boxes","nonMaxSuppressionAsync"),u=I(t,"scores","nonMaxSuppressionAsync"),c=wo(l,u,e,r,o);e=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold;let p=yield Promise.all([l.data(),u.data()]),f=p[0],d=p[1],{selectedIndices:h}=bb(f,d,e,r,o);return l!==n&&l.dispose(),u!==t&&u.dispose(),Bt(h,"int32")})}var cM=qee;function Kee(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=wo(i,a,e,r,o,s);e=l.maxOutputSize,r=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=E.runKernel(gf,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var pM=T({nonMaxSuppressionWithScore_:Kee});function Xee(i,a,l){return z(this,arguments,function*(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let u=I(n,"boxes","nonMaxSuppressionAsync"),c=I(t,"scores","nonMaxSuppressionAsync"),p=wo(u,c,e,r,o,s);e=p.maxOutputSize,r=p.iouThreshold,o=p.scoreThreshold,s=p.softNmsSigma;let f=yield Promise.all([u.data(),c.data()]),d=f[0],h=f[1],{selectedIndices:g,selectedScores:m}=wb(d,h,e,r,o,s);return u!==n&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:Bt(g,"int32"),selectedScores:Bt(m)}})}var fM=Xee;function Yee(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=wo(i,a,e,r,o,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,f={boxes:i,scores:a},d={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},h=E.runKernel(mf,f,d);return{selectedIndices:h[0],validOutputs:h[1]}}var dM=T({nonMaxSuppressionPadded_:Yee});function Zee(i,a,l){return z(this,arguments,function*(n,t,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let u=I(n,"boxes","nonMaxSuppressionAsync"),c=I(t,"scores","nonMaxSuppressionAsync"),p=wo(u,c,e,r,o,null),f=p.maxOutputSize,d=p.iouThreshold,h=p.scoreThreshold,[g,m]=yield Promise.all([u.data(),c.data()]),{selectedIndices:y,validOutputs:x}=vb(g,m,f,d,h,s);return u!==n&&u.dispose(),c!==t&&c.dispose(),{selectedIndices:Bt(y,"int32"),validOutputs:se(x,"int32")}})}var hM=Zee;function Qee(n,t,e=!1,r=!1){let o=I(n,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(r===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:t},u=E.runKernel(pl,a,l);return i?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Cb=T({resizeBilinear_:Qee});function Jee(n,t,e=!1,r=!1){let o=I(n,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(r===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:t},u=E.runKernel(cl,a,l);return i?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Ib=T({resizeNearestNeighbor_:Jee});function ete(n,t="binary",e=!1,r=.5){let o=I(n,"image","threshold"),s=.2989,i=.587,a=.114,l=o.shape[0]*o.shape[1],u=R(Bt([r]),255),c,p,f,d;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,f]=cn(o,[1,1,1],-1);let m=R(c,s),y=R(p,i),x=R(f,a);d=j(j(m,y),x)}else d=n;if(t==="otsu"){let m=kx(Y(ud(d),"int32"),ln([]),256);u=tte(m,l)}let h=e?Mr(d,u):$t(d,u);return Y(R(h,255),"int32")}function tte(n,t){let e=Bt([-1]),r=Bt([0]),o=Bt([0]),s,i,a,l,u,c;for(let p=0;p<n.size-1;p++){s=Ne(n,0,p+1),i=Ne(n,p+1),u=ne(ie(s),t),c=ne(ie(i),t);let f=ie(R(s,Os(0,s.size)));a=ne(f,ie(s));let d=xo(i.shape,s.size),h=j(Os(0,i.size),d),g=R(i,h);l=ne(ie(g),ie(i));let m=te(a,l),y=te(a,l),x=R(u,c);o=R(R(x,m),y);let v=$t(o,r);r=vt(v,o,r),e=vt(v,Bt([p]),e)}return e}var mM=T({threshold_:ete});function nte(n,t,e="nearest",r="constant",o=0,s){let i=I(n,"image","transform","float32"),a=I(t,"transforms","transform","float32");D(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:a},u={interpolation:e,fillMode:r,fillValue:o,outputShape:s};return E.runKernel(Lf,l,u)}var gM=T({transform_:nte});function rte(n,t,e){let r=I(n,"a","bandPart");D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,l;typeof t=="number"?(D(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),a=I(t<0?s:t,"numLower","bandPart")):(D(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=vt(Qi(t,0),s,to(t,s))),typeof e=="number"?(D(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),D(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=I(e<0?i:e,"numUpper","bandPart")):(D(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=vt(Qi(e,0),i,to(e,i)));let u=O(Os(0,s,1,"int32"),[-1,1]),c=Os(0,i,1,"int32"),p=te(u,c),f=Bn(Mr(p,a),sr(p,Fe(l))),d=nt([s,i],r.dtype);return O(Lt(pn(O(r,[-1,s,i])).map(h=>vt(f,h,d))),o)}var yM=T({bandPart_:rte});function ote(n){let t;if(Array.isArray(n)){t=!1,D(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=n[0].shape[0];for(let s=1;s<n.length;++s)D(n[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${o})`)}else t=!0,n=cn(n,n.shape[0],0).map(o=>$r(o,[0]));D(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);let e=[],r=n;for(let o=0;o<n.length;++o)e.push(E.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=R(ie(R(e[i],s)),e[i]);s=te(s,a)}return ne(s,Zi(s,"euclidean"))}));return t?Lt(e,0):e}var xM=T({gramSchmidt_:ote});function ste(n,t=!1){if(D(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return bM(n,t);{let e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=pn(O(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),o=[],s=[];r.forEach(l=>{let[u,c]=bM(l,t);o.push(u),s.push(c)});let i=O(Lt(o,0),n.shape),a=O(Lt(s,0),n.shape);return[i,a]}}function bM(n,t=!1){return E.tidy(()=>{D(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);let e=n.shape[0],r=n.shape[1],o=ac(e),s=or(n),i=ta([[1]],[1,1]),a=or(i),l=e>=r?r:e;for(let u=0;u<l;++u){let c=s,p=a,f=o;[a,s,o]=E.tidy(()=>{let d=Ne(s,[u,u],[e-u,1]),h=Zi(d),g=Ne(s,[u,u],[1,1]),m=vt($t(g,0),ta([[-1]]),ta([[1]])),y=te(g,R(m,h)),x=ne(d,y);x.shape[0]===1?a=or(i):a=Je([i,Ne(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let v=Fe(ne(Oe(m,y),h)),w=Ne(s,[u,0],[e-u,r]),S=R(v,a),k=Me(a);if(u===0)s=te(w,Oe(S,Oe(k,w)));else{let F=te(w,Oe(S,Oe(k,w)));s=Je([Ne(s,[0,0],[u,r]),F],0)}let A=Me(S),_=Ne(o,[0,u],[e,o.shape[1]-u]);if(u===0)o=te(_,Oe(Oe(_,a),A));else{let F=te(_,Oe(Oe(_,a),A));o=Je([Ne(o,[0,0],[e,u]),F],1)}return[a,s,o]}),Se([c,p,f])}return!t&&e>r&&(o=Ne(o,[0,0],[e,r]),s=Ne(s,[0,0],[r,r])),[o,s]})}var vM=T({qr_:ste});var rn=function(n){return n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",n}(rn||{});function ite(n,t,e=rn.SUM_BY_NONZERO_WEIGHTS){let r=I(n,"losses","computeWeightedLoss"),o=null;t!=null&&(o=I(t,"weights","computeWeightedLoss"));let s=o==null?r:R(r,o);if(e===rn.NONE)return s;if(e===rn.SUM)return ie(s);if(e===rn.MEAN){if(o==null)return wt(s);{let i=r.size/o.size,a=ne(ie(s),ie(o));return i>1?ne(a,se(i)):a}}if(e===rn.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ne(ie(s),se(r.size));{let i=R(o,Pt(r.shape)),a=Y(ie(Xo(i,se(0))),"float32");return ne(ie(s),a)}}throw Error(`Unknown reduction: ${e}`)}var zn=T({computeWeightedLoss_:ite});function ate(n,t,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(n,"labels","absoluteDifference"),s=I(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=I(e,"weights","absoluteDifference")),Kt(o.shape,s.shape,"Error in absoluteDifference: ");let a=Tt(te(o,s));return zn(a,i,r)}var wM=T({absoluteDifference_:ate});function lte(n,t,e,r,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"labels","cosineDistance"),i=I(t,"predictions","cosineDistance"),a=null;r!=null&&(a=I(r,"weights","cosineDistance")),Kt(s.shape,i.shape,"Error in cosineDistance: ");let l=se(1),u=te(l,ie(R(s,i),e,!0));return zn(u,a,o)}var CM=T({cosineDistance_:lte});function ute(n,t,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(n,"labels","hingeLoss"),s=I(t,"predictions","hingeLoss"),i=null;e!=null&&(i=I(e,"weights","hingeLoss")),Kt(o.shape,s.shape,"Error in hingeLoss: ");let a=se(1);o=te(R(se(2),o),a);let l=_n(te(a,R(o,s)));return zn(l,i,r)}var IM=T({hingeLoss_:ute});function cte(n,t,e,r=1,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"labels","huberLoss"),i=I(t,"predictions","huberLoss"),a=null;e!=null&&(a=I(e,"weights","huberLoss")),Kt(s.shape,i.shape,"Error in huberLoss: ");let l=se(r),u=Tt(te(i,s)),c=to(u,l),p=te(u,c),f=j(R(se(.5),_e(c)),R(l,p));return zn(f,a,o)}var SM=T({huberLoss_:cte});function pte(n,t,e,r=1e-7,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"labels","logLoss"),i=I(t,"predictions","logLoss"),a=null;e!=null&&(a=I(e,"weights","logLoss")),Kt(s.shape,i.shape,"Error in logLoss: ");let l=se(1),u=se(r),c=Fe(R(s,wn(j(i,u)))),p=R(te(l,s),wn(j(te(l,i),u))),f=te(c,p);return zn(f,a,o)}var TM=T({logLoss_:pte});function fte(n,t,e,r=rn.SUM_BY_NONZERO_WEIGHTS){let o=I(n,"labels","meanSquaredError"),s=I(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=I(e,"weights","meanSquaredError")),Kt(o.shape,s.shape,"Error in meanSquaredError: ");let a=xd(o,s);return zn(a,i,r)}var NM=T({meanSquaredError_:fte});function dte(n,t){let e=I(n,"labels","sigmoidCrossEntropyWithLogits"),r=I(t,"logits","sigmoidCrossEntropyWithLogits");Kt(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=_n(r),s=R(r,e),i=Ol(Ht(Fe(Tt(r))));return j(te(o,s),i)}function hte(n,t,e,r=0,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"multiClassLabels","sigmoidCrossEntropy"),i=I(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=I(e,"weights","sigmoidCrossEntropy")),Kt(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=se(r),c=se(1),p=se(.5);s=j(R(s,te(c,u)),R(p,u))}let l=dte(s,i);return zn(l,a,o)}var EM=T({sigmoidCrossEntropy_:hte});function mte(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return vr((o,s,i)=>{let l=Ml(s,[e],!0),u=te(Y(s,"float32"),l);i([o,u]);let c=Fe(R(u,o));return{value:ie(c,[e]),gradFunc:(d,h)=>{let[g,m]=h,y=bo(d.shape,[e]);return[R(O(d,y),te(Y(g,"float32"),Ht(m))),R(O(d,y),te(Ht(m),Y(g,"float32")))]}}})(n,t)}function gte(n,t,e,r=0,o=rn.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"onehotLabels","softmaxCrossEntropy"),i=I(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=I(e,"weights","softmaxCrossEntropy")),Kt(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=se(r),c=se(1),p=se(s.shape[1]);s=j(R(s,te(c,u)),ne(u,p))}let l=mte(s,i);return zn(l,a,o)}var DM=T({softmaxCrossEntropy_:gte});function yte(n,t,e,r){let o=I(n,"indices","sparseFillEmptyRows","int32"),s=I(t,"values","sparseFillEmptyRows"),i=I(e,"denseShape","sparseFillEmptyRows","int32"),a=I(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let l={indices:o,values:s,denseShape:i,defaultValue:a},u=E.runKernel(Ef,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var kM=T({sparseFillEmptyRows_:yte});function xte(n,t,e){let r=I(n,"inputIndices","sparseReshape","int32"),o=I(t,"inputShape","sparseReshape","int32"),s=I(e,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=E.runKernel(Df,i);return{outputIndices:a[0],outputShape:a[1]}}var AM=T({sparseReshape_:xte});function bte(n,t,e){let r=I(n,"data","sparseSegmentMean"),o=I(t,"indices","sparseSegmentMean","int32"),s=I(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return E.runKernel(kf,i)}var RM=T({sparseSegmentMean_:bte});function vte(n,t,e){let r=I(n,"data","sparseSegmentSum"),o=I(t,"indices","sparseSegmentSum","int32"),s=I(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return E.runKernel(Af,i)}var _M=T({sparseSegmentSum_:vte});function wte(n,t,e,r,o,s,i,a){let l=I(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=I(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:l,dataSplits:u},f=E.runKernel(Mf,p,c);return{nGrams:f[0],nGramsSplits:f[1]}}var OM=T({stringNGrams_:wte});function Cte(n,t,e=!0){let r=I(n,"input","stringSplit","string"),o=I(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:r,delimiter:o},a=E.runKernel(Ff,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var MM=T({stringSplit_:Cte});function Ite(n,t){let e=I(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return E.runKernel($f,o,r)}var FM=T({stringToHashBucketFast_:Ite});function Ste(n,t,e,r=!0){let o=I(n,"input","staticRegexReplace","string"),s={pattern:t,rewrite:e,replaceGlobal:r};return E.runKernel(Gu,{x:o},s)}var $M=T({staticRegexReplace_:Ste});var Tte={fft:zl,ifft:ea,rfft:Vl,irfft:yd},Nte={hammingWindow:eM,hannWindow:yb,frame:xb,stft:tM},Cr={flipLeftRight:rM,grayscaleToRGB:oM,resizeNearestNeighbor:Ib,resizeBilinear:Cb,rgbToGrayscale:sM,rotateWithOffset:iM,cropAndResize:nM,nonMaxSuppression:aM,nonMaxSuppressionAsync:cM,nonMaxSuppressionWithScore:pM,nonMaxSuppressionWithScoreAsync:fM,nonMaxSuppressionPadded:dM,nonMaxSuppressionPaddedAsync:hM,threshold:mM,transform:gM},HT={bandPart:yM,gramSchmidt:xM,qr:vM},Ete={absoluteDifference:wM,computeWeightedLoss:zn,cosineDistance:CM,hingeLoss:IM,huberLoss:SM,logLoss:TM,meanSquaredError:NM,sigmoidCrossEntropy:EM,softmaxCrossEntropy:DM},Dte={sparseFillEmptyRows:kM,sparseReshape:AM,sparseSegmentMean:RM,sparseSegmentSum:_M},kte={stringNGrams:OM,stringSplit:MM,stringToHashBucketFast:FM,staticRegexReplace:$M};var q={};yt(q,{Serializable:()=>km,SerializationMap:()=>Sb,getRegisteredName:()=>Rte,registerClass:()=>KT});var Ate=new Map,qT=new Map,km=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Sb=class n{constructor(){this.classNameMap={}}static getMap(){return n.instance==null&&(n.instance=new n),n.instance}static register(t){n.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function KT(n,t,e){D(n.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),D(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);let r=e,o=t+">"+r;return Sb.register(n),Ate.set(o,n),qT.set(n,o),n}function Rte(n){return qT.has(n)?qT.get(n):n.className}var Vn=class extends km{minimize(t,e=!1,r){let{value:o,grads:s}=this.computeGradients(t,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Se(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return $T(t,e)}dispose(){this.iterations_!=null&&Se(this.iterations_)}saveIterations(){return z(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:se(this.iterations_,"int32")}})}getWeights(){return z(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(t){return z(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(t){return z(this,null,function*(){return this.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})}};Object.defineProperty(Vn,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});var Cd=class extends Vn{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,o)=>{let s=E.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:B(()=>ye(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:B(()=>ye(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[r];if(a==null)return;let l=this.accumulatedGrads[o].variable,u=this.accumulatedUpdates[o].variable;B(()=>{let c=j(R(l,this.rho),R(_e(a),1-this.rho)),p=R(ne(pt(j(u,this.epsilon)),pt(j(l,this.epsilon))),a),f=j(R(u,this.rho),R(_e(p),1-this.rho));l.assign(c),u.assign(f);let d=j(R(p,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Se(this.accumulatedGrads.map(t=>t.variable)),Se(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){return z(this,null,function*(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return z(this,null,function*(){t=yield this.extractIterations(t);let e=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};var Id=class extends Vn{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,o)=>{let s=E.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:B(()=>xo(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;B(()=>{let l=j(a,_e(i));a.assign(l);let u=j(R(ne(i,pt(j(l,E.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Se(this.accumulatedGrads.map(t=>t.variable))}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return z(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};var Sd=class extends Vn{static get className(){return"Adam"}constructor(t,e,r,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=se(e).variable(),this.accBeta2=se(r).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);B(()=>{let r=te(1,this.accBeta1),o=te(1,this.accBeta2);e.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:B(()=>ye(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:B(()=>ye(a).variable(l))});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,f=j(R(c,this.beta1),R(u,1-this.beta1)),d=j(R(p,this.beta2),R(_e(u),1-this.beta2)),h=ne(f,r),g=ne(d,o);c.assign(f),p.assign(d);let m=j(R(ne(h,j(pt(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(R(this.accBeta1,this.beta1)),this.accBeta2.assign(R(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Se(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Se(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){return z(this,null,function*(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return z(this,null,function*(){t=yield this.extractIterations(t),B(()=>{this.accBeta1.assign(Ln(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ln(this.beta2,this.iterations_+1))});let e=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};var Td=class extends Vn{static get className(){return"Adamax"}constructor(t,e,r,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=se(0).variable(),this.accBeta1=se(e).variable()}),o==null&&(this.epsilon=E.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);B(()=>{let r=te(1,this.accBeta1),o=ne(-this.learningRate,j(R(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=E.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:ye(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:ye(a).variable(l)});let u=Array.isArray(t)?t[i].tensor:t[s];if(u==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,f=j(R(c,this.beta1),R(u,1-this.beta1)),d=R(p,this.beta2),h=Tt(u),g=wr(d,h);c.assign(f),p.assign(g);let m=j(R(ne(o,r),ne(f,j(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(j(this.iteration,1)),this.accBeta1.assign(R(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Se(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Se(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return z(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(t){return z(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};var Gl=class extends Vn{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,o)=>{let s=Array.isArray(t)?t[o].tensor:t[r];if(s==null)return;let i=E.registeredVariables[r];B(()=>{let a=j(R(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Et(se(-t))}dispose(){this.c.dispose()}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()]})}setWeights(t){return z(this,null,function*(){if(t=yield this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};var Nd=class extends Gl{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=se(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,o)=>{let s=E.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:B(()=>ye(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[r];a!=null&&B(()=>{let l,u=j(R(this.m,i),a);this.useNesterov?l=j(R(this.c,j(a,R(u,this.m))),s):l=j(R(this.c,u),s),i.assign(u),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Se(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){return z(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})}setWeights(t){return z(this,null,function*(){t=yield this.extractIterations(t);let e=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};var Ed=class extends Vn{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=E.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,o)=>{let s=E.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:B(()=>ye(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:B(()=>ye(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:B(()=>ye(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[r];if(a==null)return;let l=this.accumulatedMeanSquares[o].variable,u=this.accumulatedMoments[o].variable;B(()=>{let c=j(R(l,this.decay),R(_e(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,f=j(R(p,this.decay),R(a,1-this.decay)),d=ne(R(a,this.learningRate),pt(te(c,j(_e(f),this.epsilon)))),h=j(R(u,this.momentum),d);l.assign(c),p.assign(f),u.assign(h);let g=te(s,h);s.assign(g)}else{let p=j(R(l,this.decay),R(_e(a),1-this.decay)),f=j(R(u,this.momentum),ne(R(a,this.learningRate),pt(j(p,this.epsilon))));l.assign(p),u.assign(f);let d=te(s,f);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Se(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Se(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Se(this.accumulatedMoments.map(t=>t.variable))}getWeights(){return z(this,null,function*(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(t){return z(this,null,function*(){t=yield this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};var _te=[Cd,Id,Sd,Td,Nd,Ed,Gl];function PM(){for(let n of _te)KT(n)}var Yo={};yt(Yo,{CompositeArrayBuffer:()=>Pn,browserFiles:()=>BM,browserHTTPRequest:()=>WM,concatenateArrayBuffers:()=>T2,copyModel:()=>B2,decodeWeights:()=>cx,decodeWeightsStream:()=>px,encodeWeights:()=>w2,fromMemory:()=>jM,fromMemorySync:()=>tN,getLoadHandlers:()=>k2,getModelArtifactsForJSON:()=>qf,getModelArtifactsForJSONSync:()=>CT,getModelArtifactsInfoForJSON:()=>Ss,getSaveHandlers:()=>D2,getWeightSpecs:()=>bm,http:()=>Nb,isHTTPScheme:()=>Tb,listModels:()=>P2,loadWeights:()=>VM,moveModel:()=>z2,registerLoadRouter:()=>E2,registerSaveRouter:()=>N2,removeModel:()=>L2,weightsLoaderFactory:()=>JT,withSaveHandler:()=>HM,withSaveHandlerSync:()=>qM});var Ote="model",Mte=".json",Fte=".weights.bin";function LM(n){return new Promise(t=>setTimeout(t)).then(n)}var XT=(()=>{class n{constructor(e){if(!L().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Ote),this.modelJsonFileName=e+Mte,this.weightDataFileName=e+Fte}save(e){return z(this,null,function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=Pn.join(e.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=fx(e,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=a,yield LM(()=>l.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=o,yield LM(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ss(e)}}})}}return n.URL_SCHEME="downloads://",n})();var YT=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){return z(this,null,function*(){return new Promise((t,e)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let l=qf(s,u=>this.loadWeights(u));t(l)},r.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})})}loadWeights(t){let e=[],r=[];for(let i of t)e.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,i])}loadWeightsFile(t,e){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],r=this.weightsFiles.map(s=>wT(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=wT(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},$te=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(XT.URL_SCHEME)?Pte(n.slice(XT.URL_SCHEME.length)):null;xn.registerSaveRouter($te);function Pte(n="model"){return new XT(n)}function BM(n){return new YT(n)}function ZT(n,t,e,r){i(n),e=e??0,r=r??1,a(e,r);let o=0,s=l=>(l.then(u=>{let c=e+ ++o/n.length*(r-e);return t(c),u}),l);function i(l){D(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),D(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(s))}function QT(n,t){return z(this,null,function*(){t==null&&(t={});let e=t.fetchFunc==null?L().platform.fetch:t.fetchFunc,r=n.map(p=>e(p,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?yield Promise.all(r):yield ZT(r,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?yield Promise.all(a):yield ZT(a,t.onProgress,.5,1)})}function zM(n,t){var e;let r=t.fetchFunc==null?L().platform.fetch:t.fetchFunc,o=0,s;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:i=>z(this,null,function*(){for(var a;o<n.length;){s||(s=(yield r(n[o],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=yield s.read();if(l){o++,s=void 0,(a=t.onProgress)===null||a===void 0||a.call(t,o/n.length);continue}i.enqueue(u);return}i.close()})})}function VM(n,t="",e,r){return z(this,null,function*(){return JT(i=>QT(i,{requestInit:r}))(n,t,e)})}function JT(n){return(t,e="",r)=>z(this,null,function*(){let o=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(t.forEach((d,h)=>{let g=0;d.weights.forEach(m=>{let y="quantization"in m?m.quantization.dtype:m.dtype,x=Ki[y]*$e(m.shape),v=()=>{o[h]=!0,s[h]==null&&(s[h]=[]),s[h].push({manifestEntry:m,groupOffset:g,sizeBytes:x})};r!=null?r.forEach((w,S)=>{w===m.name&&(v(),i[S]=!0)}):v(),a.push(m.name),g+=x})}),!i.every(d=>d)){let d=r.filter((h,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let l=o.reduce((d,h,g)=>(h&&d.push(g),d),[]),u=[];l.forEach(d=>{t[d].paths.forEach(h=>{let g=e+(e.endsWith("/")?"":"/")+h;u.push(g)})});let c=yield n(u),p={},f=0;return l.forEach(d=>{let h=t[d].paths.length,g=new Pn(c.slice(f,f+h));s[d].forEach(y=>{let x=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),v=cx(x,[y.manifestEntry]);for(let w in v)p[w]=v[w]}),f+=h}),p})}var Lte="application/octet-stream",Bte="application/json",UM=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?(D(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=L().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(e){return z(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=fx(e,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:Bte}),"model.json"),e.weightData!=null){let a=Pn.join(e.weightData);r.body.append("model.weights.bin",new Blob([a],{type:Lte}),"model.weights.bin")}let i=yield this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:Ss(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})}loadModelJSON(){return z(this,null,function*(){let e=yield this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r})}load(){return z(this,null,function*(){if(this.loadOptions.streamWeights)return this.loadStream();let e=yield this.loadModelJSON();return qf(e,r=>this.loadWeights(r))})}loadStream(){return z(this,null,function*(){let e=yield this.loadModelJSON(),r=yield this.getWeightUrls(e.weightsManifest),o=bm(e.weightsManifest),s=()=>zM(r,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:o,getWeightStream:s})})}getWeightUrls(e){return z(this,null,function*(){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=zte(r),i=this.weightPathPrefix||o,a=[],l=[];for(let u of e)for(let c of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(c)):a.push(i+c+s);return this.weightUrlConverter&&a.push(...yield Promise.all(l)),a})}loadWeights(e){return z(this,null,function*(){let r=yield this.getWeightUrls(e),o=bm(e),s=yield QT(r,this.loadOptions);return[o,s]})}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function zte(n){let t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),r=n.substring(0,t),o=e>t?n.substring(e):"";return[r+"/",o]}function Tb(n){return n.match(UM.URL_SCHEME_REGEX)!=null}var GM=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(r=>Tb(r)):e=Tb(n),e)return Nb(n,t)}return null};xn.registerSaveRouter(GM);xn.registerLoadRouter(GM);function Nb(n,t){return new UM(n,t)}function WM(n,t){return Nb(n,t)}var Am=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},Eb=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},eN=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function jM(n,t,e,r){let o=arguments;return new eN(tN(...o))}function tN(n,t,e,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Am(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Am({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Am({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function HM(n){return new Eb(n)}function qM(n){return new Eb(n)}function Vte(n,t){let e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if($e(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=n.shape,l=o.slice();l.pop();let u=1;for(let p=s;p<e;++p)u*=a[p],l.push(a[p]);let c=[...xs(n.shape).map(p=>p/u),1].slice(0,s);return[l,i,u,c]}var Cn={};yt(Cn,{assertParamsValid:()=>Gte,computeFlatOffset:()=>Kte,computeOutShape:()=>jte,getNormalizedAxes:()=>Hte,isSliceContinous:()=>qte,maskToAxes:()=>Wte,parseSliceParams:()=>rN,sliceInfo:()=>Xte,startForAxis:()=>tF,startIndicesWithElidedDims:()=>QM,stopForAxis:()=>nF,stopIndicesWithElidedDims:()=>JM,stridesForAxis:()=>eF,stridesWithElidedDims:()=>XM});var nN=-2,Ute=-1;function Gte(n,t,e){let r=n.shape.length;D(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),D(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)D(t[o]+e[o]<=n.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${n.shape[o]})`)}function Wte(n){let t=[],e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function jte(n,t,e){let r=[];for(let o=0;o<n.length;o++)r[o]=Math.ceil((t[o]-n[o])/e[o]);return r}function XM(n,t,e,r){let o=[...n];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function YM(n,t,e){return e<=n?e:e-(t-1)}function ZM(n,t){let e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Hte(n,t,e,r,o,s,i,a,l){let u=n.length,c=new Array(u),p=new Array(u),f=new Array(u);if(t.length&&e>0){let d=t[0],h=e+1;c=QM(i,d,h,r,n),p=JM(a,d,h,o,n),f=XM(s,d,h,n)}else for(let d=0;d<u;d++)c[d]=tF(i,r,s,n,d,l),p[d]=nF(a,o,s,n,d,l),f[d]=eF(s,d,l);return{begin:c,end:p,strides:f}}function QM(n,t,e,r,o){let s=[...o],i=ZM(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let l=YM(t,e,a),u=r[l];n&1<<l&&(u=0),s[a]=u}return s}function JM(n,t,e,r,o){let s=[...o],i=ZM(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let l=YM(t,e,a),u=r[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[a]=u}for(let a=0;a<s.length;a++){let l=o[a];s[a]<0&&(s[a]+=l),s[a]=Ap(0,s[a],o[a])}return s}function eF(n,t,e){let r=n[t];return(e&1<<t||r==null)&&(r=1),r}function tF(n,t,e,r,o,s){let i=t[o],a=e[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),i=Ap(0,i,l-1),i}function nF(n,t,e,r,o,s){let i=t[o],a=e[o]||1;(n&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),a>0?i=Ap(0,i,l):i=Ap(-1,i,l-1),i}function qte(n,t,e){let r=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){r=o;break}for(let o=r+1;o<e.length;o++)if(t[o]>0||e[o]!==n[o])return!1;return!0}function Kte(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function rN(n,t,e){let r,o=n.shape.length;typeof t=="number"?r=[t,...new Array(o-1).fill(0)]:t.length<o?r=t.concat(new Array(o-t.length).fill(0)):r=t.slice(),r.forEach(i=>{D(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(D(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,s]}function Xte(n,t,e,r,o,s,i,a,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let v=0;v<p.dims;v++)c&&1<<v&a&&p.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Yte(p,f);let d=!0,h=!0,g=!0,m=[],y=[];for(let v=0;v<n.length;++v){if(f.strides[v]===0)throw Error(`strides[${v}] must be non-zero`);let w=!!(f.shrinkAxisMask&1<<v),S=n[v];if(S===-1){m.push(w?1:-1);continue}let k=[f.beginMask&1<<v,f.endMask&1<<v],A=[f.strides[v]>0?0:-1,f.strides[v]>0?S:S-1];if(w&&f.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&f.strides[v]===1;let _=!!(f.beginMask&1<<v&&f.endMask&1<<v);if(f.beginValid&&f.endValid){if(w){let U=f.begin[v]<0?S+f.begin[v]:f.begin[v];if(f.begin[v]=U,f.end[v]=f.begin[v]+1,U<0||U>=S)throw Error(`slice index ${f.begin[v]} of dimension ${v} out of bounds.`)}else f.begin[v]=KM(f.begin[v],0,f.strides[v],S,k,A),f.end[v]=KM(f.end[v],1,f.strides[v],S,k,A);let V=f.strides[v]===1&&f.begin[v]===0&&f.end[v]===S;d=d&&V,h=h&&(v===0&&f.strides[v]===1||V)}else d=d&&f.strides[v]===1&&_,h=h&&(v===0&&f.strides[v]===1||_);let F,$=!1;if(f.beginValid&&f.endValid?(F=f.end[v]-f.begin[v],$=!0):w?(F=1,$=!0):_&&S>=0&&(f.strides[v]<0?F=-S:F=S,$=!0),$){let V;F===0||F<0!=f.strides[v]<0?V=0:V=Math.trunc(F/f.strides[v])+(F%f.strides[v]!==0?1:0),m.push(V)}else m.push(-1)}for(let v=0;v<f.finalShapeGatherIndices.length;++v){let w=f.finalShapeGatherIndices[v];w>=0?y.push(m[w]):w===nN&&y.push(1)}return{finalShapeSparse:y.filter((v,w)=>f.finalShapeGatherIndices[w]!==nN),finalShape:y,isIdentity:d,sliceDim0:h,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function Yte(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){let o=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(nN),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[r]),n.end!=null&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Ute),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}function KM(n,t,e,r,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=n<0?r+n:n;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var Db=class{static sgd(t){return new Gl(t)}static momentum(t,e,r=!1){return new Nd(t,e,r)}static rmsprop(t,e=.9,r=0,o=null,s=!1){return new Ed(t,e,r,o,s)}static adam(t=.001,e=.9,r=.999,o=null){return new Sd(t,e,r,o)}static adadelta(t=.001,e=.95,r=null){return new Cd(t,e,r)}static adamax(t=.002,e=.9,r=.999,o=null,s=0){return new Td(t,e,r,o,s)}static adagrad(t,e=.1){return new Id(t,e)}};var xc=Db;var Zte=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function Rm(){return new Promise(n=>Zte(()=>n()))}var N={};yt(N,{ERF_A1:()=>fne,ERF_A2:()=>dne,ERF_A3:()=>hne,ERF_A4:()=>mne,ERF_A5:()=>gne,ERF_P:()=>pne,PARALLELIZE_THRESHOLD:()=>kb,RowPartitionType:()=>na,SELU_SCALE:()=>sN,SELU_SCALEALPHA:()=>oN,applyActivation:()=>gc,assertAndGetBroadcastShape:()=>De,assertAxesAreInnerMostDims:()=>ZZ,assertParamsConsistent:()=>Qte,assignToTypedArray:()=>Cne,axesAreInnerMostDims:()=>_T,calculateShapes:()=>ree,checkEinsumDimSizes:()=>Dne,checkPadOnDimRoundingMode:()=>bt,combineLocations:()=>eO,combineRaggedTensorToTensorShapes:()=>ene,complexWithEvenIndex:()=>bne,complexWithOddIndex:()=>vne,computeConv2DInfo:()=>sc,computeConv3DInfo:()=>j2,computeDefaultPad:()=>RT,computeDilation2DInfo:()=>YY,computeOptimalWindowSize:()=>one,computeOutAndReduceShapes:()=>OT,computeOutShape:()=>Jte,computePool2DInfo:()=>AT,computePool3DInfo:()=>ZY,convertConv2DDataFormat:()=>H2,decodeEinsumEquation:()=>Nne,eitherStridesOrDilationsAreOne:()=>An,expandShapeToKeepDim:()=>bo,exponent:()=>Sne,exponents:()=>Ine,fromStringArrayToUint8:()=>Xne,fromUint8ToStringArray:()=>Kne,getAxesPermutation:()=>MT,getBroadcastDims:()=>Q2,getComplexWithIndex:()=>wne,getEinsumComputePath:()=>kne,getEinsumPermutation:()=>Ene,getFusedBiasGradient:()=>mc,getFusedDyActivation:()=>hc,getImageCenter:()=>sne,getInnerMostAxes:()=>QZ,getPermuted:()=>ane,getRaggedRank:()=>nne,getReductionAxes:()=>ht,getReshaped:()=>ine,getReshapedPermuted:()=>lne,getRowPartitionTypesHelper:()=>tne,getSliceBeginCoords:()=>une,getSliceSize:()=>cne,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>One,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Mne,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Fne,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Lne,getSparseReshapeInputOutputMismatchErrorMessage:()=>zne,getSparseReshapeInputOutputMultipleErrorMessage:()=>Bne,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>$ne,getSparseReshapeNegativeOutputDimErrorMessage:()=>Pne,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Wne,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Vne,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Une,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Gne,getUndoAxesPermutation:()=>Im,isIdentityPermutation:()=>Ane,log:()=>VX,mergeRealAndImagArrays:()=>yne,prepareAndValidate:()=>Vte,prepareSplitSize:()=>_ne,segment_util:()=>aN,shouldFuse:()=>yc,slice_util:()=>Cn,splitRealAndImagArrays:()=>xne,stridesOrDilationsArePositive:()=>Ns,tupleValuesAreOne:()=>Jr,upcastType:()=>nn,validateDefaultValueShape:()=>rne,validateInput:()=>Em,validateUpdateShape:()=>jO,warn:()=>Is});function Qte(n,t){let e=n[0].length;n.forEach((o,s)=>{D(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),D(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let r=n[0];n.forEach((o,s)=>{for(let i=0;i<e;i++)D(i===t||o[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Jte(n,t){let e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var na=function(n){return n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",n}(na||{});function ene(n,t,e){let r=new Array;if(e==null&&t==null)return r;if(t==null)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(e==null)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let o=1;o<e.length;++o){let s=e[o],i=r[r.length-e.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+n}] = ${s} but shape[${o+n}] = ${a}`)}else r[i]=s}return r}function tne(n){let t={FIRST_DIM_SIZE:na.FIRST_DIM_SIZE,VALUE_ROWIDS:na.VALUE_ROWIDS,ROW_LENGTHS:na.ROW_LENGTHS,ROW_SPLITS:na.ROW_SPLITS,ROW_LIMITS:na.ROW_LIMITS,ROW_STARTS:na.ROW_STARTS},e=[];for(let r of n)if(r in t)e.push(t[r]);else break;return e}function nne(n){return n.length===0?0:n[0]===na.FIRST_DIM_SIZE?n.length-1:n.length}function rne(n,t){if(n==null||t==null)return;let e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(e,r-1);++o){let s=n[o],i=t[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-n.length}] = ${s} but ragged tensor input.flatValues.shape[${o-n.length}] = ${i}`)}}var kb=30;function one(n){return n<=kb?n:Mp(n,Math.floor(Math.sqrt(n)))}function sne(n,t,e){let r=e*(typeof n=="number"?n:n[0]),o=t*(typeof n=="number"?n:n[1]);return[r,o]}function ine(n,t,e,r=!0){let o=[];if(r)o=o.concat(t.slice(0)),o.push(n[0]/e),o=o.concat(n.slice(1));else{o=o.concat(n[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([n[i+1]/t[i],t[i]]);o=o.concat(n.slice(s+1))}return o}function ane(n,t,e=!0){let r=[];if(e){r.push(t);for(let o=t+1;o<n;++o)o<=2*t?(r.push(o),r.push(o-(t+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<n;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function lne(n,t,e,r=!0){let o=[];r?o.push(n[0]/e):o.push(n[0]*e);for(let s=1;s<n.length;++s)s<=t.length?r?o.push(t[s-1]*n[s]):o.push(n[s]/t[s-1]):o.push(n[s]);return o}function une(n,t){let e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function cne(n,t,e){let r=n.slice(0,1);for(let o=0;o<e;++o)r.push(n[o+1]-t[o][0]-t[o][1]);return r}var oN=1.7580993408473768,sN=1.0507009873554805;var pne=.3275911,fne=.254829592,dne=-.284496736,hne=1.421413741,mne=-1.453152027,gne=1.061405429;function yne(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);let e=new Float32Array(n.length*2);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function xne(n){let t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function bne(n){let t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let o=0;o<n.length;o+=4)e[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:e,imag:r}}function vne(n){let t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let o=2;o<n.length;o+=4)e[Math.floor(o/4)]=n[o],r[Math.floor(o/4)]=n[o+1];return{real:e,imag:r}}function wne(n,t){let e=n[t*2],r=n[t*2+1];return{real:e,imag:r}}function Cne(n,t,e,r){n[r*2]=t,n[r*2+1]=e}function Ine(n,t){let e=new Float32Array(n/2),r=new Float32Array(n/2);for(let o=0;o<Math.ceil(n/2);o++){let s=(t?2:-2)*Math.PI*(o/n);e[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:e,imag:r}}function Sne(n,t,e){let r=(e?2:-2)*Math.PI*(n/t),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var iN="->",Tne=/->/g,rF=",",oF="...";function Nne(n,t){n=n.replace(/\s/g,"");let e=(n.length-n.replace(Tne,"").length)/iN.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${iN}").`);let[r,o]=n.split(iN);D(r.indexOf(oF)===-1,()=>`The ellipsis notation ("${oF}") is not supported yet.`);let s=r.split(rF),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let f=0;f<o.length;++f){let d=o[f];if(!s.some(h=>h.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){let d=r[f];a.indexOf(d)===-1&&d!==rF&&a.push(d)}let l=new Array(s.length);for(let f=0;f<i;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<s[f].length;++d)l[f].push(a.indexOf(s[f][d]))}let u=a.length,c=o.length,p=[];for(let f=c;f<u;++f)p.push(f);return{allDims:a,summedDims:p,idDims:l}}function Ene(n,t){let e=new Array(n);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let r=[];for(let o=0;o<n;++o)e[o]===-1&&r.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:r}}function Dne(n,t,e){let r=new Array(n);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)r[t[o][i]]===void 0?r[t[o][i]]=s[i]:D(r[t[o][i]]===s[i],()=>`Expected dimension ${r[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function kne(n,t){let e=n,r=[],o=0;n.length===0&&e.push(-1),o=n.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],l=Rne(t,a);for(let u of l)s.indexOf(u)===-1&&(r[i].push(u),s.push(u))}return{path:e,steps:r}}function Ane(n){return n.every((t,e)=>t===e)}function Rne(n,t){let e=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(t)!==-1||t===-1)&&e.push(r);return e}function _ne(n,t,e=0){let r=[];if(typeof t=="number")D(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,l)=>l>0?a+l:a);t[s]=n.shape[e]-i}D(n.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function One(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Mne(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function Fne(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function $ne(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function Pne(n,t){return`size ${n} must be non-negative, not ${t}`}function Lne(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Bne(n,t){let e=$e(n),r=$e(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${t}`}function zne(n,t){let e=$e(n),r=$e(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${t}`}function Vne(){return"segment ids must be >= 0"}function Une(){return"segment ids are not increasing"}function Gne(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Wne(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}var aN={};yt(aN,{collectGatherOpShapeInfo:()=>qne,computeOutShape:()=>Hne,segOpComputeOptimalWindowSize:()=>jne});function jne(n,t){let e=!1,r;for(n<=kb?(r=n,e=!0):r=Mp(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=Mp(n,r+1);return r}function Hne(n,t,e){let r=[],o=n.length;for(let s=0;s<o;s++)s!==t?r.push(n[s]):r.push(e);return r}function qne(n,t,e,r){let o=t.shape.length,s=n.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let p=0;p<r;++p)if(n.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=n.shape[e],a=[],l=1,u=1,c=1;for(let p=0;p<r;++p)a.push(n.shape[p]),l*=n.shape[p];for(let p=r;p<e;p++)a.push(n.shape[p]),u*=n.shape[p];for(let p=r;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(n.shape[p]),c*=n.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function Kne(n){try{return n.map(t=>jf(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Xne(n){return n.map(t=>Wf(t))}var Un={};yt(Un,{nonMaxSuppressionV3Impl:()=>bb,nonMaxSuppressionV4Impl:()=>vb,nonMaxSuppressionV5Impl:()=>wb,whereImpl:()=>db});PM();var Ab={kernelName:ka,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,vo(Y(e,"float32"),-1))}}};var sF={kernelName:ti,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=_e(Y(e,"float32")),o=pt(te(se(1),r));return Fe(ne(n,o))}}}};var iF={kernelName:ni,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=pt(te(_e(Y(e,"float32")),1));return ne(n,r)}}}};var aF={kernelName:Go,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=n,l=ht(e.shape,o);return l.length>0&&(a=ie(a,l)),O(a,e.shape)},b:()=>{let a=n,l=ht(r.shape,o);return l.length>0&&(a=ie(a,l)),O(a,r.shape)}}}};var lF={kernelName:Aa,saveAllInputs:!0,gradFunc:(n,t)=>{let e={};return t.forEach((r,o)=>{e[o]=()=>n.clone()}),e}};var uF={kernelName:Ra,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ye(e)}}};var cF={kernelName:_a,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ye(e)}}};var pF={kernelName:ri,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,pt(te(se(1),_e(Y(e,"float32")))))}}};var fF={kernelName:oi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=pt(j(se(1),_e(Y(e,"float32"))));return ne(n,r)}}}};var dF={kernelName:ai,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=j(_e(e),_e(r)),l=R(n,ne(r,a)),u=ht(e.shape,o);return u.length>0&&(l=ie(l,u)),O(l,e.shape)},b:()=>{let a=j(_e(e),_e(r)),l=Fe(R(n,ne(e,a))),u=ht(r.shape,o);return u.length>0&&(l=ie(l,u)),O(l,r.shape)}}}};var hF={kernelName:si,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,j(_e(Y(e,"float32")),1))}}};var mF={kernelName:ii,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,te(se(1),_e(Y(e,"float32"))))}}};function Yne(n,t,e,r,o,s){let i=I(n,"dy","avgPool3dGrad"),a=I(t,"input","avgPool3dGrad"),l=i,u=a,c=!1;a.rank===4&&(c=!0,l=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),D(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),bt("avgPool3dGrad",o,s);let p={dy:l,input:u},f={filterSize:e,strides:r,pad:o,dimRoundingMode:s},d=E.runKernel(Bp,p,f);return c?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var gF=T({avgPool3dGrad_:Yne});var yF={kernelName:Ma,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>gF(n,r,o,s,i,a)}}};function Zne(n,t,e,r,o){let s=I(n,"dy","avgPoolGrad"),i=I(t,"input","avgPoolGrad");D(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,l=s,u=!1;i.rank===3&&(u=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=O(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),D(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:l,input:a},p={filterSize:e,strides:r,pad:o},f=E.runKernel(Lp,c,p);return u?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var xF=T({avgPoolGrad_:Zne});var bF={kernelName:Oa,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>xF(n,r,o,s,i)}}};var vF={kernelName:Fa,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{let[r,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>Oe(n,o,!1,!0),b:()=>Oe(r,n,!0,!1)}:!s&&i?{a:()=>Oe(n,o,!1,!1),b:()=>Oe(n,r,!0,!1)}:s&&!i?{a:()=>Oe(o,n,!1,!0),b:()=>Oe(r,n,!1,!1)}:{a:()=>Oe(o,n,!0,!0),b:()=>Oe(n,r,!0,!0)}}};var wF={kernelName:$a,gradFunc:(n,t,e)=>{let{blockShape:r,crops:o}=e;return{x:()=>Pl(n,r,o)}}};var CF={kernelName:F_,gradFunc:(n,t,e)=>{let r=e,o=r.inputShape,s=r.shape,i=Array.from(s);for(let l=o.length-1;l>=0;l--)if(o[l]===s[l])i[l]=1;else if(o[l]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>ie(n,a,!0)}}};var IF={kernelName:bs,gradFunc:n=>({x:()=>n.clone()})};var SF={kernelName:li,gradFunc:n=>({x:()=>ye(n)})};var TF={kernelName:ui,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>vt(Bn(sr(r,o),Mr(r,s)),n,ye(n))}}};var NF={kernelName:Pa,inputsToSave:["x"],gradFunc:Ab.gradFunc};var EF={kernelName:La,saveAllInputs:!0,gradFunc:(n,t,e)=>{let r=t.map(l=>l.shape),{axis:o}=e,s=an(o,t[0].shape)[0],i=r.map(l=>l[s]);return cn(n,i,s).map(l=>()=>l)}};var DF={kernelName:Ba,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[r,o]=t,{dilations:s,strides:i,pad:a,dataFormat:l}=e;return D(Jr(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>td(r.shape,n,o,i,a,l),filter:()=>wd(r,n,o.shape,i,a,l)}}};var kF={kernelName:za,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{let[r,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>br(n,o,s,i,a,1,l),filter:()=>wd(n,r,o.shape,s,i,a,l)}}};function Qne(n,t,e,r,o){let s=n;n.rank===4&&(s=O(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=t;i.rank===4&&(i=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),D(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),D(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),D(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},l={strides:r,pad:o,filterShape:e};return E.runKernel(Wp,a,l)}var AF=T({conv3DBackpropFilter_:Qne});var RF={kernelName:Va,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:r,strides:o,pad:s}=e;D(Jr(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,a]=t;return{x:()=>$x(i.shape,n,a,o,s),filter:()=>AF(i,n,a.shape,o,s)}}};var _F={kernelName:ci,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(Fe(dd(Y(e,"float32"))),n)}}};var OF={kernelName:pi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(hd(Y(e,"float32")),n)}}};var MF={kernelName:Ua,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=MT([o],r.rank),l=od(n,o,s,!i);return a!=null&&(l=Me(l,a)),l}}}};var FF={kernelName:Ga,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:r,strides:o,pad:s,dimRoundingMode:i}=e,a=r??[1,1];D(Jr(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[l,u]=t;return D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),D(An(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),bt("depthwiseConv2d",s,i),{x:()=>gb(l.shape,n,u,o,s,a,i),filter:()=>mb(l,n,u.shape,o,s,a,i)}}};var $F={kernelName:Wa,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[r,o]=t,s={x:r,filter:o,dy:n},i={x:r,filter:o,dy:n};return{x:()=>E.runKernel(fm,s,e),filter:()=>E.runKernel(dm,i,e)}}};var PF={kernelName:di,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t,r={dy:n,y:e};return{x:()=>E.runKernel(ef,r)}}};var LF={kernelName:hi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,r=R(Ht(Fe(_e(e))),2/Math.sqrt(Math.PI));return{x:()=>R(n,r)}}};var BF={kernelName:mi,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,e)}}};var zF={kernelName:ja,inputsToSave:["input"],gradFunc:(n,t)=>{let[e]=t;return{input:()=>O(n,e.shape)}}};var VF={kernelName:gi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,Ht(e))}}};var UF={kernelName:yi,gradFunc:n=>({x:()=>ye(n)})};var GF={kernelName:xi,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=ne(n,Y(r,"float32")),l=ht(e.shape,o);return l.length>0?O(ie(a,l),e.shape):a},b:()=>{let a=R(n,Y(e,"float32")),l=ht(r.shape,o);l.length>0&&(a=O(ie(a,l),r.shape));let u=_e(r);return Fe(ne(a,Y(u,"float32")))}}}};var WF={kernelName:Ha,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{let{varianceEpsilon:r}=e,[o,s,i,a]=t,l=a??se(1),u=ht(s.shape,o.shape),c=[];if(s.rank===1){for(let w=0;w<o.shape.length-1;++w)c.push(o.shape[w]);c.push(1)}let p=te(o,s),f=R(n,l),d=cd(j(i,se(r))),h=R(R(R(d,d),d),se(-.5));return{x:()=>s.rank===1?O(R(R(n,Rn(O(d,[1,1,1,s.shape[0]]),c)),l),o.shape):O(R(R(n,d),l),o.shape),mean:()=>{let w=R(R(d,se(-1)),f);return s.rank===1&&(w=ie(w,u)),O(w,s.shape)},variance:()=>{let w=R(R(h,p),f);return s.rank===1&&(w=ie(w,u)),O(w,s.shape)},scale:()=>{let w=R(p,d),S=R(n,w);return s.rank===1&&(S=ie(S,u)),O(S,s.shape)},offset:()=>{let w=n;return s.rank===1&&(w=ie(w,u)),O(w,s.shape)}}}};var qF={kernelName:qa,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{let[r,o]=t,{axis:s,batchDims:i}=e,a=an(s,r.shape)[0],l=(u,c,p)=>()=>{let f=u.shape,d=c.size,h=f.slice(0,a),g=h.length,m=f.slice(s,f.length).slice(1),y=m.length,x=jF(0,g),v=jF(g+1,g+1+y),w=HF([h,[d],m]),S=O(p,w),k=O(c,[d]),A=HF([[g],x,v]),_=Me(S,A),F=vd(_,k,u.shape[a]),$=Im(A);return F=Me(F,$),F};if(i===1){let u=r.shape[0],c=r.split(u,0);return{x:()=>Lt(c.map((d,h)=>l(d,o.slice(h,1),n.slice(h,1))())).reshape(r.shape),indices:()=>o}}else return{x:l(r,o,n),indices:()=>o}}};function jF(n,t){let e=[];for(let r=n;r<t;++r)e.push(r);return e}function HF(n){let t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}var KF={kernelName:bi,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t;return{a:()=>ye(e),b:()=>ye(r)}}};var XF={kernelName:vs,gradFunc:n=>({x:()=>Y(n,"float32")})};var YF={kernelName:vi,gradFunc:n=>({x:()=>ye(n)})};var ZF={kernelName:wi,gradFunc:n=>({x:()=>ye(n)})};var QF={kernelName:Ci,gradFunc:n=>({x:()=>ye(n)})};var JF={kernelName:Ka,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{alpha:o}=e,s=$t(r,0);return{x:()=>vt(s,n,R(n,o))}}};var e$={kernelName:Si,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,j(e,1))}}};var t$={kernelName:Ii,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,Y(e,"float32"))}}};var n$={kernelName:P_,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r]=t,{axis:o}=e;return{logits:()=>{let i=Ht(r);return te(n,R(ie(n,o,!0),i))}}}};function Jne(n,t,e,r=5,o=1,s=1,i=.5){let a={x:n,y:t,dy:e},l={depthRadius:r,bias:o,alpha:s,beta:i};return E.runKernel(uf,a,l)}var r$=T({localResponseNormalizationBackprop_:Jne});var o$={kernelName:Xa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,o]=t,{depthRadius:s,bias:i,alpha:a,beta:l}=e;return{x:()=>r$(r,o,n,s,i,a,l)}}};function Rb(n,t,e,r){return t.rank<e.rank&&(t=O(t,bo(t.shape,r))),n.rank<e.rank&&(n=O(n,bo(n.shape,r))),{x:()=>R(n,Y(Yn(e,t),n.dtype))}}var lN={kernelName:Ya,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let r=e,{reductionIndices:o}=r,s=t[0],i=t[1],a=an(o,s.shape),l=Rb(n,i,s,a);return{x:()=>l.x()}}};var s$={kernelName:Ti,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t;return{a:()=>R(n,Y(sr(e,r),"float32")),b:()=>R(n,Y(Qi(e,r),"float32"))}}};function ere(n,t,e,r,o,s,i){let a=I(n,"dy","maxPool3dGrad"),l=I(t,"input","maxPool3dGrad"),u=I(e,"output","maxPool3dGrad"),c=a,p=l,f=u,d=!1;l.rank===4&&(d=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=O(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=O(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),D(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),D(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),D(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),bt("maxPool3dGrad",s,i);let h={dy:c,input:p,output:f},g={filterSize:r,strides:o,pad:s,dimRoundingMode:i},m=E.runKernel(pf,h,g);return d?O(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var i$=T({maxPool3dGrad_:ere});var a$={kernelName:Qa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>i$(n,r,o,s,i,a,l)}}};function tre(n,t,e,r,o,s,i){let a=I(n,"dy","maxPoolGrad"),l=I(t,"input","maxPoolGrad"),u=I(e,"output","maxPoolGrad");D(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),D(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),D(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),bt("maxPoolGrad",s,i);let c={dy:a,input:l,output:u},p={filterSize:r,strides:o,pad:s,dimRoundingMode:i};return E.runKernel(cf,c,p)}var l$=T({maxPoolGrad_:tre});var u$={kernelName:Za,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>l$(n,r,o,s,i,a)}}};var c$={kernelName:Ja,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{axis:o}=e,s=an(o,r.shape),a=OT(r.shape,s)[1],l=$e(a);return{x:()=>{let c=r.shape.slice();s.forEach(d=>{c[d]=1});let p=O(n,c);return ne(R(p,Pt(r.shape,"float32")),l)}}}};var p$={kernelName:el,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let r=e,{axis:o}=r,[s,i]=t,a=an(o,s.shape),l=Rb(n,i,s,a);return{x:()=>l.x()}}};var f$={kernelName:Ni,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t;return{a:()=>R(n,Y(Mr(e,r),"float32")),b:()=>R(n,Y($t(e,r),"float32"))}}};var d$={kernelName:tl,inputsToSave:["x"],gradFunc:(n,t,e)=>{let r=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ne(n,s,r.shape)}}};var h$={kernelName:Ei,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=ht(e.shape,o);return a.length>0?O(ie(n,a),e.shape):n},b:()=>{let a=R(n,Fe(Rs(ne(e,r)))),l=ht(r.shape,o);return l.length>0?O(ie(a,l),r.shape):a}}}};var m$={kernelName:Di,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=R(n,Y(r,"float32")),l=ht(e.shape,o);return l.length>0?O(ie(a,l),e.shape):a},b:()=>{let a=R(n,Y(e,"float32")),l=ht(r.shape,o);return l.length>0?O(ie(a,l),r.shape):a}}}};var g$={kernelName:nl,gradFunc:n=>({x:()=>Fe(n)})};var y$={kernelName:ol,inputsToSave:["indices"],gradFunc:(n,t)=>{let e=t[0];return{indices:()=>nt(e.shape,"float32")}}};var x$={kernelName:rl,gradFunc:n=>({x:()=>ye(n)})};var b$={kernelName:sl,saveAllInputs:!0,gradFunc:(n,t,e)=>{let{axis:r}=e;return pn(n,r).map(s=>()=>s)}};var uN={kernelName:il,inputsToSave:["x"],gradFunc:(n,t,e)=>{let r=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ne(n,s,r.shape)}}};var v$={kernelName:ki,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{let[e,r,o]=t,s=e,i=r,a=De(s.shape,i.shape);return{a:()=>{let c=Y(i,"float32"),p=R(n,R(c,Ln(s,te(c,se(1))))),f=ht(s.shape,a);return f.length>0&&(p=ie(p,f)),O(p,s.shape)},b:()=>{let c=$t(s,0),p=vt(c,wn(s),ye(s)),f=R(n,R(o,p)),d=ht(i.shape,a);return d.length>0&&(f=ie(f,d)),O(f,i.shape)}}}};var w$={kernelName:al,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{let[e,r]=t,o=$t(e,0);return{x:()=>vt(o,n,R(n,r)),alpha:()=>{let s=vt(o,ye(n),R(n,e)),i=ht(r.shape,n.shape);return i.length>0&&(s=ie(s,i)),O(s,r.shape)}}}};function nre(n,t,e){let r=n.shape.slice();r[e]=1;let o=O(t,r),s=ic(n,e,!0,!1),i=ic(n,e,!0,!0),a=R(s,i);return R(o,a)}function rre(n,t,e){let r=n.shape.length,o=r-e.length,s=N.getAxesPermutation(e,r),i=n;s!=null&&(i=Me(n,s));let a=i.shape.slice(),u=a.splice(r-e.length,e.length).reduce((f,d)=>f*d,1);a.push(u);let c=i.reshape(a),p=nre(c,t,o);if(p=p.reshape(i.shape),s!=null){let f=N.getUndoAxesPermutation(s);p=Me(p,f)}return p}var C$={kernelName:ll,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{axis:o}=e,s=[];return o==null?s=r.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>rre(r,n,s)}}};var I$={kernelName:fi,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=ne(n,Y(r,"float32")),l=ht(e.shape,o);return l.length>0?O(ie(a,l),e.shape):a},b:()=>{let a=R(n,Y(e,"float32")),l=ht(r.shape,o);l.length>0&&(a=O(ie(a,l),r.shape));let u=_e(r);return Fe(ne(a,Y(u,"float32")))}}}};var S$={kernelName:Ai,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,Fe(_e(e)))}}};var T$={kernelName:_i,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,r=R(Mr(e,6),vo(e));return{x:()=>R(n,Y(r,"float32"))}}};var N$={kernelName:Ri,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,Y(vo(e),"float32"))}}};var E$={kernelName:ul,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>O(n,e.shape)}}};var D$={kernelName:pl,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[r]=t,o={dy:n,images:r};return{images:()=>E.runKernel(If,o,e)}}};var k$={kernelName:cl,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[r]=t,o={dy:n,images:r};return{images:()=>E.runKernel(Cf,o,e)}}};var A$={kernelName:fl,gradFunc:(n,t,e)=>{let{dims:r}=e,o=an(r,n.shape);return{x:()=>un(n,o)}}};var R$={kernelName:Oi,gradFunc:n=>({x:()=>ye(n)})};var _$={kernelName:Mi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Fe(ne(n,R(Ln(e,1.5),2)))}}};var O$={kernelName:dl,inputsToSave:["condition"],gradFunc:(n,t)=>{let[e]=t;return{condition:()=>Y(ye(e),"float32"),t:()=>R(n,Y(e,n.dtype)),e:()=>R(n,Y(Fl(e),n.dtype))}}};var M$={kernelName:Fi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=$t(e,se(0)),o=se(oN),s=se(sN),i=R(n,s),a=R(R(n,o),Ht(Y(e,"float32")));return vt(r,i,a)}}}};var F$={kernelName:Bi,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,R(e,te(se(1),e)))}}};var $$={kernelName:Li,gradFunc:n=>({x:()=>ye(n)})};var P$={kernelName:$i,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(kl(Y(e,"float32")),n)}}};var L$={kernelName:Pi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(rd(Y(e,"float32")),n)}}};var B$={kernelName:hl,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{begin:o,size:s}=e,i=r.shape,[a,l]=rN(r,o,s),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>ir(n,u)}}};var z$={kernelName:xl,outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r]=t,{dim:o}=e,s=!0,i=R(n,r);return{logits:()=>te(i,R(ie(i,[o],s),r))}}};var V$={kernelName:zi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,Xn(e))}}};var cN={kernelName:gl,gradFunc:(n,t,e)=>{let{blockShape:r,paddings:o}=e;return{x:()=>Dl(n,r,o)}}};var pN={kernelName:yl,gradFunc:(n,t,e)=>{let{axis:r}=e;return{x:()=>Je(n,r)}}};var U$={kernelName:Vi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,R(pt(Y(e,"float32")),2))}}};var G$={kernelName:_f,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(n,R(Y(e,"float32"),2))}}};var W$={kernelName:Ui,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=se(2);return{a:()=>R(n,R(o,te(e,r))),b:()=>R(n,R(o,te(r,e)))}}};var j$={kernelName:Hi,gradFunc:n=>({x:()=>ye(n)})};var H$={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,o=De(e.shape,r.shape);return{a:()=>{let a=n,l=ht(e.shape,o);return l.length>0&&(a=ie(a,l)),O(a,e.shape)},b:()=>{let a=n,l=ht(r.shape,o);return l.length>0&&(a=ie(a,l)),O(Fe(a),r.shape)}}}};var q$={kernelName:ml,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,o=r.shape.slice(),{axis:s}=e;an(s,r.shape).forEach(u=>{o[u]=1});let a=O(n,o),l=R(a,Pt(r.shape,"float32"));return{x:()=>l}}};var K$={kernelName:Wi,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ne(n,_e(kl(e)))}}};var X$={kernelName:ji,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>R(te(se(1),_e(e)),n)}}};var Y$={kernelName:ws,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{reps:o}=e;return{x:()=>{let i=ye(r);if(r.rank===1)for(let a=0;a<o[0];++a)i=j(i,Ne(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)i=j(i,Ne(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)i=j(i,Ne(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let u=0;u<o[2];++u)for(let c=0;c<o[3];++c)i=j(i,Ne(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};var Z$={kernelName:Cs,gradFunc:(n,t,e)=>{let r=e,{perm:o}=r,s=Im(o);return{x:()=>Me(n,s)}}};var Q$={kernelName:bl,gradFunc:(n,t,e)=>{let r=e,{axis:o}=r;return{value:()=>Lt(n,o)}}};var J$={kernelName:vl,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>ore(n,e)}}};function ore(n,t){let e=wr(t,ye(t)),r=_s(n,e),o=sr(t,se(0,"int32")),s=r.rank-o.rank;for(let a=0;a<s;++a)o=Xt(o,a+1);o=Bn(o,Pt(r.shape,"bool"));let i=ye(r);return vt(o,r,i)}var eP={kernelName:wl,gradFunc:n=>({x:()=>ye(n)})};var sre=[Ab,sF,iF,aF,lF,uF,cF,pF,fF,dF,hF,mF,yF,bF,vF,wF,CF,IF,SF,TF,NF,EF,kF,DF,RF,_F,OF,MF,FF,$F,I$,PF,LF,BF,zF,VF,GF,UF,WF,qF,KF,XF,YF,ZF,QF,JF,e$,t$,n$,o$,lN,lN,s$,a$,u$,c$,p$,f$,d$,h$,m$,g$,y$,x$,b$,uN,uN,v$,w$,C$,S$,T$,N$,E$,D$,k$,A$,R$,_$,O$,M$,F$,$$,P$,L$,B$,z$,V$,cN,cN,pN,pN,U$,W$,G$,j$,H$,q$,K$,X$,Y$,Z$,Q$,J$,eP];for(let n of sre)z_(n);M().prototype.abs=function(){return this.throwIfDisposed(),Tt(this)};M().prototype.acos=function(){return this.throwIfDisposed(),yx(this)};M().prototype.acosh=function(){return this.throwIfDisposed(),xx(this)};M().prototype.add=function(n){return this.throwIfDisposed(),j(this,n)};M().prototype.all=function(n,t){return this.throwIfDisposed(),Qf(this,n,t)};M().prototype.any=function(n,t){return this.throwIfDisposed(),oc(this,n,t)};M().prototype.argMax=function(n){return this.throwIfDisposed(),Ts(this,n)};M().prototype.argMin=function(n){return this.throwIfDisposed(),bx(this,n)};M().prototype.asScalar=function(){return this.throwIfDisposed(),D(this.size===1,()=>"The array must have only 1 element."),O(this,[])};M().prototype.asType=function(n){return this.throwIfDisposed(),Y(this,n)};M().prototype.as1D=function(){return this.throwIfDisposed(),O(this,[this.size])};M().prototype.as2D=function(n,t){return this.throwIfDisposed(),O(this,[n,t])};M().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),O(this,[n,t,e])};M().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),O(this,[n,t,e,r])};M().prototype.as5D=function(n,t,e,r,o){return this.throwIfDisposed(),O(this,[n,t,e,r,o])};M().prototype.asin=function(){return this.throwIfDisposed(),vx(this)};M().prototype.asinh=function(){return this.throwIfDisposed(),wx(this)};M().prototype.atan=function(){return this.throwIfDisposed(),Cx(this)};M().prototype.atan2=function(n){return this.throwIfDisposed(),Ix(this,n)};M().prototype.atanh=function(){return this.throwIfDisposed(),Sx(this)};M().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),El(this,n,t,e,r)};M().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Dl(this,n,t)};M().prototype.batchNorm=function(n,t,e,r,o){return this.throwIfDisposed(),Es(this,n,t,e,r,o)};M().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Ds(this,n)};M().prototype.cast=function(n){return this.throwIfDisposed(),Y(this,n)};M().prototype.ceil=function(){return this.throwIfDisposed(),Ax(this)};M().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),bn(this,n,t)};M().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Ke&&(n=[n]),Je([this,...n],t)};M().prototype.conv1d=function(n,t,e,r,o,s){return this.throwIfDisposed(),ed(this,n,t,e,r,o,s)};M().prototype.conv2dTranspose=function(n,t,e,r,o){return this.throwIfDisposed(),nd(this,n,t,e,r,o)};M().prototype.conv2d=function(n,t,e,r,o,s){return this.throwIfDisposed(),br(this,n,t,e,r,o,s)};M().prototype.cos=function(){return this.throwIfDisposed(),kl(this)};M().prototype.cosh=function(){return this.throwIfDisposed(),rd(this)};M().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),ic(this,n,t,e)};M().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),od(this,n,t,e)};M().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),Lx(this,n,t)};M().prototype.depthwiseConv2d=function(n,t,e,r,o,s){return this.throwIfDisposed(),ks(this,n,t,e,r,o,s)};M().prototype.dilation2d=function(n,t,e,r,o){return this.throwIfDisposed(),Bx(this,n,t,e,r,o)};M().prototype.divNoNan=function(n){return this.throwIfDisposed(),zx(this,n)};M().prototype.div=function(n){return this.throwIfDisposed(),ne(this,n)};M().prototype.dot=function(n){return this.throwIfDisposed(),Vx(this,n)};M().prototype.elu=function(){return this.throwIfDisposed(),As(this)};M().prototype.equal=function(n){return this.throwIfDisposed(),Yn(this,n)};M().prototype.erf=function(){return this.throwIfDisposed(),sd(this)};M().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),Ux(this,n,t)};M().prototype.exp=function(){return this.throwIfDisposed(),Ht(this)};M().prototype.expandDims=function(n){return this.throwIfDisposed(),Xt(this,n)};M().prototype.expm1=function(){return this.throwIfDisposed(),Gx(this)};M().prototype.fft=function(){return this.throwIfDisposed(),zl(this)};M().prototype.flatten=function(){return this.throwIfDisposed(),O(this,[this.size])};M().prototype.floor=function(){return this.throwIfDisposed(),Rs(this)};M().prototype.floorDiv=function(n){return this.throwIfDisposed(),Zf(this,n)};M().prototype.gather=function(n,t,e){return this.throwIfDisposed(),_s(this,n,t,e)};M().prototype.greaterEqual=function(n){return this.throwIfDisposed(),sr(this,n)};M().prototype.greater=function(n){return this.throwIfDisposed(),$t(this,n)};M().prototype.ifft=function(){return this.throwIfDisposed(),ea(this)};M().prototype.irfft=function(){return this.throwIfDisposed(),yd(this)};M().prototype.isFinite=function(){return this.throwIfDisposed(),Wx(this)};M().prototype.isInf=function(){return this.throwIfDisposed(),jx(this)};M().prototype.isNaN=function(){return this.throwIfDisposed(),Hx(this)};M().prototype.leakyRelu=function(n){return this.throwIfDisposed(),_l(this,n)};M().prototype.lessEqual=function(n){return this.throwIfDisposed(),Mr(this,n)};M().prototype.less=function(n){return this.throwIfDisposed(),Qi(this,n)};M().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),qx(this,n,t,e,r)};M().prototype.logSigmoid=function(){return this.throwIfDisposed(),Kx(this)};M().prototype.logSoftmax=function(n){return this.throwIfDisposed(),id(this,n)};M().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),Ml(this,n,t)};M().prototype.log=function(){return this.throwIfDisposed(),wn(this)};M().prototype.log1p=function(){return this.throwIfDisposed(),Ol(this)};M().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Bn(this,n)};M().prototype.logicalNot=function(){return this.throwIfDisposed(),Fl(this)};M().prototype.logicalOr=function(n){return this.throwIfDisposed(),ad(this,n)};M().prototype.logicalXor=function(n){return this.throwIfDisposed(),Xx(this,n)};M().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),Oe(this,n,t,e)};M().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),$l(this,n,t,e,r)};M().prototype.max=function(n,t){return this.throwIfDisposed(),vn(this,n,t)};M().prototype.maximum=function(n){return this.throwIfDisposed(),wr(this,n)};M().prototype.mean=function(n,t){return this.throwIfDisposed(),wt(this,n,t)};M().prototype.min=function(n,t){return this.throwIfDisposed(),Yi(this,n,t)};M().prototype.minimum=function(n){return this.throwIfDisposed(),to(this,n)};M().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),Qx(this,n,t)};M().prototype.mod=function(n){return this.throwIfDisposed(),Jx(this,n)};M().prototype.mul=function(n){return this.throwIfDisposed(),R(this,n)};M().prototype.neg=function(){return this.throwIfDisposed(),Fe(this)};M().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Zi(this,n,t,e)};M().prototype.notEqual=function(n){return this.throwIfDisposed(),Xo(this,n)};M().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),uc(this,n,t,e)};M().prototype.onesLike=function(){return this.throwIfDisposed(),hn(this)};M().prototype.pad=function(n,t){return this.throwIfDisposed(),ir(this,n,t)};M().prototype.pool=function(n,t,e,r,o,s){return this.throwIfDisposed(),eb(this,n,t,e,r,o,s)};M().prototype.pow=function(n){return this.throwIfDisposed(),Ln(this,n)};M().prototype.prelu=function(n){return this.throwIfDisposed(),Ll(this,n)};M().prototype.prod=function(n,t){return this.throwIfDisposed(),tb(this,n,t)};M().prototype.reciprocal=function(){return this.throwIfDisposed(),ib(this)};M().prototype.relu=function(){return this.throwIfDisposed(),_n(this)};M().prototype.relu6=function(){return this.throwIfDisposed(),ld(this)};M().prototype.reshapeAs=function(n){return this.throwIfDisposed(),O(this,n.shape)};M().prototype.reshape=function(n){return this.throwIfDisposed(),O(this,n)};M().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),Cb(this,n,t,e)};M().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),Ib(this,n,t,e)};M().prototype.reverse=function(n){return this.throwIfDisposed(),un(this,n)};M().prototype.rfft=function(){return this.throwIfDisposed(),Vl(this)};M().prototype.round=function(){return this.throwIfDisposed(),ud(this)};M().prototype.rsqrt=function(){return this.throwIfDisposed(),cd(this)};M().prototype.selu=function(){return this.throwIfDisposed(),pd(this)};M().prototype.separableConv2d=function(n,t,e,r,o,s){return this.throwIfDisposed(),fd(this,n,t,e,r,o,s)};M().prototype.sigmoid=function(){return this.throwIfDisposed(),Xn(this)};M().prototype.sign=function(){return this.throwIfDisposed(),ab(this)};M().prototype.sin=function(){return this.throwIfDisposed(),dd(this)};M().prototype.sinh=function(){return this.throwIfDisposed(),hd(this)};M().prototype.slice=function(n,t){return this.throwIfDisposed(),Ne(this,n,t)};M().prototype.softmax=function(n){return this.throwIfDisposed(),Bl(this,n)};M().prototype.softplus=function(){return this.throwIfDisposed(),Ko(this)};M().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Pl(this,n,t)};M().prototype.split=function(n,t){return this.throwIfDisposed(),cn(this,n,t)};M().prototype.sqrt=function(){return this.throwIfDisposed(),pt(this)};M().prototype.square=function(){return this.throwIfDisposed(),_e(this)};M().prototype.squaredDifference=function(n){return this.throwIfDisposed(),xd(this,n)};M().prototype.squeeze=function(n){return this.throwIfDisposed(),$r(this,n)};M().prototype.stack=function(n,t){this.throwIfDisposed();let e=n instanceof Ke?[this,n]:[this,...n];return Lt(e,t)};M().prototype.step=function(n){return this.throwIfDisposed(),vo(this,n)};M().prototype.stridedSlice=function(n,t,e,r,o,s,i,a){return this.throwIfDisposed(),lb(this,n,t,e,r,o,s,i,a)};M().prototype.sub=function(n){return this.throwIfDisposed(),te(this,n)};M().prototype.sum=function(n,t){return this.throwIfDisposed(),ie(this,n,t)};M().prototype.tan=function(){return this.throwIfDisposed(),ub(this)};M().prototype.tanh=function(){return this.throwIfDisposed(),qo(this)};M().prototype.tile=function(n){return this.throwIfDisposed(),Rn(this,n)};M().prototype.toBool=function(){return this.throwIfDisposed(),Y(this,"bool")};M().prototype.toFloat=function(){return this.throwIfDisposed(),Y(this,"float32")};M().prototype.toInt=function(){return this.throwIfDisposed(),Y(this,"int32")};M().prototype.topk=function(n,t){return this.throwIfDisposed(),cb(this,n,t)};M().prototype.transpose=function(n){return this.throwIfDisposed(),Me(this,n)};M().prototype.unique=function(n){return this.throwIfDisposed(),pb(this,n)};M().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),vd(this,n,t)};M().prototype.unstack=function(n){return this.throwIfDisposed(),pn(this,n)};M().prototype.where=function(n,t){return this.throwIfDisposed(),vt(n,this,t)};M().prototype.zerosLike=function(){return this.throwIfDisposed(),ye(this)};var no=class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}},ar=class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}},P=class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}},ve=class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}},_b=class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}};var _m=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}};function Io(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}else{let e=new Array(t);return e.fill(n),e}}function ro(n,t){if(!n)throw new _b(t)}function dN(n,t){let e=0;for(let r of n)r===t&&e++;return e}function In(n){return n.length===1?n[0]:n}function rt(n){return Array.isArray(n)?n:[n]}function So(n){let e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function ra(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var Co={};function Dd(n){if(n==null)return null;let t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function fN(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>fN(t));else{let t=Object.keys(n);for(let e of t){let r=n[e];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[e]=r.value:fN(r))}}}function Ms(n,t={},e={},r="object",o=!1){if(typeof n=="string"){let s=n,i;if(s in e)i=e[s];else if(s in Co)i=Co[s];else if(i=t[s],i==null)throw new P(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=n;if(s.className==null||s.config==null)throw new P(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,l;if(i in e?[a,l]=e[i]:i in Co?[a,l]=Co.className:i in t&&([a,l]=t[i]),a==null)throw new P(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let d of Object.keys(Co))u[d]=Co[d];for(let d of Object.keys(e))u[d]=e[d];let c=s.config;c.customObjects=u;let p=Object.assign({},Co);for(let d of Object.keys(e))Co[d]=e[d];fN(s.config);let f=l(a,s.config,e,o);return Co=Object.assign({},p),f}else{let u=Object.assign({},Co);for(let p of Object.keys(e))Co[p]=e[p];let c=new a(s.config);return Co=Object.assign({},u),c}}}function ire(n,t){return n<t?-1:n>t?1:0}function Om(n,t){return-1*ire(n,t)}function To(n){if(n==null)return n;let t=[];for(let e of n)t.indexOf(e)===-1&&t.push(e);return t}function tP(n){if(n==null)throw new P(`Invalid value in obj: ${JSON.stringify(n)}`);for(let t in n)if(n.hasOwnProperty(t))return!1;return!0}function Fs(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new P(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function Ob(n,t,e=0,r=1/0){return ro(e>=0),ro(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(o=>typeof o===t)}function Zt(n,t){Array.isArray(n)?(b.assert(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>Zt(e,`element ${r+1} of ${t}`))):b.assert(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${nP(n)}.`)}function nP(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>nP(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function rP(n,t,e){let r=e!=null?e():b.now(),o;return(...i)=>{let a=e!=null?e():b.now();return a-r<t||(r=a,o=n(...i)),o}}function Mb(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}var are=0;function $b(){return are++}var Fb={};function Wl(n=""){return n in Fb||(Fb[n]=0),Fb[n]+=1,n+Fb[n].toString()}var oP=["channelsFirst","channelsLast"],sP=["nearest","bilinear"],iP=["valid","same","causal"],aP=["max","avg"],lP=["sum","mul","concat","ave"];var kd=new Map;function kt(n){Fs(oP,"DataFormat",n)}function cP(n){Fs(sP,"InterpolationFormat",n)}function lr(n){Fs(iP,"PaddingMode",n)}function hN(n){Fs(aP,"PoolMode",n)}var Mm=[],uP="/";function Qo(n,t){Mm.push(n);try{let e=t();return Mm.pop(),e}catch(e){throw Mm.pop(),e}}function lre(){return Mm.length===0?"":Mm.join(uP)+uP}function Pb(n){if(!pP(n))throw new Error("Not a valid tensor name: '"+n+"'");return lre()+n}function Lb(n){if(!pP(n))throw new Error("Not a valid tensor name: '"+n+"'");kd.has(n)||kd.set(n,0);let t=kd.get(n);if(kd.set(n,kd.get(n)+1),t>0){let e=`${n}_${t}`;return kd.set(e,1),e}else return n}var ure=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function pP(n){return!!n.match(ure)}function fP(n){return n===parseInt(n.toString(),10)}function No(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let r=1;for(let o=t;o<e;++o)r*=n[o];return r}function bc(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){let r=n[e];r<t&&(t=r)}return t}function Jo(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){let r=n[e];r>t&&(t=r)}return t}function ur(n,t){if(t<n)throw new P(`end (${t}) < begin (${n}) is forbidden.`);let e=[];for(let r=n;r<t;++r)e.push(r);return e}var mN;function on(){return mN==null&&(mN=ux().epsilon()),mN}function cr(){return"channelsLast"}function Zn(n,t){return Y(n,t)}function sa(n,t=-1){let e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),O(n,e)}function dP(n,t){return B(()=>{if(n.shape.length!==2)throw new P(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);let e=sa(n,1);return zb(e,[1,t,1])})}function hP(n){let t=[No(n.shape)];return O(n,t)}function mP(n){if(n.rank<=1)throw new P(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);let t=[n.shape[0],No(n.shape,1)];return O(n,t)}function oa(n,t,e){return B(()=>{switch(n.rank){case 1:return md(n,t,e);case 2:return Nm(n,[t,0],[e,n.shape[1]]);case 3:return gd(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return dc(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Ne(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Ne(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new P(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function gN(n,t,e){return B(()=>{switch(n.rank){case 1:return md(n,t,e);case 2:return Nm(n,[0,t],[n.shape[0],e]);case 3:return gd(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return dc(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Fm(n,t,e,r){return B(()=>{switch(n.rank){case 1:return md(n,t,e);case 2:switch(r){case 1:return oa(n,t,e);case 2:return gN(n,t,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return oa(n,t,e);case 2:return gd(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return gN(n,t,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return oa(n,t,e);case 2:return dc(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return dc(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return gN(n,t,e);default:throw new P(`The axis is not within the rank of the tensor ${r}`)}default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ad(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),Je(n,t)}function xN(n,t){switch(n.rank){case 1:return Rx([n,t]);case 2:return _x([n,t],0);case 3:return Ox([n,t],0);case 4:return Mx([n,t],0);default:throw new P(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function zb(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new P(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Rn(n,t)}function Rd(n,t=0,e=1,r,o){return fc(n,t,e,r,o)}function Eo(n,t,e,r){if(n.rank<2||t.rank<2)throw new ve(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=n.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new ve(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return Ul.matMul({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?yN(n.rank,r,cr()):null,activation:e});{let o=n.shape.slice(),s=o.pop();n=O(n,[-1,s]);let i=t.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:t.rank},(h,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=O(Me(t,c),[l,-1]);let p=[...o,...u];return O(Ul.matMul({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?yN(n.rank,r,cr()):null,activation:e}),p)}}function Vb(n,t,e){return B(()=>(Array.isArray(t)?t=Bt(t,"int32"):t=Y(t,"int32"),_s(n,t,e)))}function vc(n){return R(n,n)}function yN(n,t,e){let r=t.shape;if(t.rank!==1&&t.rank!==n)throw new P(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return r.length===1?O(t,[1,r[0],1,1,1]):O(t,[1,r[3],r[0],r[1],r[2]]);if(e==="channelsLast")return r.length===1?O(t,[1,1,1,1,r[0]]):O(t,[1].concat(r))}else if(n===4){if(e==="channelsFirst")return r.length===1?O(t,[1,r[0],1,1]):O(t,[1,r[2],r[0],r[1]]);if(e==="channelsLast")return r.length===1?O(t,[1,1,1,r[0]]):O(t,[1].concat(r))}else if(n===3){if(e==="channelsFirst")return r.length===1?O(t,[1,r[0],1]):O(t,[1,r[1],r[0]]);if(e==="channelsLast")return r.length===1?O(t,[1,1,r[0]]):O(t,[1].concat(r))}else if(n<3)return t;throw new P(`Unsupported input rank by biasAdd: ${t.rank}`)}function pr(n,t,e){return B(()=>(e==null&&(e=cr()),kt(e),j(n,yN(n.rank,t,e))))}function gP(n,t=1){if(t!==1)throw new ve(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return As(n)}function yP(n){return B(()=>ne(n,j(Tt(n),1)))}function Ub(n,t,e,r){return B(()=>GT(n,t,e,r))}function xP(n){return B(()=>{let t=j(.5,R(.2,n));return bn(t,0,1)})}function jl(n,t,e=!1){return e?n():t()}var bP=["fanIn","fanOut","fanAvg"],vP=["normal","uniform","truncatedNormal"];function cre(n){Fs(bP,"FanMode",n)}function pre(n){Fs(vP,"Distribution",n)}var fr=class extends q.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},IP=(()=>{class n extends fr{apply(e,r){return nt(e,r)}}return n.className="Zeros",n})();q.registerClass(IP);var Gb=(()=>{class n extends fr{apply(e,r){return Pt(e,r)}}return n.className="Ones",n})();q.registerClass(Gb);var SP=(()=>{class n extends fr{constructor(e){if(super(),typeof e!="object")throw new P(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new P(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return B(()=>R(se(this.value),Pt(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})();q.registerClass(SP);var TP=(()=>{class n extends fr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Fr(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})();q.registerClass(TP);var NP=(()=>{class n extends fr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new ve(`randomNormal does not support dType ${r}.`);return Rd(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})();q.registerClass(NP);var EP=(()=>{class n extends fr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new ve(`truncatedNormal does not support dType ${r}.`);return bd(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})();q.registerClass(EP);var DP=(()=>{class n extends fr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,r){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new P("Identity matrix initializer can only be used for 2D square matrices.");return R(this.gain,ac(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})();q.registerClass(DP);function fre(n,t="channelsLast"){let e,r;if(kt(t),n.length===2)e=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){let o=No(n,2);e=n[1]*o,r=n[0]*o}else if(t==="channelsLast"){let o=No(n,0,n.length-2);e=n[n.length-2]*o,r=n[n.length-1]*o}}else{let o=No(n);e=Math.sqrt(o),r=Math.sqrt(o)}return[e,r]}var Pr=(()=>{class n extends fr{constructor(e){if(super(),e.scale<0)throw new P(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,cre(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,pre(this.distribution),this.seed=e.seed}apply(e,r){let o=fre(e),s=o[0],i=o[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(s+i)/2),this.distribution==="normal"){let l=Math.sqrt(a);if(r=r||"float32",r!=="float32"&&r!=="int32")throw new ve(`${this.getClassName()} does not support dType ${r}.`);return bd(e,0,l,r,this.seed)}else{let l=Math.sqrt(3*a);return Fr(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();q.registerClass(Pr);var bN=(()=>{class n extends Pr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="GlorotUniform",n})();q.registerClass(bN);var vN=(()=>{class n extends Pr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="GlorotNormal",n})();q.registerClass(vN);var wN=(()=>{class n extends Pr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="HeNormal",n})();q.registerClass(wN);var CN=(()=>{class n extends Pr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="HeUniform",n})();q.registerClass(CN);var IN=(()=>{class n extends Pr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="LeCunNormal",n})();q.registerClass(IN);var SN=(()=>{class n extends Pr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Pr.className}}return n.className="LeCunUniform",n})();q.registerClass(SN);var kP=(()=>{class n extends fr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return B(()=>{if(e.length<2)throw new ve("Shape must be at least 2D.");if(r!=="int32"&&r!=="float32"&&r!==void 0)throw new TypeError(`Unsupported data type ${r}.`);r=r;let o=b.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],i=o*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=[Math.max(s,o),Math.min(s,o)],l=Rd(a,0,1,r,this.seed),u=HT.qr(l,!1),c=u[0],f=u[1].flatten().stridedSlice([0],[Math.min(s,o)*Math.min(s,o)],[Math.min(s,o)+1]);return c=R(c,f.sign()),o<s&&(c=c.transpose()),R(se(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})();q.registerClass(kP);var wP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function CP(n,t={}){return Ms(n,q.SerializationMap.getMap().classNameMap,t,"initializer")}function Ct(n){return Dd(n)}function ft(n){if(typeof n=="string"){let t=n in wP?wP[n]:n;if(t==="GlorotNormal")return new vN;if(t==="GlorotUniform")return new bN;if(t==="HeNormal")return new wN;if(t==="HeUniform")return new CN;if(t==="LeCunNormal")return new IN;if(t==="LeCunUniform")return new SN;{let e={};return e.className=t,e.config={},CP(e)}}else return n instanceof fr?n:CP(n)}function Wb(n){return Array.isArray(n)&&Array.isArray(n[0])}function _d(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function xe(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new P(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Re(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new P(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Od(n){let t=0;for(let e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((r,o)=>r*o);return t}var RP="Variable",$m=class{constructor(t,e="float32",r=RP,o=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=$b(),r=r??RP,this.originalName=Pb(r),this.name=Lb(this.originalName),this.trainable_=o,this.constraint=s,this.val=fb(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),hre(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function hre(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function Pm(n){return n.map(t=>t.read())}function Md(n){n.forEach(t=>{t[0].write(t[1])})}var mt=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Qn=class{constructor(t,e,r,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=$b(),i!=null&&(this.originalName=Pb(i),this.name=Lb(this.originalName)),this.rank=e.length}},mre=0,ia=class{constructor(t,e){this.callArgs=e,this.id=mre++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},gre=0,we=class extends q.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=gre++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let r=this.getClassName();e=So(r)+"_"+Wl(r)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),r=[s].concat(t.inputShape)}this.batchInputShape=r;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new ar(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new P(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return In(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return In(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new no(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new no(`Layer ${this.name} is not connected, no input to return.`);return In(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new no(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new no(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return In(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){let e=rt(t);if(this.inputSpec==null||this.inputSpec.length===0)return;let r=rt(this.inputSpec);if(e.length!==r.length)throw new P(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let o=0;o<e.length;o++){let s=e[o],i=r[o];if(i==null)continue;let a=s.rank;if(i.ndim!=null&&a!==i.ndim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&s.dtype!==i.dtype)throw new P(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){let l=s.shape;for(let u in i.axes){let c=Number(u),p=i.axes[u],f=c>=0?l[c]:l[l.length+c];if(p!=null&&[p,null].indexOf(f)===-1)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${p} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){let u=i.shape[l],c=s.shape[l];if(u!=null&&c!=null&&u!==c)throw new P(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let r=rt(t),o=bre(t),s=vre(t);if(o===s)throw new P("Arguments to apply() must be all SymbolicTensors or all Tensors");return Qo(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of rt(t))i.push(a.shape);this.build(In(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,i);let a=rt(i),l=[];for(let u of a)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=In(l),this.activityRegularizer!=null)throw new ve("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=yre(t),a=this.computeOutputShape(i),l,u=xre(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,p)=>new Qn(u,c,this,rt(t),e,this.name,p)):l=new Qn(u,a,this,rt(t),e,this.name),this.addInboundNode(t,l,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new ve("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,o)=>{r!=null&&t[o]!=null&&t[o]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new no(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let r=JSON.stringify(e.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new no(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ar(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Od(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Pm(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{let e=this.weights;if(e.length!==t.length)throw new P(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let r=[],o=Pm(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],l=t[s];if(!b.arraysEqual(i.shape,l.shape))throw new P(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}Md(r)})}addWeight(t,e,r,o,s,i,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new P(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(o=l!=null?l():ft("zeros"));let u=o.apply(e,r),c=new $m(u,r,t,i,a);return u.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=rt(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,r){if(!this.supportsMasking)return;let o=this.computeMask(t,r),s=rt(e),i=rt(o);if(s.length!==i.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=i[a]}addInboundNode(t,e,r,o,s,i,a=null){let l=rt(t);e=rt(e),r=rt(r),o=rt(o),s=_d(s),i=_d(i);let u=[],c=[],p=[];for(let f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),p.push(f.tensorIndex);new ia({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:p,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function yre(n){n=rt(n);let t=[];for(let e of n)t.push(e.shape);return In(t)}function xre(n){return"float32"}function TN(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{let r=t.inboundNodes[e];if(r.inboundLayers.length===0)return r.inputTensors;{let o=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],a=r.inboundLayers[s],l=r.nodeIndices[s],u=TN(i,a,l);for(let c of u)o.indexOf(c)===-1&&o.push(c)}return o}}}function bre(n){let t=!0;for(let e of rt(n))if(!(e instanceof Qn)){t=!1;break}return t}function vre(n){let t=!0;for(let e of rt(n))if(e instanceof Qn){t=!1;break}return t}var wc=(()=>{class n extends we{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Wl("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new P("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(r==null){if(e.inputShape==null)throw new P("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new P("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=e.dtype||"float32";this.batchInputShape=r,this.dtype=o,this.inputSpec=[{shape:r}];let s=new Qn(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new ia({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new P(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();q.registerClass(wc);function NN(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new P("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new wc({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function wre(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Y(t,n.dtype)}catch{throw new P(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}var $s=class n{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof n)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=wre(t,e),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new P(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Qn){if(this.id2Value[t.id]==null)throw new P(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new P(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Qn){if(this.id2Value[t.id]==null)throw new P(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new P(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Se(this.id2Mask)}},jb=new _m,Hb=new _m;function OP(n){jb?.setMaxEntries(n),Hb?.setMaxEntries(n)}function Cc(n,t,e,r){let o=e==null?!1:e.training,s=Array.isArray(n),i=s?n:[n],a=i.map(h=>h.name),l=[],u=t.names();for(let h of a)u.indexOf(h)!==-1?l.push(t.getValue(h)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=jb.get(c),f;if(p==null){let h=Cre(i,t);p=h.sorted,f=h.recipientCounts,jb.put(c,p),Hb.put(c,f)}f={},o||Object.assign(f,Hb.get(c));let d=new $s(t);for(let h=0;h<p.length;++h){if(r!=null){let F=xm().numTensors;F>r.maxNumTensors&&(r.maxNumTensors=F),F<r.minNumTensors&&(r.minNumTensors=F)}let g=p[h],m=g.sourceLayer;if(m instanceof wc)continue;let y=[],x=[],v=[],w=!1;for(let F of g.inputs){let $=d.getValue(F),V=d.getMask(F);y.push($),x.push(V),V!=null&&(w=!0),o||(f[F.name]--,f[F.name]===0&&!t.hasKey(F)&&a.indexOf(F.name)===-1&&!$.isDisposed&&F.sourceLayer.stateful!==!0&&v.push($))}w&&(e=e||{},e.mask=x[0]);let S=rt(m.apply(y,e)),k=null;m.supportsMasking&&(k=m.computeMask(y,x));let A=Sre(g),_=Array.isArray(A)?A:[A];for(let F=0;F<_.length;++F){d.hasKey(_[F])||d.add(_[F],S[F],Array.isArray(k)?k[0]:k);let $=a.indexOf(_[F].name);$!==-1&&(l[$]=S[F])}o||Se(v)}return d.disposeMasks(),s?l:l[0]}function Cre(n,t){b.assert(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(n.length===1){let o=_P(n[0],t);e=o.sorted,r=o.recipientMap}else{let o=new Set;for(let s of n){let{sorted:i,recipientMap:a}=_P(s,t);for(let l of i)o.has(l.name)||(e.push(l),o.add(l.name));for(let l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:e,recipientCounts:Ire(r)}}function Ire(n){let t={};for(let e in n)t[e]=n[e].size;return t}function _P(n,t){let e=new Set,r=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(n);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(s.length-1);for(let u of a.inputs)o[u.name]==null&&(o[u.name]=new Set),o[u.name].add(a.name),!e.has(u.name)&&s.push(u)}}return{sorted:r,recipientMap:o}}function Sre(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(let o of n.sourceLayer.inboundNodes[r].outputTensors)if(o.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}var Tre=L();Tre.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,OP);function EN(n,t){return B(()=>pt(ie(R(n,n),t,!0)))}var Ic=class extends q.Serializable{getConfig(){return{}}},$P=(()=>{class n extends Ic{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let r=EN(e,this.axis),o=bn(r,0,this.maxValue);return R(e,ne(o,j(on(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})();q.registerClass($P);var PP=(()=>{class n extends Ic{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>ne(e,j(on(),EN(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})();q.registerClass(PP);var LP=(()=>{class n extends Ic{apply(e){return _n(e)}}return n.className="NonNeg",n})();q.registerClass(LP);var BP=(()=>{class n extends Ic{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let r=EN(e,this.axis),o=j(R(this.rate,bn(r,this.minValue,this.maxValue)),R(1-this.rate,r));return R(e,ne(o,j(on(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})();q.registerClass(BP);var MP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function zt(n){return Dd(n)}function FP(n,t={}){return Ms(n,q.SerializationMap.getMap().classNameMap,t,"constraint")}function Vt(n){if(n==null)return null;if(typeof n=="string"){let e={className:n in MP?MP[n]:n,config:{}};return FP(e)}else return n instanceof Ic?n:FP(n)}function aa(n){return z(this,null,function*(){if(n==null)return;let t=[],e=[],r=[];for(let o in n){let s=n[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),r.push(i)}}if(t.length>0){let o=yield Promise.all(t);for(let s=0;s<o.length;++s)n[e[s]]=o[s][0];Se(r)}})}function qb(n){if(n!=null)for(let t in n){let e=n[t];typeof e!="number"&&e.dispose()}}var Dre=125,Hl=class{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return z(this,null,function*(){})}onEpochEnd(t,e){return z(this,null,function*(){})}onBatchBegin(t,e){return z(this,null,function*(){})}onBatchEnd(t,e){return z(this,null,function*(){})}onTrainBegin(t){return z(this,null,function*(){})}onTrainEnd(t){return z(this,null,function*(){})}setModel(t){}},Kb=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochBegin(t,e)})}onEpochEnd(t,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochEnd(t,e)})}onBatchBegin(t,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchBegin(t,e)})}onBatchEnd(t,e){return z(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchEnd(t,e)})}onTrainBegin(t){return z(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainBegin(t)})}onTrainEnd(t){return z(this,null,function*(){t==null&&(t={});for(let e of this.callbacks)yield e.onTrainEnd(t)})}},DN=class extends Hl{constructor(){super()}onEpochBegin(t){return z(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(t,e){return z(this,null,function*(){e==null&&(e={});let r=e.size==null?0:e.size;this.seen+=r;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*r;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=B(()=>j(this.totals[o],R(s,r)));this.totals[o]=a,i?.dispose()}}})}onEpochEnd(t,e){return z(this,null,function*(){if(e!=null)for(let r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?e[r]=this.totals[r]/this.seen:B(()=>{let o=R(ne(1,this.seen),this.totals[r]);e[r]=o,this.totals[r].dispose(),Et(e[r])}))})}},Xb=class extends Hl{onTrainBegin(t){return z(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(t,e){return z(this,null,function*(){e==null&&(e={}),this.epoch.push(t);for(let r in e)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(e[r])})}syncData(){return z(this,null,function*(){let t=[],e=[],r=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let l=i[a];t.push(l.data()),e.push(s),r.push(a)}}let o=yield Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][r[s]].dispose(),this.history[e[s]][r[s]]=o[s][0]})}},Yb=class extends Hl{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Rm,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Dre),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=rP(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){return z(this,null,function*(){let o=[];this.yield!=null&&(yield aa(r),o.push(this.yield(t,e,r))),o.push(this.nextFrameFunc()),yield Promise.all(o)})}onEpochBegin(t,e){return z(this,null,function*(){this.currentEpoch=t,this.epochBegin!=null&&(yield aa(e),yield this.epochBegin(t,e))})}onEpochEnd(t,e){return z(this,null,function*(){let r=[];this.epochEnd!=null&&(yield aa(e),r.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),yield Promise.all(r)})}onBatchBegin(t,e){return z(this,null,function*(){this.batchBegin!=null&&(yield aa(e),yield this.batchBegin(t,e))})}onBatchEnd(t,e){return z(this,null,function*(){let r=[];this.batchEnd!=null&&(yield aa(e),r.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,e)),yield Promise.all(r)})}onTrainBegin(t){return z(this,null,function*(){this.trainBegin!=null&&(yield aa(t),yield this.trainBegin(t))})}onTrainEnd(t){return z(this,null,function*(){this.trainEnd!=null&&(yield aa(t),yield this.trainEnd(t))})}};function Zb(n,t){return n==null&&(n={}),n instanceof Hl?[n]:Array.isArray(n)&&n[0]instanceof Hl?n:rt(n).map(r=>new Yb(r,t))}var zP=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),n.constructors[e]==null&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(let r in n.constructors)n.constructors[+r].forEach(s=>{if(s===e)throw new P("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){let r=[];for(let o in n.constructors){let s=+o;e>=s&&r.push(...n.constructors[s])}return r.map(o=>new o)}}return n.constructors={},n})();function Qb(n,t,e,r,o,s,i,a,l){let u=new Xb,c=[new DN,...zP.createCallbacks(t)];n!=null&&c.push(...n),c.push(u);let p=new Kb(c);return p.setParams({epochs:e,initialEpoch:r,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:l}),{callbackList:p,history:u}}function Lr(n,t={},e=!1){return Ms(n,q.SerializationMap.getMap().classNameMap,t,"layer",e)}function Lm(n,t){return B(()=>{n.dtype!=="float32"&&(n=Y(n,"float32"));let e=ie(vc(n),t,!0),r=xo(e.shape,on()),o=pt(wr(e,r));return ne(n,o)})}function Sc(n,t){return B(()=>wt(vc(te(t,n)),-1))}function zm(n,t){return B(()=>wt(Tt(te(t,n)),-1))}function Vm(n,t){return B(()=>{let e=te(n,t),r=bn(Tt(n),on(),Number.MAX_VALUE),o=Tt(ne(e,r));return R(100,wt(o,-1))})}function kre(n,t){return B(()=>{let e=bn(t,on(),Number.MAX_VALUE),r=wn(j(1,e)),o=bn(n,on(),Number.MAX_VALUE),s=wn(j(1,o));return wt(vc(te(r,s)),-1)})}function Are(n,t){return B(()=>{let e=wr(0,te(1,R(n,t)));return wt(vc(e),-1)})}function Rre(n,t){return B(()=>{let e=wr(0,te(1,R(n,t)));return wt(e,-1)})}function _re(n,t){return B(()=>{let e=ie(R(n,t),-1),r=vn(R(te(1,n),t),-1);return wr(0,j(1,te(r,e)))})}function Ore(n,t){return B(()=>{let e=Math.log(2),r=te(t,n),o=te(j(r,Ko(R(-2,r))),e);return wt(o,-1)})}function Tc(n,t,e=!1){return B(()=>{if(e)t=Bl(t);else{let r=ie(t,t.shape.length-1,!0);t=ne(t,r)}return t=bn(t,on(),1-on()),Fe(ie(R(Y(n,"float32"),wn(t)),t.shape.length-1))})}function Fd(n,t,e=!1){return B(()=>{let r=Y(Rs(hP(n)),"int32");t=bn(t,on(),1-on());let o=t.shape,s=O(uc(r,o[o.length-1]),o);return Tc(s,t,e)})}function Mre(n,t){if(!b.arraysEqual(n.shape,t.shape))throw new P(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let e=_n(t),r=Fe(Tt(t));return j(te(e,R(t,n)),Ol(Ht(r)))})}function $d(n,t){return B(()=>{let e;return e=bn(t,on(),1-on()),e=wn(ne(e,te(1,e))),wt(Mre(n,e),-1)})}function Fre(n,t){return B(()=>{let e=bn(n,on(),1),r=bn(t,on(),1);return ie(R(n,wn(ne(e,r))),-1)})}function $re(n,t){return B(()=>{let e=wn(j(on(),t));return wt(te(t,R(n,e)),-1)})}function Jb(n,t){return B(()=>{let e=Lm(n,-1),r=Lm(t,-1),o=R(e,r);return Fe(ie(o,-1))})}var Bm={meanSquaredError:Sc,meanAbsoluteError:zm,meanAbsolutePercentageError:Vm,meanSquaredLogarithmicError:kre,squaredHinge:Are,hinge:Rre,categoricalHinge:_re,logcosh:Ore,categoricalCrossentropy:Tc,sparseCategoricalCrossentropy:Fd,binaryCrossentropy:$d,kullbackLeiblerDivergence:Fre,poisson:$re,cosineProximity:Jb};function ev(n){if(typeof n=="string"){if(n in Bm)return Bm[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new P(t)}else return n}function nv(n,t){return B(()=>{let e=R(.5,hn(t)),r=Zn($t(t,e),n.dtype);return wt(Yn(n,r),-1)})}function rv(n,t){return B(()=>Zn(Yn(Ts(n,-1),Ts(t,-1)),"float32"))}function Pre(n,t){return B(()=>Y(ie(Bn(Yn(n,1),Yn(t,1))),"float32"))}function Lre(n,t){return B(()=>Y(ie(Bn(Yn(n,0),Yn(t,1))),"float32"))}function UP(n,t){return B(()=>{let e=Pre(n,t),r=Lre(n,t),o=j(e,r);return Y(vt($t(o,0),ne(e,o),0),"float32")})}function kN(n,t){return $d(n,t)}function AN(n,t){return n.rank===t.rank&&(n=$r(n,[n.rank-1])),t=Ts(t,-1),t.dtype!==n.dtype&&(t=Y(t,n.dtype)),Y(Yn(n,t),"float32")}var Bre=Sc,zre=Sc,Vre=zm,Ure=zm,Gre=Vm,Wre=Vm,ov=Tc,jre=Jb,RN=Fd,tv={binaryAccuracy:nv,categoricalAccuracy:rv,precision:UP,categoricalCrossentropy:ov,sparseCategoricalCrossentropy:RN,mse:Bre,MSE:zre,mae:Vre,MAE:Ure,mape:Gre,MAPE:Wre,cosine:jre};function GP(n){if(typeof n=="string"&&n in tv)return tv[n];if(typeof n!="string"&&n!=null)return n;throw new P(`Unknown metric ${n}`)}function Um(n){if(ro(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(let e of Object.keys(Bm))if(Bm[e]===n){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(tv))if(tv[e]===n){t=e;break}return t!==void 0?t:n.name}}function jP(n){let t={Adagrad:()=>xc.adagrad(.01),Adadelta:()=>xc.adadelta(1,.95,on()),Adam:()=>xc.adam(.001,.9,.999,on()),Adamax:()=>xc.adamax(.002,.9,.999,on(),0),RMSProp:()=>xc.rmsprop(.001,.9,0,on()),SGD:()=>xc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new P(`Unknown Optimizer ${n}`)}function ON(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!_N(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function _N(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){let t=Object.keys(n);for(let e of t)if(typeof e!="string"||!_N(n[e]))return!1;return!0}else if(Array.isArray(n)){for(let t of n)if(!_N(t))return!1;return!0}else return!1;else{let t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function HP(n,t,e,r=console.log){let o=Kre(n),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in n.nodesByDepth)i.push(...n.nodesByDepth[c])}r("_".repeat(t)),sv(s,e,r),r("=".repeat(t));let a=n.layers;for(let c=0;c<a.length;++c)o?Xre(a[c],e,r):Yre(a[c],e,i,r),r((c===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();let l=qre(n),u=Od(n.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function qre(n){let t;return n.collectedTrainableWeights!=null?t=Od(n.collectedTrainableWeights):t=Od(n.trainableWeights),t}function Kre(n){let t=!0,e=[],r=[];for(let o in n.nodesByDepth)e.push(n.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}r.push(...o)}if(t)for(let o of n.layers){let s=!1;for(let i of o.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function sv(n,t,e=console.log){let r="";for(let o=0;o<n.length;++o)o>0&&(r=r.slice(0,r.length-1)+" "),r+=n[o],r=r.slice(0,t[o]),r+=" ".repeat(t[o]-r.length);e(r)}function Xre(n,t,e){let r,o;try{o=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}let s=n.name,i=n.getClassName(),a=[`${s} (${i})`,o,r,n.countParams().toString()];sv(a,t,e)}function Yre(n,t,e,r){let o,s;try{s=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(n.outputShape)}catch{o="multiple"}let i=[];for(let p of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let f=0;f<p.inboundLayers.length;++f){let d=p.inboundLayers[f].name,h=p.nodeIndices[f],g=p.tensorIndices[f];i.push(`${d}[${h}][${g}]`)}let a=n.name,l=n.getClassName(),u=i.length===0?"":i[0],c=[`${a} (${l})`,s,o,n.countParams().toString(),u];sv(c,t,r);for(let p=1;p<i.length;++p)sv(["","","","",i[p]],t,r)}function qP(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function Gm(n,t){if(n===null)return null;if(typeof n=="string")return ra(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],r=n.length;for(let o=0;o<r;++o){let s=n[o];qP(t,o,s)?e.push(s):e.push(Gm(s,t))}return e}else{let e={};for(let r of Object.keys(n)){let o=n[r];if(r==="name"&&typeof o=="string")e[r]=o;else{let s=ra(r);e[s]=Gm(o,s)}}return e}}function iv(n,t){if(n==null)return null;if(typeof n=="string")return So(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],r=n.length;for(let o=0;o<r;++o){let s=n[o];qP(t,o,s)?e.push(s):e.push(iv(s,t))}return e}else{let e={};for(let r of Object.keys(n)){let o=n[r],s=So(r);(r==="name"||r==="className")&&typeof o=="string"?e[s]=o:e[s]=iv(o,r)}return e}}var Pd="4.20.0";var Zre=n=>{let t=Object.keys(n);if(t.length===0)return!1;let e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))},av=class n extends we{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Wl(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],To(this.inputs).length!==this.inputs.length)throw new P(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);To(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let v=x.sourceLayer,w=x.nodeIndex,S=x.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(S)}for(let x of this.inputs){let v=x.sourceLayer,w=x.nodeIndex,S=x.tensorIndex;ro(w===0,"input layer has >1 nodes"),ro(S===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let v=this.inputLayers[x];if(!(v instanceof wc))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let e={},r={},o={},s={},i={},a=[],l=(x,v,w,S,k,A)=>{(S==null||k==null||A==null)&&(S=x.sourceLayer,k=x.nodeIndex,A=x.tensorIndex);let _=S.inboundNodes[k];if(w.indexOf(_)!==-1)throw new ar(`The tensor ${x.name} at layer "${S.name}" is part of a cycle.`);if(v.indexOf(_)!==-1)return;this.containerNodes.add(n.nodeKey(S,k)),S.id in i||(i[S.id]=Object.keys(i).length),w.indexOf(_)===-1&&w.push(_);let F=_.inboundLayers.length;for(let $=0;$<F;$++){let V=_.inputTensors[$],U=_.inboundLayers[$],W=_.nodeIndices[$],G=_.tensorIndices[$];l(V,v,w,U,W,G)}for(v.push(_);w.indexOf(_)>=0;)w.splice(w.indexOf(_),1);a.push(_)},u=[],c=[];for(let x of this.outputs)l(x,u,c);let p=a.slice().reverse();for(let x of p){r[x.id]=x,x.id in e||(e[x.id]=0);let v=e[x.id],w=o[x.outboundLayer.id]==null?0:o[x.outboundLayer.id];v=Math.max(v,w),o[x.outboundLayer.id]=v,s[x.outboundLayer.id]=x.outboundLayer,e[x.id]=v;for(let S=0;S<x.inboundLayers.length;S++){let k=x.inboundLayers[S],A=x.nodeIndices[S],_=k.inboundNodes[A],F=e[_.id]==null?0:e[_.id];e[_.id]=Math.max(v+1,F),r[_.id]=_}}let f={};for(let x in e){let v=e[x];v in f||(f[v]=[]),f[v].push(r[x])}let d={};for(let x in o){let v=o[x];v in d||(d[v]=[]),d[v].push(s[x])}let h=Object.keys(d).map(x=>parseInt(x,10)).sort(Om);this.layers=[];for(let x of h){let v=d[x];v.sort((w,S)=>{let k=i[w.id],A=i[S.id];return k<A?-1:k>A?1:0});for(let w of v)w instanceof n&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,h=Object.keys(f).map(x=>parseInt(x,10)).sort(Om);let g=this.inputs.slice(),m=[];for(let x of h)for(let v of f[x]){let w=v.outboundLayer;if(w!=null){for(let S of v.inputTensors)if(g.indexOf(S)===-1)throw new ar(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${w.name}". The following previous layers were accessed without issue: ${m}`);for(let S of v.outputTensors)g.push(S);m.push(w.name)}}this.nodesByDepth=f;let y=this.layers.map(x=>x.name);for(let x of y){let v=y.filter(w=>w===x).length;if(v!==1)throw new ar(`The name "${x}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ia({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new P("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let r={},o=0,s=Zre(t);s&&this.parseWeights(t);for(let a of this.layers)for(let[l,u]of a.weights.entries()){let c=s?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new P(`Duplicate weight name: ${c}`);r[c]=u,o++}let i=[];for(let a in t){let l=a;if(r[a]==null){let u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[a]]);else if(e)throw new P(`Provided weight data has no target variable: ${a}`);delete r[l]}if(e){let a=[];for(let l in r)a.push(l);if(a.length>0)throw new P(`${a.length} of ${o} weights are not set: ${a}`)}Md(i)}parseWeights(t){for(let e in Object.keys(t)){let r=e.split("/"),o=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!o.includes(i)).join("/");s!==e&&(t[s]=t[e],delete t[e])}}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Pd}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let r=iv(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return B(()=>{t=rt(t);let r=new $s;for(let o=0;o<this.inputs.length;++o)r.add(this.inputs[o],t[o]);return Cc(this.outputs,r,e)})}computeMask(t,e){return B(()=>{t=rt(t);let r;return e==null?r=Io(null,t.length):r=rt(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let e=_d(t);if(e.length!==this.inputLayers.length)throw new P(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let a=0;a<e.length;a++){let l=this.inputLayers[a],u=e[a],c=l.name+"_0_0";r[c]=u}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Om);if(o.length>1)for(let a of o){let l=this.nodesByDepth[a];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(c.id)!==-1)continue;let p=[];for(let g=0;g<u.inboundLayers.length;g++){let m=u.inboundLayers[g],y=u.nodeIndices[g],x=u.tensorIndices[g],v=`${m.name}_${y}_${x}`,w=r[v];p.push(w)}let f=c.computeOutputShape(In(p)),d=_d(f),h=c.inboundNodes.indexOf(u);for(let g=0;g<d.length;g++){let m=`${c.name}_${h}_${g}`;r[m]=d[g]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${l.name}_${u}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let l=i[a];ro(l in r),s.push(r[l])}return In(s)}runInternalGraph(t,e){e==null&&(e=Io(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],p=e[l];r[u.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Om);for(let l of o){let u=this.nodesByDepth[l];for(let c of u){let p=c.outboundLayer,f=c.inputTensors,d=c.outputTensors,h=new Array;for(let g of f)g.id in r&&h.push(r[g.id]);if(h.length===f.length){let g={},m,y,x,v;if(c.callArgs!=null&&(g=c.callArgs),h.length===1){let[w,S]=h[0];g.mask==null&&(g.mask=S),x=rt(p.call(w,g)),v=rt(p.computeMask(w,S)),m=[w],y=[S]}else m=h.map(w=>w[0]),y=h.map(w=>w[1]),g.mask==null&&(g.mask=y),x=rt(p.call(m,g)),v=rt(p.computeMask(m,y));if(p.activityRegularizer)throw new ve("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){let S=d[w],k=x[w],A=v[w];r[S.id]=[k,A]}}}}let s=[],i=[],a=[];for(let l of this.outputs){ro(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];a.push(u.shape),s.push(u),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},r;for(let o of this.layers){r=o instanceof n?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=n.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new P("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new P(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new P(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return B(()=>{let t=[];for(let e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){let o=n.nodeKey(e,r);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let a=i.getClassName(),l=i.getConfig(),u=[];for(let p=0;p<i.inboundNodes.length;p++){let f=i.inboundNodes[p],d=n.nodeKey(i,p),h={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),h=f.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(f.inboundLayers.length>0){let g=[];for(let m=0;m<f.inboundLayers.length;m++){let y=f.inboundLayers[m],x=f.nodeIndices[m],v=f.tensorIndices[m],w=n.nodeKey(y,x),S=e[w];S==null&&(S=0),g.push([y.name,S,v,h])}u.push(g)}}}let c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=n.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=n.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=e[u];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,r={},o=!1){let s={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){let x=[],v;for(let w of y){let S=w[0],k=w[1],A=w[2];if(v=w[3]==null?{}:w[3],!(S in s)){a(m,y);return}let _=s[S];if(_.inboundNodes.length<=k){a(m,y);return}let F=_.inboundNodes[k];x.push(F.outputTensors[A])}x.length>0&&m.apply(In(x),v)}function u(m){let y=m.name,x=Lr(m,e.customObjects!=null?e.customObjects:{});x.setFastWeightInitDuringBuild(o),s[y]=x,m.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new P(`Corrupted configuration, expected array for nodeData: ${w}`);a(x,w)})}let c=e.name,p=e.layers;for(let m of p)u(m);for(;!tP(i);)for(let m of p){let y=s[m.name];if(y.name in i){let x=i[y.name];delete i[y.name];for(let v of x)l(y,v)}}let f=[],d=[],h=e.inputLayers;for(let m of h){let y=m[0],x=m[1],v=m[2];ro(y in s);let S=s[y].inboundNodes[x].outputTensors;f.push(S[v])}let g=e.outputLayers;for(let m of g){let y=m[0],x=m[1],v=m[2];ro(y in s);let S=s[y].inboundNodes[x].outputTensors;d.push(S[v])}return new t({inputs:f,outputs:d,name:c})}get stateful(){if(this._stateful)throw new P("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Qre(n,t,e){let r=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(o=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){let o=[];return t.forEach(s=>{s in n?o.push(n[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function lv(n,t){return Qre(n,t,"classWeight")}function uv(n,t,e,r){return z(this,null,function*(){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=B(()=>{if(n.shape.length===1)return or(n);if(n.shape.length===2){if(n.shape[1]>1)return Ts(n,1);if(n.shape[1]===1)return O(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield o.data());Se(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Bt(i,"float32")}else return null})}function KP(n,t){return R(n,t)}var Jre=32;function ZP(n,t){let e,r,o=t;e=o.xs,r=o.ys,b.assert(e!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=XP("input",n.inputNames,e),i=XP("output",n.outputNames,r),a=s[0].shape[0];b.assert(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),b.assert(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<s.length;l++)b.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)b.assert(i[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:s,ys:i}}function XP(n,t,e){if(e instanceof Ke)return[e];if(Array.isArray(e))return b.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{let r=[];for(let o of t){if(e[o]==null)throw new P(`The feature data generated by the dataset lacks the required ${n} key '${o}'.`);r.push(e[o])}return r}}function eoe(n){if(n.length===3)throw new ve("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function QP(n,t,e){return z(this,null,function*(){let r=e.batchesPerEpoch!=null;if(b.assert(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),b.assert(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),b.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(YP(e.validationData))b.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let m=eoe(e.validationData);s=m.xs,i=m.ys}let a=n.makeTrainFunction(),l=n.getDedupedMetricsNames(),u;o?u=l.slice().concat(l.map(m=>"val_"+m)):u=l.slice();let c=Zb(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:f,history:d}=Qb(c,p,e.epochs,null,null,toe(t,e),null,o,u);f.setModel(n),n.history=d,yield f.onTrainBegin(),n.stopTraining_=!1;let h=e.initialEpoch==null?0:e.initialEpoch,g=yield t.iterator();for(;h<e.epochs;){let m={};yield f.onEpochBegin(h);let y=0,x=0;for(r||(g=yield t.iterator());!r||y<e.batchesPerEpoch;){let v=yield g.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){let{xs:w,ys:S}=ZP(n,v.value),k={};k.batch=x,k.size=w[0].shape[0],yield f.onBatchBegin(x,k);let A=[];if(e.classWeight!=null){let $=lv(e.classWeight,n.outputNames);for(let V=0;V<$.length;++V)A.push(yield uv(S[V],null,$[V]))}let _=w.concat(S).concat(A),F=a(_);Se(_);for(let $=0;$<l.length;++$){let V=l[$],U=F[$];k[V]=U,Et(U)}yield f.onBatchEnd(x,k),qb(k),x++,y++}if(r?y>=e.batchesPerEpoch:v.done){if(o){let w;YP(e.validationData)?w=rt(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):w=rt(n.evaluate(s,i,{batchSize:e.validationBatchSize==null?Jre:e.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)m[`val_${n.metricsNames[S]}`]=w[S]}break}if(n.stopTraining_)break}if(yield f.onEpochEnd(h,m),h++,n.stopTraining_)break}return yield f.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})}function toe(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function YP(n){return typeof n.iterator=="function"}function noe(n){return typeof n.next=="function"}function JP(n,t,e){return z(this,null,function*(){e=e||{};let r=e.batches!=null,o=n.testFunction,s=[];if(e.verbose>0)throw new ve("Verbose mode is not implemented yet.");b.assert(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=noe(t)?t:yield t.iterator(),a=0,l=0;for(;!r||l<e.batches;){let u=yield i.next();if(s=B(()=>{if(u.value){let{xs:c,ys:p}=ZP(n,u.value),f=c.concat(p),d=B(()=>o(f));if(Se(f),l===0)for(let g=0;g<d.length;++g)s.push(se(0));let h=f[0].shape[0];for(let g=0;g<d.length;++g){let m=d[g],y=s[g];s[g]=B(()=>j(s[g],R(h,m))),l>0&&Se(y)}Se(d),a+=h,++l}return s}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let c=s[u];s[u]=ne(s[u],a),Se(c)}return In(s)})}function cv(n){b.assert(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Ld(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(r=>oa(r,t,e-t)):oa(n,t,e-t)}function pv(n,t){return B(()=>n==null?null:Array.isArray(n)?n.map(e=>pv(e,t)):Vb(n,t.dtype==="int32"?t:Y(t,"int32")))}function fv(n,t){let e=[],r=0,o=null;for(;r<n;)o=r+t,o>=n&&(o=n),e.push([r,o]),r=o;return e}function MN(n){let t=[];n instanceof Ke&&(n=[n]);for(let e=0;e<n.length;++e){let r=n[e];if(r.rank===1)t.push(sa(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Do(n,t){if(n==null)return;let e=[];if(t instanceof Ke)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let r=[];if(n instanceof Ke)e.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(o=>{e.indexOf(o.id)===-1&&r.push(o)});else if(n!=null)for(let o in n){let s=n[o];e.indexOf(s.id)===-1&&r.push(s)}r.forEach(o=>{o.isDisposed||o.dispose()})}function roe(n){return n instanceof Ke}function FN(n){return Array.isArray(n)}function eL(n){return!roe(n)&&!FN(n)}function tL(n,t,e,r=!0,o=""){if(t==null||t.length===0){if(n!=null){let i=!1;if(FN(n)&&n.length>0)i=!0;else if(eL(n)){for(let a in n)if(n.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new P(`Error when checking model ${o} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(i=>null);let s;if(eL(n)){n=n,s=[];for(let i of t){if(n[i]==null)throw new P(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(n[i])}}else if(FN(n)){if(n=n,n.length!==t.length)throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(n=n,t.length>1)throw new P(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=MN(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new P(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c>=0&&u!==c)throw new P(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function ooe(n,t,e){let r=To(n.map(s=>s.shape[0]));r.sort();let o=To(t.map(s=>s.shape[0]));if(o.sort(),r.length>1)throw new P(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(o.length>1)throw new P(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&o.length>0&&!b.arraysEqual(r,o))throw new P(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${o[0]} target sample(s).`)}function soe(n,t,e){let r=[Sc,$d,Tc];for(let o=0;o<n.length;++o){let s=n[o],i=t[o],a=e[o];if(i!=null){if(i===Tc&&s.shape[s.shape.length-1]===1)throw new P(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){let p=l[c],f=u[c];if(f!=null&&p!==f)throw new P(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function nL(n,t,e,r=!0,o=""){let s;if(Array.isArray(n)){if(n.length!==t.length)throw new P(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(t.length>1)throw new P(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new P(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let u=a.shape[l],c=e[i][l];if(c!=null&&c!==u)throw new P(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function ioe(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(r=>e);{let r=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var aoe="layers-model",la=(()=>{class n extends av{constructor(e){super(e),this.isTraining=!1}summary(e,r,o=console.log){if(!this.built)throw new P("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");HP(this,e,r,o)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=jP(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Vn))throw new P("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new P(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(ev(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new P(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>ev(l))}else{let a=ev(e.loss);this.outputs.forEach(l=>{r.push(a)})}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let l=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}let o=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Qo("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=ioe(e.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};Qo("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=s[a];(c=>{let p="",f,d,h;for(let g of c){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){let y=this.internalOutputShapes[a];y[y.length-1]===1||this.lossFunctions[a]===$d?["accuracy","acc"].indexOf(g)!==-1?d=nv:["crossentropy","ce"].indexOf(g)!==-1&&(d=kN):this.lossFunctions[a]===Fd?["accuracy","acc"].indexOf(g)!==-1?d=AN:["crossentropy","ce"].indexOf(g)!==-1&&(d=RN):["accuracy","acc"].indexOf(g)!==-1?d=rv:["crossentropy","ce"].indexOf(g)!==-1&&(d=ov);let x;["accuracy","acc"].indexOf(g)!==-1?x="acc":["crossentropy","ce"].indexOf(g)!==-1&&(x="ce"),h=d,f=p+x}else h=GP(g),f=p+Um(g);let m;Qo(f,()=>{m=h}),i(a,f,m)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,o={}){let s=o.batchSize==null?32:o.batchSize;cv(s);let a=this.standardizeUserDataXY(e,r,!0,s);try{let l=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,c=this.testLoop(u,l,s,o.verbose,o.steps);return In(c)}finally{Do(a[0],e),Do(a[1],r)}}evaluateDataset(e,r){return z(this,null,function*(){return this.makeTestFunction(),JP(this,e,r)})}checkNumSamples(e,r,o,s="steps"){let i;if(o!=null){if(i=null,r!=null)throw new P(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new P(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,r){if(Array.isArray(r)&&r.length===0)throw new P("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(r),s=o?r:[r],i=this.retrieveSymbolicTensors(s),a=new $s;if(e instanceof Ke&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new P(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(let u of this.inputs){let c=e[u.name];if(c==null)throw new P(`No value is provided for the model's input ${u.name}`);a.add(u,c)}let l=Cc(i,a);return o?l:l[0]}retrieveSymbolicTensors(e){let r=Io(null,e.length),o=e.length;for(let s of this.layers){let i=Array.isArray(s.output)?s.output:[s.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){let u=a.indexOf(e[l]);if(u!==-1&&(r[l]=i[u],o--),o===0)break}if(o===0)break}if(o>0){let s=[];throw r.forEach((i,a)=>{i==null&&s.push(e[a])}),new P(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,o=!1){return B(()=>{let s=this.checkNumSamples(e);if(o)throw new ve("Verbose predictLoop() is not implemented yet.");let i=fv(s,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)B(()=>{let c=i[l][0],p=i[l][1],f=Ld(e,c,p),d=[];if(Array.isArray(f))for(let g=0;g<f.length;++g)d.push({key:this.inputs[g],value:f[g]});else d.push({key:this.inputs[0],value:f});let h=new $s(d);return Cc(this.outputs,h)}).forEach((c,p)=>a[p].push(c));return In(a.map(l=>Je(l,0)))})}predict(e,r={}){let o=MN(e);nL(o,this.inputNames,this.feedInputShapes,!1);try{let s=r.batchSize==null?32:r.batchSize;return cv(s),this.predictLoop(o,s)}finally{Do(o,e)}}predictOnBatch(e){nL(e,this.inputNames,this.feedInputShapes,!0);let r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,o=!0,s){if(this.optimizer_==null)throw new ar("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let a=0;a<this.feedOutputShapes.length;++a){let l=this.feedOutputShapes[a];this.feedLossFns[a]===Fd?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=tL(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=tL(r,this.feedOutputNames,i,!1,"target"),ooe(e,r,null),soe(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new P(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,o,s,i=!0,a){return z(this,null,function*(){let[l,u]=this.standardizeUserDataXY(e,r,i,a);if(o!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){let p=lv(s,this.outputNames);c=[];for(let f=0;f<p.length;++f)c.push(yield uv(u[f],null,p[f]))}return[l,u,c]})}testLoop(e,r,o,s=0,i){return B(()=>{let a=this.checkNumSamples(r,o,i,"steps"),l=[];if(s>0)throw new ve("Verbose mode is not implemented yet.");if(i!=null)throw new ve("steps mode in testLoop() is not implemented yet");{let u=fv(a,o),c=Bt(ur(0,a));for(let p=0;p<u.length;++p){let f=u[p][0],d=u[p][1],h=oa(c,f,d-f),g=pv(r,h),m=e(g);if(p===0)for(let y=0;y<m.length;++y)l.push(se(0));for(let y=0;y<m.length;++y){let x=m[y];l[y]=j(l[y],R(d-f,x))}}for(let p=0;p<l.length;++p)l[p]=ne(l[p],a)}return l})}getDedupedMetricsNames(){let e=this.metricsNames,r=[];for(let o=0;o<e.length;++o){let s=e[o],i=s;if(dN(e,s)>1){let a=dN(e.slice(0,o),s);i+=`_${a}`}r.push(i)}return r}makeTrainFunction(){return e=>{let r=[],o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],l=()=>{let f=[];for(let m=0;m<this.inputs.length;++m)f.push({key:this.inputs[m],value:o[m]});let d=new $s(f),h=Cc(this.outputs,d,{training:!0}),g;for(let m=0;m<this.lossFunctions.length;++m){let y=this.lossFunctions[m],x=y(s[m],h[m]);i[m]!=null&&(x=KP(x,i[m]));let v=wt(x);r.push(v),m===0?g=x:g=j(g,x)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{let x=this.metricsTensors[m][0],v=this.metricsTensors[m][1];y=wt(x(s[v],h[v]))}Et(y),a.push(y)}return g=wt(g),this.calculateLosses().forEach(m=>{g=j(g,m)}),g},u=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(l,!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>B(()=>{let r=[],o,s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:s[c]});let l=new $s(a),u=Cc(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){let p=this.lossFunctions[c],f=wt(p(i[c],u[c]));c===0?o=f:o=j(o,f),r.push(o)}for(let c=0;c<this.metricsTensors.length;++c){let p=this.metricsTensors[c][0],f=this.metricsTensors[c][1],d=wt(p(i[f],u[f]));r.push(d)}return r})}fit(s,i){return z(this,arguments,function*(e,r,o={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,l,u,c,p,f,d,h,g;try{let m=o.batchSize==null?32:o.batchSize;cv(m);let x=yield this.standardizeUserData(e,r,o.sampleWeight,o.classWeight,!1,m);a=x[0],l=x[1],g=x[2];let v=!1,w;if(o.validationData!=null&&o.validationData.length>0){if(v=!0,o.validationData.length===2)p=o.validationData[0],f=o.validationData[1];else throw o.validationData.length===3?new ve("validationData including sample weights is not supported yet."):new P(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);let W=yield this.standardizeUserData(p,f,null,null,!0,m);d=W[0],h=W[1],w=d.concat(h)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){v=!0;let U=Math.floor(a[0].shape[0]*(1-o.validationSplit)),W=a[0].shape[0];d=Ld(a,U,W),u=a,a=Ld(a,0,U),h=Ld(l,U,W),c=l,l=Ld(l,0,U),w=d.concat(h)}else o.validationSteps!=null&&(v=!0);let S=a.concat(l).concat(g);this.checkTrainableWeightsConsistency();let k=this.makeTrainFunction(),A=this.getDedupedMetricsNames(),_,F;v?(this.makeTestFunction(),_=this.testFunction,F=A.slice().concat(A.map(U=>"val_"+U))):(_=null,w=[],F=A.slice());let $=Zb(o.callbacks,o.yieldEvery);return yield this.fitLoop(k,S,A,m,o.epochs,o.verbose,$,_,w,o.shuffle,F,o.initialEpoch,null,null)}finally{this.isTraining=!1,Do(a,e),Do(l,r),Do(u,e),Do(c,r),Do(d,p),Do(h,f),g!=null&&Se(g)}})}fitLoop(e,r,o,s,i,a,l,u,c,p,f,d,h,g){return z(this,null,function*(){s==null&&(s=32),i==null&&(i=1),p==null&&(p=!0),d==null&&(d=0);let m=!1;if(u!=null&&c!=null&&(m=!0),g!=null&&(m=!0,h==null))throw new P("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y=this.checkNumSamples(r,s,h,"steps_per_epoch"),x;y!=null&&(x=ur(0,y)),a==null&&(a=1);let{callbackList:v,history:w}=Qb(l,a,i,d,y,h,s,m,f);v.setModel(this),this.history=w,yield v.onTrainBegin(),this.stopTraining_=!1;for(let S=d;S<i;++S){yield v.onEpochBegin(S);let k={};if(h!=null)throw new ve("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new ve("batch shuffling is not implemneted yet");p&&b.shuffle(x);let A=Bt(x),_=fv(y,s);for(let F=0;F<_.length;++F){let $={};if(yield v.onBatchBegin(F,$),B(()=>{let V=_[F][0],U=_[F][1],W=oa(A,V,U-V);$.batch=F,$.size=U-V;let G=pv(r,W),H=e(G);for(let K=0;K<o.length;++K){let Q=o[K],X=H[K];$[Q]=X,Et(X)}if(F===_.length-1&&m){let K=this.testLoop(u,c,s);for(let Q=0;Q<o.length;++Q){let X=o[Q],J=K[Q];Et(J),k["val_"+X]=J}}}),yield v.onBatchEnd(F,$),qb($),this.stopTraining_)break}A.dispose()}if(yield v.onEpochEnd(S,k),this.stopTraining_)break}return yield v.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(e,r){return z(this,null,function*(){return QP(this,e,r)})}trainOnBatch(e,r){return z(this,null,function*(){let o=yield this.standardizeUserData(e,r),s=o[0],i=o[1],l=this.makeTrainFunction()(s.concat(i)),u=[];for(let c of l){let p=yield c.data();u.push(p[0])}return Se(l),Do(o[0],e),Do(o[1],r),In(u)})}getNamedWeights(e){let r=[],o=e!=null&&e.trainableOnly,s=o?this.trainableWeights:this.weights,i=this.getWeights(o);for(let a=0;a<s.length;++a)o&&!s[a].trainable||r.push({name:s[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let r=xm().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-xm().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=So(this.loss);else if(Array.isArray(this.loss)){for(let r of this.loss)if(typeof r!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>So(r))}else{let r=Object.keys(this.loss);e={};let o=this.loss;for(let s of r)if(typeof o[s]=="string")e[s]=So(o[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[So(Um(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>So(Um(e)));{let e={};for(let r in this.metrics)e[r]=So(Um(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let r=Gm(e.optimizer_config),o=Lr(r),s;if(typeof e.loss=="string")s=ra(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>ra(a));else if(e.loss!=null){s={};for(let a in e.loss)s[a]=ra(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>ra(a));else if(e.metrics!=null){i={};for(let a in e.metrics)i[a]=ra(e.metrics[a])}this.compile({loss:s,metrics:i,optimizer:o})}save(e,r){return z(this,null,function*(){if(typeof e=="string"){let c=Yo.getSaveHandlers(e);if(c.length===0)throw new P(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new P(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new P("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=yield Yo.encodeWeights(this.getNamedWeights(r)),l={modelTopology:this.toJSON(null,!1),format:aoe,generatedBy:`TensorFlow.js tfjs-layers v${Pd}`,convertedBy:null};if((r==null?!1:r.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();let c="optimizer",{data:p,specs:f}=yield Yo.encodeWeights(yield this.optimizer.getWeights(),c);o.specs.push(...f),o.data=Yo.concatenateArrayBuffers([o.data,p])}return this.userDefinedMetadata!=null&&(ON(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=o.data,l.weightSpecs=o.specs,e.save(l)})}setUserDefinedMetadata(e){ON(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();q.registerClass(la);var loe=(()=>{class n extends la{}return n.className="Functional",n})();q.registerClass(loe);var $N=(()=>{class n extends la{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Wl("sequential_"),e.layers!=null)for(let r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new P(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let r=e instanceof n||e instanceof la,o;if(r){if(o=e,o.outputs.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new P("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new P("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=NN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=o.outputs,this.inputs=o.inputs;else{if(e.inboundNodes.length!==1)throw new P(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=TN(this.outputs[0])}this.inboundNodes=[],new ia({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Io(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return this.model==null&&this.build(),this.model.call(e,r)}build(e){if(Re(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new la({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,o=console.log){this.built||this.build(),super.summary(e,r,o)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,r,o={}){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.evaluate(e,r,o)}evaluateDataset(e,r){return z(this,null,function*(){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,r)})}predict(e,r={}){return this.model==null&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(s,i){return z(this,arguments,function*(e,r,o={}){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.fit(e,r,o)})}fitDataset(e,r){return z(this,null,function*(){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.fitDataset(e,r)})}trainOnBatch(e,r){return z(this,null,function*(){return this.model.trainOnBatch(e,r)})}static fromConfig(e,r,o={},s=!1){let i,a={};if(r instanceof Array){if(r[0].className==null||r[0].className==="Merge")throw new P("Legacy serialization format not supported yet.");i=r}else b.assert(r.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;let l=new e(a);if(!(l instanceof n))throw new ve(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(let u of i){let p=Lr(u,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),l.add(p)}return l}set stopTraining(e){if(this.model==null)throw new P("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new P("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let r of this.layers){let o={};o.className=r.getClassName(),o.config=r.getConfig(),e.push(o)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();q.registerClass($N);var On=class extends q.Serializable{getConfig(){return{}}},coe=(()=>{class n extends On{apply(e,r=1){return gP(e,r)}}return n.className="elu",n})();q.registerClass(coe);var poe=(()=>{class n extends On{apply(e){return pd(e)}}return n.className="selu",n})();q.registerClass(poe);var foe=(()=>{class n extends On{apply(e){return _n(e)}}return n.className="relu",n})();q.registerClass(foe);var doe=(()=>{class n extends On{apply(e){return B(()=>to(6,_n(e)))}}return n.className="relu6",n})();q.registerClass(doe);var hoe=(()=>{class n extends On{apply(e){return e}}return n.className="linear",n})();q.registerClass(hoe);var moe=(()=>{class n extends On{apply(e){return Xn(e)}}return n.className="sigmoid",n})();q.registerClass(moe);var goe=(()=>{class n extends On{apply(e){return xP(e)}}return n.className="hardSigmoid",n})();q.registerClass(goe);var yoe=(()=>{class n extends On{apply(e){return Ko(e)}}return n.className="softplus",n})();q.registerClass(yoe);var xoe=(()=>{class n extends On{apply(e){return yP(e)}}return n.className="softsign",n})();q.registerClass(xoe);var boe=(()=>{class n extends On{apply(e){return qo(e)}}return n.className="tanh",n})();q.registerClass(boe);var LN=(()=>{class n extends On{apply(e,r=-1){return Bl(e,r)}}return n.className="softmax",n})();q.registerClass(LN);var voe=(()=>{class n extends On{apply(e,r=-1){return id(e,r)}}return n.className="logSoftmax",n})();q.registerClass(voe);var woe=(()=>{class n extends On{apply(e){return B(()=>B(()=>{let r=Math.sqrt(2),o=R(.5,j(1,sd(ne(e,r))));return R(e,o)}))}}return n.className="gelu",n})();q.registerClass(woe);var Coe=(()=>{class n extends On{apply(e){return B(()=>R(.5,R(e,j(1,qo(R(pt(ne(2,Math.PI)),j(e,R(.044715,Ln(e,3)))))))))}}return n.className="gelu_new",n})();q.registerClass(Coe);var Ioe=(()=>{class n extends On{apply(e){return B(()=>R(e,qo(Ko(e))))}}return n.className="mish",n})();q.registerClass(Ioe);var Soe=(()=>{class n extends On{apply(e,r=1){return B(()=>R(Xn(R(e,r)),e))}}return n.className="swish",n})();q.registerClass(Soe);function es(n){return n.getClassName()}function PN(n,t={}){return Ms(n,q.SerializationMap.getMap().classNameMap,t,"activation")}function ts(n){if(n==null){let t={};return t.className="linear",t.config={},PN(t)}if(typeof n=="string"){let t={};return t.className=n,t.config={},PN(t)}else return n instanceof On?n:PN(n)}function Toe(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}var dv=class extends q.Serializable{},sL=(()=>{class n extends dv{constructor(e){super(),Toe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let r=nt([1]);return this.hasL1&&(r=j(r,ie(R(this.l1,Tt(e))))),this.hasL2&&(r=j(r,ie(R(this.l2,vc(e))))),O(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})();q.registerClass(sL);var rL={l1l2:"L1L2"};function at(n){return Dd(n)}function oL(n,t={}){return Ms(n,q.SerializationMap.getMap().classNameMap,t,"regularizer")}function gt(n){if(n==null)return null;if(typeof n=="string"){let e={className:n in rL?rL[n]:n,config:{}};return oL(e)}else return n instanceof dv?n:oL(n)}var iL=(()=>{class n extends we{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,r){e=xe(e);let o=_n(e);return this.maxValue!=null&&(o=bn(o,0,this.maxValue)),o}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})();q.registerClass(iL);var aL=(()=>{class n extends we{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=xe(e);return _l(o,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})();q.registerClass(aL);var lL=(()=>{class n extends we{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ft(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=gt(e.alphaRegularizer),this.alphaConstraint=Vt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new P(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Re(e);let r=e.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)o[s]=e[s];this.inputSpec=[new mt({ndim:e.length,axes:o})],this.built=!0}call(e,r){return e=xe(e),Ll(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Ct(this.alphaInitializer),alphaRegularizer:at(this.alphaRegularizer),alphaConstraint:zt(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})();q.registerClass(lL);var uL=(()=>{class n extends we{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ve(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=xe(e);return As(o)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})();q.registerClass(uL);var cL=(()=>{class n extends we{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,r){let o=xe(e);return R(o,Y($t(o,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})();q.registerClass(cL);var pL=(()=>{class n extends we{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new LN().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,r){return B(()=>{let o=xe(e),s=r.mask;if(s!=null){let i=R(te(Pt(o.shape),Y(s,o.dtype)),se(-1e9));o=j(o,i)}return this.axis instanceof Array?this.axis.length>1?Ht(te(o,Ml(o,this.axis,!0))):this.softmax(o,this.axis[0]):this.softmax(o,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})();q.registerClass(pL);function ql(n,t,e){if(typeof n=="number")return Io(n,t);if(n.length!==t)throw new P(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){let o=n[r];if(!fP(o))throw new P(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`)}return n}function Ir(n,t,e,r,o=1){if(n==null)return n;let s=t+(t-1)*(o-1),i;return e==="same"?i=n:i=n-s+1,Math.floor((i+r-1)/r)}function ns(n,t,e,r){if(n==null)return null;if(r==="valid")n=n*t+Jo([e-t,0]);else if(r==="same")n=n*t;else throw new P(`Unsupport padding mode: ${r}.`);return n}function jm(n,t){return B(()=>(kt(t),t==="channelsFirst"?Me(n,[0,2,3,1]):n))}function BN(n,t){return B(()=>(kt(t),t==="channelsFirst"?Me(n,[0,2,3,4,1]):n))}function Eoe(n,t,e,r=1,o="valid",s,i=1){return B(()=>{if(s==null&&(s=cr()),kt(s),n.shape.length!==3)throw new P(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new P(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new P(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(n=Me(n,[0,2,1])),o==="causal")throw new ve("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=ed(n,t,r,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=pr(a,e)),a})}function fL(n,t,e,r=[1,1],o="valid",s,i,a=null){return B(()=>{if(s==null&&(s=cr()),kt(s),n.rank!==3&&n.rank!==4)throw new P(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new P(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=jm(n,s);if(o==="causal")throw new ve("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Ul.conv2d({x:l,filter:t,strides:r,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(l=Me(l,[0,3,1,2])),l})}function Doe(n,t,e,r=[1,1,1],o="valid",s,i){return B(()=>{if(s==null&&(s=cr()),kt(s),n.rank!==4&&n.rank!==5)throw new P(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new P(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=BN(n,s);if(o==="causal")throw new ve("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Fx(a,t,r,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=pr(a,e)),s==="channelsFirst"&&(a=Me(a,[0,4,1,2,3])),a})}var Wm=class n extends we{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",n.verifyArgs(e),this.rank=t,Zt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ve(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ql(e.kernelSize,t,"kernelSize"),this.strides=ql(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,lr(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kt(this.dataFormat),this.activation=ts(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Vt(e.biasConstraint),this.biasRegularizer=gt(e.biasRegularizer),this.activityRegularizer=gt(e.activityRegularizer),this.dilationRate=ql(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new P(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new P(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new P(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ro("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Ob(t.kernelSize,"number",1,3))throw new P(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:es(this.activation),useBias:this.useBias,biasInitializer:Ct(this.biasInitializer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),biasConstraint:zt(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},Bd=class n extends Wm{constructor(t,e){super(t,e),this.kernel=null,n.verifyArgs(e),this.filters=e.filters,Zt(this.filters,"filters"),this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Vt(e.kernelConstraint),this.kernelRegularizer=gt(e.kernelRegularizer)}build(t){t=Re(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new P(`The channel dimension of the input should be defined. Found ${t[e]}`);let r=t[e],o=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return B(()=>{t=xe(t);let r,o=this.bias==null?null:this.bias.read(),s=Mb(this.activation.getClassName());if(s!=null&&this.rank===2)r=fL(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=Eoe(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=fL(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Doe(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ve("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Re(t);let e=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){let i=Ir(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Ct(this.kernelInitializer),kernelRegularizer:at(this.kernelRegularizer),kernelConstraint:zt(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new P(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},zN=(()=>{class n extends Bd{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Ob(e.kernelSize,"number",1,2))throw new P(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();q.registerClass(zN);var VN=(()=>{class n extends Bd{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new P(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();q.registerClass(VN);var dL=(()=>{class n extends zN{constructor(e){if(super(e),this.inputSpec=[new mt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Re(e),e.length!==4)throw new P("Input should have rank 4; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new mt({ndim:4,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{let o=xe(e);if(o.shape.length!==4)throw new P(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l;this.dataFormat==="channelsFirst"?(a=2,l=3):(a=1,l=2);let u=s[a],c=s[l],p=this.kernelSize[0],f=this.kernelSize[1],d=this.strides[0],h=this.strides[1],g=ns(u,d,p,this.padding),m=ns(c,h,f,this.padding),y=[i,g,m,this.filters];this.dataFormat!=="channelsLast"&&(o=Me(o,[0,2,3,1]));let x=nd(o,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=Me(x,[0,3,1,2])),this.bias!=null&&(x=pr(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Re(e);let r=e.slice(),o,s,i;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3):(o=3,s=1,i=2);let a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[o]=this.filters,r[s]=ns(r[s],u,a,this.padding),r[i]=ns(r[i],c,l,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})();q.registerClass(dL);var hL=(()=>{class n extends VN{constructor(e){if(super(e),this.inputSpec=[new mt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Re(e),e.length!==5)throw new P("Input should have rank 5; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new mt({ndim:5,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{let o=xe(e);if(o.shape.length!==5)throw new P(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l,u;this.dataFormat==="channelsFirst"?(u=2,a=3,l=4):(u=1,a=2,l=3);let c=s[u],p=s[a],f=s[l],d=this.kernelSize[0],h=this.kernelSize[1],g=this.kernelSize[2],m=this.strides[0],y=this.strides[1],x=this.strides[2],v=ns(c,m,d,this.padding),w=ns(p,y,h,this.padding),S=ns(f,x,g,this.padding),k=[i,v,w,S,this.filters];this.dataFormat!=="channelsLast"&&(o=Me(o,[0,2,3,4,1]));let A=Px(o,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=Me(A,[0,4,1,2,3])),this.bias!==null&&(A=pr(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=Re(e);let r=e.slice(),o,s,i,a;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3,a=4):(o=4,s=1,i=2,a=3);let l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],p=this.strides[0],f=this.strides[1],d=this.strides[2];return r[o]=this.filters,r[s]=ns(r[s],p,l,this.padding),r[i]=ns(r[i],f,u,this.padding),r[a]=ns(r[a],d,c,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})();q.registerClass(hL);var koe=(()=>{class n extends Bd{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,r.filters==null)throw new P("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(r.kernelInitializer!=null||r.kernelRegularizer!=null||r.kernelConstraint!=null)throw new P("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(r.padding!=null&&r.padding!=="same"&&r.padding!=="valid")throw new P(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier==null?1:r.depthMultiplier,this.depthwiseInitializer=ft(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=gt(r.depthwiseRegularizer),this.depthwiseConstraint=Vt(r.depthwiseConstraint),this.pointwiseInitializer=ft(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=gt(r.pointwiseRegularizer),this.pointwiseConstraint=Vt(r.pointwiseConstraint)}build(e){if(e=Re(e),e.length<this.rank+2)throw new P(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null||e[r]<0)throw new P(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);let o=e[r],s=this.kernelSize.concat([o,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(o*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new mt({ndim:this.rank+2,axes:{[r]:o}})],this.built=!0}call(e,r){return B(()=>{e=xe(e);let o;if(this.rank===1)throw new ve("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Me(e,[0,2,3,1])),o=fd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=pr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=Me(o,[0,3,1,2])),o})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ct(this.depthwiseInitializer),e.pointwiseInitializer=Ct(this.pointwiseInitializer),e.depthwiseRegularizer=at(this.depthwiseRegularizer),e.pointwiseRegularizer=at(this.pointwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseConstraint),e.pointwiseConstraint=zt(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();var mL=(()=>{class n extends koe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})();q.registerClass(mL);var gL=(()=>{class n extends Bd{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Ob(e.kernelSize,"number",1,1))throw new P(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})();q.registerClass(gL);var yL=(()=>{class n extends we{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return B(()=>{if(e=xe(e),this.dataFormat==="channelsLast"){let o=Fm(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Fm(o,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=Fm(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Fm(o,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})();q.registerClass(yL);var xL=(()=>{class n extends we{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,cP(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let r=e[2]==null?null:this.size[0]*e[2],o=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],r,o]}else{let r=e[1]==null?null:this.size[0]*e[1],o=e[2]==null?null:this.size[1]*e[2];return[e[0],r,o,e[3]]}}call(e,r){return B(()=>{let o=xe(e),s=o.shape;if(this.dataFormat==="channelsFirst"){o=Me(o,[0,2,3,1]);let i=this.size[0]*s[2],a=this.size[1]*s[3],l=this.interpolation==="nearest"?Cr.resizeNearestNeighbor(o,[i,a]):Cr.resizeBilinear(o,[i,a]);return Me(l,[0,3,1,2])}else{let i=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?Cr.resizeNearestNeighbor(o,[i,a]):Cr.resizeBilinear(o,[i,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})();q.registerClass(xL);function Aoe(n,t,e=[1,1],r="valid",o,s){return B(()=>{o==null&&(o=cr()),kt(o);let i=jm(n,o);if(n.rank!==4)throw new P(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new P(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=ks(i,t,e,r==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}var bL=(()=>{class n extends Wm{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ft(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Vt(e.depthwiseConstraint),this.depthwiseRegularizer=gt(e.depthwiseRegularizer)}build(e){if(e=Re(e),e.length<4)throw new P(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let r=this.dataFormat==="channelsFirst"?1:3;if(e[r]==null||e[r]<0)throw new P(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);let o=e[r],s=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{e=xe(e);let o=Aoe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=pr(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(e){e=Re(e);let r=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Ir(r,this.kernelSize[0],this.padding,this.strides[0]),a=Ir(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,a]:[e[0],i,a,s]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ct(this.depthwiseInitializer),e.depthwiseRegularizer=at(this.depthwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})();q.registerClass(bL);function UN(n,t,e,r){if(Array.isArray(n)){if(t!=null||e!=null)throw new P("When inputs is an array, neither initialState or constants should be provided");r!=null&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:n,initialState:t,constants:e}}function GN(n,t,e,r=!1,o,s,i=!1,a=!1){return B(()=>{let l=t.shape.length;if(l<3)throw new P(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(ur(2,l));if(t=Me(t,u),s!=null)throw new ve("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Y(Y(o,"bool"),"float32"),o.rank===l-1&&(o=Xt(o,-1)),o=Me(o,u)),r&&(t=un(t,0),o!=null&&(o=un(o,0)));let c=[],p,f=e,d=t.shape[0],h=pn(t),g;o!=null&&(g=pn(o));for(let y=0;y<d;++y){let x=h[y],v=B(()=>n(x,f));if(o==null)p=v[0],f=v[1];else{let w=B(()=>{let S=g[y],k=te(hn(S),S),A=j(R(v[0],S),R(f[0],k)),_=f.map((F,$)=>j(R(v[1][$],S),R(F,k)));return{output:A,newStates:_}});p=w.output,f=w.newStates}a&&c.push(p)}let m;return a&&(m=Lt(c,1)),[p,m,f]})}var Xl=(()=>{class n extends we{constructor(e){super(e);let r;if(e.cell==null)throw new P("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?r=new HN({cells:e.cell}):r=e.cell,r.stateSize==null)throw new P("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new mt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ur(0,e).map(r=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Wb(e)&&(e=e[0]),e=e;let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let o=r[0],s;if(this.returnSequences?s=[e[0],e[1],o]:s=[e[0],o],this.returnState){let i=[];for(let a of r)i.push([e[0],a]);return[s].concat(i)}else return s}computeMask(e,r){return B(()=>{Array.isArray(r)&&(r=r[0]);let o=this.returnSequences?r:null;if(this.returnState){let s=this.states.map(i=>null);return[o].concat(s)}else return o})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let o=0;o<e;++o)r.push(null);return r}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new ve("Constants support is not implemented in RNN yet.");Wb(e)&&(e=e[0]),e=e;let o=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new mt({shape:[o,null,...s]});let i=[e[0]].concat(e.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new P(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new mt({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new no("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>nt([o,s])):this.states_=[nt([o,this.cell.stateSize])];else if(e==null)Se(this.states_),this.keptStates!=null&&(Se(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>nt([o,s])):this.states_[0]=nt([o,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r===!0?this.keptStates.push(this.states_.slice()):Se(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[o,a];if(!b.arraysEqual(i.shape,l))throw new P(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Et(s.clone()))})}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=UN(e,o,s,this.numConstants);e=i.inputs,o=i.initialState,s=i.constants;let a=[],l=[];if(o!=null){r.initialState=o,a=a.concat(o),this.stateSpec=[];for(let c of o)this.stateSpec.push(new mt({shape:c.shape}));l=l.concat(this.stateSpec)}if(s!=null&&(r.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof Qn){let c=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(c,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return B(()=>{let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;e=xe(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new P(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let l={training:s},c=GN((g,m)=>{let y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,o,null,this.unroll,this.returnSequences),p=c[0],f=c[1],d=c[2];this.stateful&&this.resetStates(d,s);let h=this.returnSequences?f:p;return this.returnState?[h].concat(d):h})}getInitialState(e){return B(()=>{let r=nt(e.shape);return r=ie(r,[1,2]),r=sa(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?zb(r,[1,o]):r):this.cell.stateSize>1?[zb(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(r.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:o}),Object.assign(Object.assign(Object.assign({},o),e),r)}static fromConfig(e,r,o={}){let s=r.cell,i=Lr(s,o);return new e(Object.assign(r,{cell:i}))}}return n.className="RNN",n})();q.registerClass(Xl);var Kl=class extends we{},WN=(()=>{class n extends Kl{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gt(e.kernelRegularizer),this.recurrentRegularizer=gt(e.recurrentRegularizer),this.biasRegularizer=gt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=bc([1,Jo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=bc([1,Jo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Re(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{if(e=e,e.length!==2)throw new P(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let o=e[1];e=e[0];let s=r.training==null?!1:r.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ua({ones:()=>hn(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ua({ones:()=>hn(o),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,l=this.recurrentDropoutMask;a!=null?i=Eo(R(e,a),this.kernel.read()):i=Eo(e,this.kernel.read()),this.bias!=null&&(i=pr(i,this.bias.read())),l!=null&&(o=R(o,l));let u=j(i,Eo(o,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:es(this.activation),useBias:this.useBias,kernelInitializer:Ct(this.kernelInitializer),recurrentInitializer:Ct(this.recurrentInitializer),biasInitializer:Ct(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();q.registerClass(WN);var vL=(()=>{class n extends Xl{constructor(e){e.cell=new WN(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})();q.registerClass(vL);var jN=(()=>{class n extends Kl{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new P("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ts(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=gt(e.kernelRegularizer),this.recurrentRegularizer=gt(e.recurrentRegularizer),this.biasRegularizer=gt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=bc([1,Jo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=bc([1,Jo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Re(e);let r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return B(()=>{if(e=e,e.length!==2)throw new P(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training==null?!1:r.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ua({ones:()=>hn(e),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ua({ones:()=>hn(s),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,l,u,c;0<this.dropout&&this.dropout<1&&(e=R(e,i[0]));let p=Eo(e,this.kernel.read());this.useBias&&(p=pr(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=R(s,a[0]));let f=this.recurrentKernel.read(),[d,h]=cn(f,[2*this.units,this.units],f.rank-1),g=Eo(s,d),[m,y,x]=cn(p,3,p.rank-1),[v,w]=cn(g,2,g.rank-1);l=this.recurrentActivation.apply(j(m,v)),u=this.recurrentActivation.apply(j(y,w));let S=Eo(R(u,s),h);c=this.activation.apply(j(x,S));let k=j(R(l,s),R(j(1,Fe(l)),c));return[k,k]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:es(this.activation),recurrentActivation:es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ct(this.kernelInitializer),recurrentInitializer:Ct(this.recurrentInitializer),biasInitializer:Ct(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();q.registerClass(jN);var wL=(()=>{class n extends Xl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new jN(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return n.className="GRU",n})();q.registerClass(wL);var Hm=(()=>{class n extends Kl{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ts(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=gt(e.kernelRegularizer),this.recurrentRegularizer=gt(e.recurrentRegularizer),this.biasRegularizer=gt(e.biasRegularizer),this.kernelConstraint=Vt(e.kernelConstraint),this.recurrentConstraint=Vt(e.recurrentConstraint),this.biasConstraint=Vt(e.biasConstraint),this.dropout=bc([1,Jo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=bc([1,Jo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;e=Re(e);let o=e[e.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,a=this.units;s=new(r=class extends fr{apply(u,c){let p=i.apply([a]),f=new Gb().apply([a]),d=i.apply([a*2]);return xN(xN(p,f),d)}},r.className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return B(()=>{let o=r.training==null?!1:r.training;if(e=e,e.length!==3)throw new P(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ua({ones:()=>hn(e),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ua({ones:()=>hn(s),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,l=this.recurrentDropoutMask,u,c,p,f;0<this.dropout&&this.dropout<1&&(e=R(e,a[0]));let d=Eo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=R(s,l[0])),d=j(d,Eo(s,this.recurrentKernel.read())),this.useBias&&(d=pr(d,this.bias.read()));let[h,g,m,y]=cn(d,4,d.rank-1);u=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(g),p=j(R(c,i),R(u,this.activation.apply(m))),f=this.recurrentActivation.apply(y);let x=R(f,this.activation.apply(p));return[x,x,p]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:es(this.activation),recurrentActivation:es(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ct(this.kernelInitializer),recurrentInitializer:Ct(this.recurrentInitializer),biasInitializer:Ct(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();q.registerClass(Hm);var CL=(()=>{class n extends Xl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Hm(e),super(e)}call(e,r){return B(()=>{this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})();q.registerClass(CL);var HN=(()=>{class n extends Kl{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return B(()=>{e=e;let o=e.slice(1),s=[];for(let l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(o.splice(0,l.stateSize.length)):s.push(o.splice(0,1));s.reverse();let i=[],a;for(let l=0;l<this.cells.length;++l){let u=this.cells[l];o=s[l],l===0?a=[e[0]].concat(o):a=[a[0]].concat(o),a=u.call(a,r),i.push(a.slice(1))}o=[];for(let l of i.slice().reverse())o.push(...l);return[a[0]].concat(o)})}build(e){Wb(e)&&(e=e[0]),e=e;let r;this.cells.forEach((o,s)=>{Qo(`RNNCell_${s}`,()=>{o.build(e),Array.isArray(o.stateSize)?r=o.stateSize[0]:r=o.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){let e=super.getConfig(),r=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(r)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,o={}){let s=[];for(let i of r.cells)s.push(Lr(i,o));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){let r=[];for(let o of this.cells)r.push(...o.trainableWeights);return r.concat(e)}return e}getWeights(){let e=[];for(let r of this.cells)e.push(...r.weights);return Pm(e)}setWeights(e){let r=[];for(let o of this.cells){let s=o.weights.length,i=e.splice(s);for(let a=0;a<o.weights.length;++a)r.push([o.weights[a],i[a]])}Md(r)}}return n.className="StackedRNNCells",n})();q.registerClass(HN);function ua(n){let{ones:t,rate:e,training:r=!1,count:o=1,dropoutFunc:s}=n,i=()=>s!=null?s(t(),e):Ub(t(),e),a=()=>jl(i,t,r);return!o||o<=1?Et(a().clone()):Array(o).fill(void 0).map(a).map(u=>Et(u.clone()))}var Roe=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,r=Object.getOwnPropertySymbols(n);o<r.length;o++)t.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(n,r[o])&&(e[r[o]]=n[r[o]]);return e};var _oe=(()=>{class n extends Xl{constructor(e){if(e.unroll)throw new ve("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ve("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new mt({ndim:5})]}call(e,r){return B(()=>{if(this.cell.dropoutMask!=null&&(Se(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Se(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new P("ConvRNN2D cell does not support constants");let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return B(()=>{let{stateSize:r}=this.cell,o=e.shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)],a=nt(i);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new no("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)];if(o[0]==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>nt(i)):this.states_=[nt(i)];else if(e==null)Se(this.states_),this.keptStates!=null&&(Se(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>nt(i)):this.states_[0]=nt(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Se(this.states_);for(let l=0;l<this.states_.length;++l){let u=e[l],c=i;if(!b.arraysEqual(u.shape,c))throw new P(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>Et(l.clone()))})}computeSingleOutputShape(e){let{dataFormat:r,filters:o,kernelSize:s,padding:i,strides:a,dilationRate:l}=this.cell,u=r==="channelsFirst",c=e[u?3:2],p=e[u?4:3],f=Ir(c,s[0],i,a[0],l[0]),d=Ir(p,s[1],i,a[1],l[1]);return[...e.slice(0,2),...u?[o,f,d]:[f,d,o]]}}return n.className="ConvRNN2D",n})(),qN=(()=>{class n extends Hm{constructor(e){let{filters:r,kernelSize:o,strides:s,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Zt(this.filters,"filters"),this.kernelSize=ql(o,2,"kernelSize"),this.kernelSize.forEach(u=>Zt(u,"kernelSize")),this.strides=ql(s||1,2,"strides"),this.strides.forEach(u=>Zt(u,"strides")),this.padding=i||"valid",lr(this.padding),this.dataFormat=a||"channelsLast",kt(this.dataFormat),this.dilationRate=ql(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Zt(u,"dilationRate"))}build(e){var r;e=Re(e);let o=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[o]==null)throw new P(`The channel dimension of the input should be defined. Found ${e[o]}`);let s=e[o],i=4,a=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let c=this.biasInitializer,p=this.filters;u=new(r=class extends fr{apply(d,h){let g=c.apply([p]),m=Pt([p]),y=c.apply([p*2]);return Ad([g,m,y])}},r.className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return B(()=>{if(e.length!==3)throw new P(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training||!1,s=e[0],i=e[1],a=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ua({ones:()=>hn(s),rate:this.dropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,c=(oe,le,ae)=>!le||!le[ae]?oe:R(le[ae],oe),p=c(s,u,0),f=c(s,u,1),d=c(s,u,2),h=c(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ua({ones:()=>hn(i),rate:this.recurrentDropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,m=c(i,g,0),y=c(i,g,1),x=c(i,g,2),v=c(i,g,3),w=3,[S,k,A,_]=cn(this.kernel.read(),l,w),[F,$,V,U]=this.useBias?cn(this.bias.read(),l):[null,null,null,null];p=this.inputConv(p,S,F,this.padding),f=this.inputConv(f,k,$,this.padding),d=this.inputConv(d,A,V,this.padding),h=this.inputConv(h,_,U,this.padding);let[W,G,H,K]=cn(this.recurrentKernel.read(),l,w);m=this.recurrentConv(m,W),y=this.recurrentConv(y,G),x=this.recurrentConv(x,H),v=this.recurrentConv(v,K);let Q=this.recurrentActivation.apply(j(p,m)),X=this.recurrentActivation.apply(j(f,y)),J=j(R(X,a),R(Q,this.activation.apply(j(d,x)))),re=R(this.recurrentActivation.apply(j(h,v)),this.activation.apply(J));return[re,re,J]})}getConfig(){let e=super.getConfig(),{units:r}=e,o=Roe(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},o),s)}inputConv(e,r,o,s){let i=br(e,r,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?pr(i,o,this.dataFormat):i}recurrentConv(e,r){return br(e,r,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();q.registerClass(qN);var IL=(()=>{class n extends _oe{constructor(e){let r=new qN(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})();q.registerClass(IL);var KN=(()=>{class n extends we{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let r=e.shape,o=[];for(let s=0;s<this.noiseShape.length;++s)o.push(this.noiseShape[s]==null?r[s]:this.noiseShape[s]);return o}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);if(0<this.rate&&this.rate<1){let s=r.training==null?!1:r.training,i=this.getNoiseShape(o);return jl(()=>Ub(o,this.rate,i,this.seed),()=>o,s)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();q.registerClass(KN);var SL=(()=>{class n extends KN{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})();q.registerClass(SL);var TL=(()=>{class n extends we{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Zt(this.units,"units"),this.activation=ts(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Vt(e.kernelConstraint),this.biasConstraint=Vt(e.biasConstraint),this.kernelRegularizer=gt(e.kernelRegularizer),this.biasRegularizer=gt(e.biasRegularizer),this.activityRegularizer=gt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Re(e);let r=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){e=Re(e);let r=e.slice();return r[r.length-1]=this.units,r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),s=Mb(this.activation.getClassName()),i;return s!=null?i=Eo(o,this.kernel.read(),s,this.bias?this.bias.read():null):(i=Eo(o,this.kernel.read()),this.bias!=null&&(i=pr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let e={units:this.units,activation:es(this.activation),useBias:this.useBias,kernelInitializer:Ct(this.kernelInitializer),biasInitializer:Ct(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),biasConstraint:zt(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})();q.registerClass(TL);var NL=(()=>{class n extends we{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Re(e);for(let r of e.slice(1))if(r==null)throw new P(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],No(e,1)]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);if(this.dataFormat==="channelsFirst"&&o.rank>1){let s=[0];for(let i=2;i<o.rank;++i)s.push(i);s.push(1),o=Me(o,s)}return mP(o)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})();q.registerClass(NL);var EL=(()=>{class n extends we{constructor(e){super(e),this.supportsMasking=!0,this.activation=ts(e.activation)}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return this.activation.apply(o)})}getConfig(){let e={activation:es(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})();q.registerClass(EL);var DL=(()=>{class n extends we{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return B(()=>(e=xe(e),dP(e,this.n)))}getConfig(){let e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})();q.registerClass(DL);var kL=(()=>{class n extends we{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,r){let o="Total size of new array must be unchanged.",s=r.slice(),i=1,a=null;for(let u=0;u<s.length;++u){let c=s[u];if(this.isUnknown(c))if(a===null)a=u;else throw new P("Can only specifiy one unknown dimension.");else i*=c}let l=No(e);if(a!==null){if(i===0||l%i!==0)throw new P(o);s[a]=l/i}else if(l!==i)throw new P(o);return s}computeOutputShape(e){let r=!1;for(let o=0;o<e.length;++o)if(this.isUnknown(e[o])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),s=o.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return O(o,i)})}getConfig(){let e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})();q.registerClass(kL);var AL=(()=>{class n extends we{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let r=ur(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new mt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Re(e);let r=e.slice();return this.dims.forEach((o,s)=>{r[s+1]=e[o]}),r}call(e,r){return Me(xe(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})();q.registerClass(AL);var RL=(()=>{class n extends we{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){let o=xe(e);return oc(Xo(o,this.maskValue),-1)}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e),a=oc(Xo(o,this.maskValue),-1,!0);return R(o,Y(a,o.dtype))})}}return n.className="Masking",n})();q.registerClass(RL);var _L=(()=>{class n extends we{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let r=null;e.batchSize!=null&&(r=e.batchSize),e.inputLength==null?this.batchInputShape=[r,null]:this.batchInputShape=[r].concat(rt(e.inputLength))}this.inputDim=e.inputDim,Zt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Zt(this.outputDim,"outputDim"),this.embeddingsInitializer=ft(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=gt(e.embeddingsRegularizer),this.activityRegularizer=gt(e.activityRegularizer),this.embeddingsConstraint=Vt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return B(()=>this.maskZero?(e=xe(e),Xo(e,ye(e))):null)}computeOutputShape(e){if(e=Re(e),this.inputLength==null)return[...e,this.outputDim];let r=rt(this.inputLength);if(r.length!==e.length-1)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let o=0;for(let s=0;s<r.length;++s){let i=r[s],a=e[s+1];if(i!=null&&a!=null&&i!==a)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(r[o]=a),o++}}return[e[0],...r,this.outputDim]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);o.dtype!=="int32"&&(o=Zn(o,"int32"));let s=Vb(this.embeddings.read(),O(o,[o.size]));return O(s,Re(this.computeOutputShape(o.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ct(this.embeddingsInitializer),embeddingsRegularizer:at(this.embeddingsRegularizer),activityRegularizer:at(this.activityRegularizer),embeddingsConstraint:zt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})();q.registerClass(_L);var ca=class extends we{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new ve}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let r=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)r.push(null);else if(s===1)r.push(i);else if(i===1)r.push(s);else{if(s!==i)throw new P("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(s)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Re(t)]),t=t,t.length<2)throw new P(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=To(e),e.length>1)throw new P(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&To(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){let r=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=Jo(o);for(let i of t){let a=i.rank;for(let l=0;l<s-a;++l)i=sa(i,1);r.push(i)}return this.mergeFunction(r)}else{let s=!1;for(let l of t){let u=l.rank;if(u==null){let c=l.shape,p=c[0],f=c.slice(1).concat([p]),d=O(l,[p].concat(No(c.slice(1))));d=Me(d,[1,0]),d=O(d,f),r.push(d),s=!0}else if(u>1){let c=ur(1,u).concat([0]);r.push(Me(l,c)),s=!0}else r.push(l)}let i=this.mergeFunction(r),a=i.rank;if(s){if(a==null){let l=i.shape,u=l.length,c=l[u-1],p=[c].concat(l.slice(0,l.length-1));i=O(Me(O(i,[-1,c]),[1,0]),p)}else if(a>1){let l=[a-1].concat(ur(0,a-1));i=Me(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(let o of t)o!=null&&o[0]!==null&&r.push(o[0]);return r=To(r),r.length===1?e=r.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new P("`mask` should be an Array");if(!Array.isArray(t))throw new P("`inputs` should be an Array");if(e.length!==t.length)throw new P(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:Xt(o,0));let r=e[0];for(let o=1;o<e.length-1;++o)r=Bn(r,e[o]);return r})}},OL=(()=>{class n extends ca{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=j(r,e[o]);return r})}}return n.className="Add",n})();q.registerClass(OL);var ML=(()=>{class n extends ca{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=R(r,e[o]);return r})}}return n.className="Multiply",n})();q.registerClass(ML);var FL=(()=>{class n extends ca{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=j(r,e[o]);return R(1/e.length,r)})}}return n.className="Average",n})();q.registerClass(FL);var $L=(()=>{class n extends ca{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=wr(r,e[o]);return r})}}return n.className="Maximum",n})();q.registerClass($L);var PL=(()=>{class n extends ca{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=to(r,e[o]);return r})}}return n.className="Minimum",n})();q.registerClass(PL);var LL=(()=>{class n extends ca{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new P("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let r=!0;for(let s of e)if(s!=null){r=!1;break}if(r)return;let o=[];for(let s=0;s<e.length;++s){let i=e[s].slice();i.splice(this.axis,1);let a=!1;for(let l of o)if(b.arraysEqual(l,i)){a=!0;break}a||o.push(i)}if(o.length>1)throw new P("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>Ad(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new P("A `Concatenate` layer should be called on a list of inputs.");let r=e,o=r[0].slice(),s=this.axis<0?o.length+this.axis:this.axis;for(let i of r.slice(1)){if(o[s]==null||i[s]==null){o[s]=null;break}o[s]+=i[s]}return o}computeMask(e,r){if(r==null)return null;if(!Array.isArray(r))throw new P("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new P("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new P(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return B(()=>{let o=!0;if(r.forEach(a=>{if(a!=null){o=!1;return}}),o)return null;let s=[];for(let a=0;a<e.length;++a)r[a]==null?s.push(Y(hn(e[a]),"bool")):r[a].rank<e[a].rank?s.push(Xt(r[a],-1)):s.push(r[a]);let i=Je(s,this.axis);return Qf(i,-1,!1)})}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})();q.registerClass(LL);function qm(n,t){for(;n<0;)n+=t;return n}function Ooe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new ve("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),b.assert(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new ve("batchDot is not implemented for complex64-type Tensors yet.");let r=n.shape.length,o=t.shape.length;e==null&&(e=[r-1,o-2]);let s=e;return B(()=>{let i;if(r>o){i=r-o;let l=[];for(let u=0;u<i;++u)l.push(1);t=O(t,t.shape.concat(l))}else if(o>r){i=o-r;let l=[];for(let u=0;u<i;++u)l.push(1);n=O(n,n.shape.concat(l))}else i=0;let a;if(n.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=ie(R(n,t),s[0]):a=ie(R(Me(n,[1,0]),t),s[1]);else{let l=s[0]!==n.shape.length-1,u=s[1]===t.shape.length-1;a=Oe(n,t,l,u)}if(i>0){let l;r>o?l=r+o-3:l=r-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);a=$r(a,u)}return a.shape.length===1&&(a=Xt(a,1)),a})}var BL=(()=>{class n extends ca{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0],o=e[1];if(r.length>3||o.length>3)throw new ve("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);if(r[s[0]]!==o[s[1]])throw new P(`Dimension incompatibility: ${r[s[0]]} !== ${o[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new P(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let r=e[0],o=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,a)=>qm(i,e[a].shape.length)):s=[qm(this.axes,r.shape.length),qm(this.axes,o.shape.length)],this.normalize&&(r=Lm(r,s[0]),o=Lm(o,s[1])),Ooe(r,o,s)}interpretAxes(e,r){let o;return Array.isArray(this.axes)?o=this.axes:o=[qm(this.axes,e.length),qm(this.axes,r.length)],o}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0].slice(),o=e[1].slice();if(r.length>3||o.length>3)throw new ve("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);r.splice(s[0],1),o.splice(s[1],1),o.splice(0,1);let i=r.concat(o);return i.length===1&&i.push(1),i}computeMask(e,r){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})();q.registerClass(BL);var zL=(()=>{class n extends we{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return jl(()=>j(Rd(o.shape,0,this.stddev),o),()=>o,r.training||!1)})}}return n.className="GaussianNoise",n})();q.registerClass(zL);var VL=(()=>{class n extends we{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);let o=xe(e);return this.rate>0&&this.rate<1?jl(()=>{let i=Math.sqrt(this.rate/(1-this.rate));return R(o,Rd(o.shape,1,i))},()=>o,r.training||!1):o})}}return n.className="GaussianDropout",n})();q.registerClass(VL);var UL=(()=>{class n extends we{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||xe(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(e);return jl(()=>{let i=xe(e),u=-1.6732632423543772*1.0507009873554805,c=sr(Fr(o),this.rate);c=Zn(c,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,f=-p*u*this.rate,d=j(R(i,c),R(j(c,-1),u));return j(R(d,p),f)},()=>xe(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})();q.registerClass(UL);function Km(n,t,e,r,o,s=.001){let i;if(n.rank===2)i=Nx(n,t,e,r,o,s);else if(n.rank===3)i=Ex(n,t,e,r,o,s);else if(n.rank===4)i=Dx(n,t,e,r,o,s);else throw new ve(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return i}function Moe(n,t,e,r,o=.001){return B(()=>{let s=lc(n,r),i=s.mean,a=s.variance;return[Km(n,i,a,e,t,o),i,a]})}function Foe(n,t,e,r,o=.001){return B(()=>{let s=lc(n,r),i=s.mean,a=s.variance,l=[];for(let h of ur(0,n.rank))r.indexOf(h)!==-1?l.push(1):l.push(n.shape[h]);let u=O(i,l),c=O(a,l),p=t==null?null:O(t,l),f=e==null?null:O(e,l);return[Km(n,u,c,f,p,o),i,a]})}function $oe(n,t,e,r,o=.001){return b.arraysEqual(r.slice().sort(),ur(0,n.rank-1))?Moe(n,t,e,r,o):Foe(n,t,e,r,o)}var GL=(()=>{class n extends we{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ft(e.betaInitializer||"zeros"),this.gammaInitializer=ft(e.gammaInitializer||"ones"),this.movingMeanInitializer=ft(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ft(e.movingVarianceInitializer||"ones"),this.betaConstraint=Vt(e.betaConstraint),this.gammaConstraint=Vt(e.gammaConstraint),this.betaRegularizer=gt(e.betaRegularizer),this.gammaRegularizer=gt(e.gammaRegularizer)}build(e){e=Re(e);let r=this.axis>=0?this.axis:this.axis+e.length,o=e[r];if(o==null)throw new P(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new mt({ndim:e.length,axes:{[r]:o}})];let s=[o];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return B(()=>{let o=r.training==null?!1:r.training,s=xe(e),i=s.shape,a=i.length,l=ur(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);let c=Io(1,a);c[u]=i[u];let p=l.slice();p.sort();let f=!b.arraysEqual(p,ur(0,a).slice(0,a-1)),d=()=>{if(f){let v=O(this.movingMean.read(),c),w=O(this.movingVariance.read(),c),S=this.center?O(this.beta.read(),c):null,k=this.scale?O(this.gamma.read(),c):null;return Km(s,v,w,S,k,this.epsilon)}else return Km(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return d();let[h,g,m]=$oe(s,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(v,w,S)=>{B(()=>{let k=1-S,A=v.read(),_=R(te(A,w),k);v.write(te(A,_))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ct(this.betaInitializer),gammaInitializer:Ct(this.gammaInitializer),movingMeanInitializer:Ct(this.movingMeanInitializer),movingVarianceInitializer:Ct(this.movingVarianceInitializer),betaRegularizer:at(this.betaRegularizer),gammaRegularizer:at(this.gammaRegularizer),betaConstraint:zt(this.betaConstraint),gammaConstraint:zt(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})();q.registerClass(GL);var WL=(()=>{class n extends we{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ft(e.betaInitializer||"zeros"),this.gammaInitializer=ft(e.gammaInitializer||"ones"),this.betaRegularizer=gt(e.betaRegularizer),this.gammaRegularizer=gt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Re(e);let r=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(let i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==To(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,r){let o=xe(e),s=o.shape,i=s.length;return B(()=>{let{mean:l,variance:u}=lc(o,this.axis,!0),c=Io(1,i);for(let m of this.axis)c[m]=s[m];let p=m=>m!=null&&m.shape.length!==i?O(m,c):m,f=this.scale?p(this.gamma.read()):null,d=this.center?p(this.beta.read()):null,h=[],g=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(h.push(s[m]),g.push(1)):(h.push(1),g.push(s[m]));return l=Rn(l,h),u=Rn(u,h),f!=null&&(f=Rn(f,g)),d!=null&&(d=Rn(d,g)),Km(o,l,u,d,f,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ct(this.betaInitializer),gammaInitializer:Ct(this.gammaInitializer),betaRegularizer:at(this.betaRegularizer),gammaRegularizer:at(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})();q.registerClass(WL);function Poe(n,t,e){return B(()=>{if(n.rank!==4)throw new P(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new P("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=cr()),e!=="channelsLast"&&e!=="channelsFirst")throw new P(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return e==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],ir(n,r)})}var jL=(()=>{class n extends we{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?cr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new P(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,o;if(typeof e.padding[0]=="number")r=[e.padding[0],e.padding[0]],o=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new P(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],e.padding[1].length!==2)throw new P(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);o=e.padding[1]}this.padding=[r,o]}this.inputSpec=[new mt({ndim:4})]}computeOutputShape(e){e=Re(e);let r,o;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?r=e[2]+this.padding[0][0]+this.padding[0][1]:r=null,e[3]!=null&&e[3]>=0?o=e[3]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],e[1],r,o]):(e[1]!=null&&e[1]>=0?r=e[1]+this.padding[0][0]+this.padding[0][1]:r=null,e[2]!=null&&e[2]>=0?o=e[2]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],r,o,e[3]])}call(e,r){return B(()=>Poe(xe(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})();q.registerClass(jL);function bv(n,t,e,r,o,s){return B(()=>{kt(o),hN(s),lr(r),e==null&&(e=[1,1]),r==null&&(r="valid"),o==null&&(o=cr()),s==null&&(s="max"),n=jm(n,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=$l(n,t,e,a):i=El(n,t,e,a),o==="channelsFirst"&&(i=Me(i,[0,3,1,2])),i})}function HL(n,t,e,r,o,s){return B(()=>{kt(o),hN(s),lr(r),e==null&&(e=[1,1,1]),r==null&&(r="valid"),o==null&&(o=cr()),s==null&&(s="max"),n=BN(n,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=Zx(n,t,e,a):i=Tx(n,t,e,a),o==="channelsFirst"&&(i=Me(i,[0,4,1,2,3])),i})}var hv=class extends we{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new P(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Zt(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new P(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Zt(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,lr(this.padding),this.inputSpec=[new mt({ndim:3})]}computeOutputShape(t){t=Re(t);let e=Ir(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=sa(xe(t),2);let r=this.poolingFunction(xe(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $r(r,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},qL=(()=>{class n extends hv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),bv(e,r,o,s,i,"max")}}return n.className="MaxPooling1D",n})();q.registerClass(qL);var KL=(()=>{class n extends hv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),bv(e,r,o,s,i,"avg")}}return n.className="AveragePooling1D",n})();q.registerClass(KL);var mv=class extends we{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new P(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Zt(this.poolSize,"poolSize"),Zt(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,kt(this.dataFormat),lr(this.padding),this.inputSpec=[new mt({ndim:4})]}computeOutputShape(t){t=Re(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Ir(e,this.poolSize[0],this.padding,this.strides[0]),r=Ir(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(xe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},XL=(()=>{class n extends mv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),bv(e,r,o,s,i,"max")}}return n.className="MaxPooling2D",n})();q.registerClass(XL);var YL=(()=>{class n extends mv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),bv(e,r,o,s,i,"avg")}}return n.className="AveragePooling2D",n})();q.registerClass(YL);var gv=class extends we{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new P(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Zt(this.poolSize,"poolSize"),Zt(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,kt(this.dataFormat),lr(this.padding),this.inputSpec=[new mt({ndim:5})]}computeOutputShape(t){t=Re(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Ir(e,this.poolSize[0],this.padding,this.strides[0]),r=Ir(r,this.poolSize[1],this.padding,this.strides[1]),o=Ir(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r,o]:[t[0],e,r,o,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(xe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},ZL=(()=>{class n extends gv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),HL(e,r,o,s,i,"max")}}return n.className="MaxPooling3D",n})();q.registerClass(ZL);var QL=(()=>{class n extends gv{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return kt(i),lr(s),HL(e,r,o,s,i,"avg")}}return n.className="AveragePooling3D",n})();q.registerClass(QL);var yv=class extends we{constructor(t){super(t),this.inputSpec=[new mt({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new ve}},JL=(()=>{class n extends yv{constructor(e){super(e||{})}call(e,r){return B(()=>{let o=xe(e);return wt(o,1)})}}return n.className="GlobalAveragePooling1D",n})();q.registerClass(JL);var e3=(()=>{class n extends yv{constructor(e){super(e||{})}call(e,r){return B(()=>{let o=xe(e);return vn(o,1)})}}return n.className="GlobalMaxPooling1D",n})();q.registerClass(e3);var xv=class extends we{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,kt(this.dataFormat),this.inputSpec=[new mt({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new ve}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},t3=(()=>{class n extends xv{call(e,r){return B(()=>{let o=xe(e);return this.dataFormat==="channelsLast"?wt(o,[1,2]):wt(o,[2,3])})}}return n.className="GlobalAveragePooling2D",n})();q.registerClass(t3);var n3=(()=>{class n extends xv{call(e,r){return B(()=>{let o=xe(e);return this.dataFormat==="channelsLast"?vn(o,[1,2]):vn(o,[2,3])})}}return n.className="GlobalMaxPooling2D",n})();q.registerClass(n3);var vv=class extends we{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){let o=e.layer,s=Lr(o,r);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},r3=(()=>{class n extends vv{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Re(e),e.length<3)throw new P(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Re(e);let r=[e[0]].concat(e.slice(2)),o=this.layer.computeOutputShape(r),s=e[1];return[o[0],s].concat(o.slice(1))}call(e,r){return B(()=>(e=xe(e),GN((a,l)=>[xe(this.layer.call(a,r)),[]],e,[],!1,null,null,!1,!0)[1]))}}return n.className="TimeDistributed",n})();q.registerClass(r3);function Loe(n){Fs(lP,"BidirectionalMergeMode",n)}var Boe="concat",o3=(()=>{class n extends vv{constructor(e){super(e);let r=e.layer.getConfig(),o={};o.className=e.layer.getClassName(),o.config=r,this.forwardLayer=Lr(o),r.goBackwards=r.goBackwards!==!0;let s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=Lr(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Boe:e.mergeMode,Loe(this.mergeMode),e.weights)throw new ve("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let r=e.length,o=Math.floor(r/2);this.forwardLayer.setWeights(e.slice(0,o)),this.backwardLayer.setWeights(e.slice(o))}computeOutputShape(e){let r=this.forwardLayer.computeOutputShape(e);Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r;let o,s,i;return this.returnState&&(i=r.slice(1)),o=r[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,s=[o]):this.mergeMode==null?s=[o,o.slice()]:s=[o],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[o].concat(i).concat(i.slice()):In(s)}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=UN(e,o,s,this.numConstants);if(e=i.inputs,o=i.initialState,s=i.constants,Array.isArray(e)&&(o=e.slice(1),e=e[0]),(o==null||o.length===0)&&s==null)return super.apply(e,r);let a=[],l=[];if(o!=null){let c=o.length;if(c%2>0)throw new P("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=o,a.push(...o);let p=o.map(f=>new mt({shape:f.shape}));this.forwardLayer.stateSpec=p.slice(0,c/2),this.backwardLayer.stateSpec=p.slice(c/2),l.push(...p)}if(s!=null)throw new ve("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof Qn;for(let c of a)if(c instanceof Qn!==u)throw new P("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let c=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(c,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return B(()=>{let o=r.initialState,s,i;if(o==null)s=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{let u=o.slice(0,o.length/2),c=o.slice(o.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:c}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=un(i,1));let l;return this.mergeMode==="concat"?l=Ad([s,i]):this.mergeMode==="sum"?l=j(s,i):this.mergeMode==="ave"?l=R(.5,j(s,i)):this.mergeMode==="mul"?l=R(s,i):this.mergeMode==null&&(l=[s,i]),this.returnState?this.mergeMode==null?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Qo(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Qo(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){Array.isArray(r)&&(r=r[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[r,r]:o=r:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let i=this.forwardLayer.states.map(a=>null);return Array.isArray(o)?o.concat(i).concat(i):[o].concat(i).concat(i)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){let o=Lr(r.layer);if(delete r.layer,r.numConstants!=null)throw new ve("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=r;return s.layer=o,new e(s)}}return n.className="Bidirectional",n})();q.registerClass(o3);var s3=(()=>{class n extends we{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>(e=xe(e),e.dtype!=="float32"&&(e=Zn(e,"float32")),j(R(e,this.scale),this.offset)))}}return n.className="Rescaling",n})();q.registerClass(s3);var{resizeBilinear:zoe,cropAndResize:Voe}=Cr,i3=(()=>{class n extends we{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,o,s,i,a,l,u){return B(()=>{let c,p=!1,f=r/a,d=o/l,h=(s+r)/a,g=(i+o)/l,m=[f,d,h,g],y=[];e.rank===3?(p=!0,c=Lt([e])):c=e;for(let k=0;k<c.shape[0];k++)y.push(m);let x=ln(y,[y.length,4]),v=Os(0,y.length,1,"int32"),S=Voe(c,x,v,[s,i],"nearest");return p?Zn(xe(pn(S)),u):Zn(S,u)})}upsize(e,r,o,s){return B(()=>{let i=zoe(e,[r,o]);return Zn(i,s)})}call(e,r){return B(()=>{let o=xe(e),s=o.dtype,i=o.shape,a=i[i.length-3],l=i[i.length-2],u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(o,u,c,this.height,this.width,a,l,s):this.upsize(e,this.height,this.width,s)})}getConfig(){let e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=Re(e);let r=e.length-3,o=e.length-2;return e[r]=this.height,e[o]=this.width,e}}return n.className="CenterCrop",n})();q.registerClass(i3);function a3(n,t,e,r){let o=xe(n);if(o.dtype!=="int32"&&(o=Zn(o,"int32")),t==="int")return o;let s=o.shape;if(o.rank===0&&(o=Xt(o,-1)),t==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=Xt(o,-1)),o.rank>2)throw new P(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${o.rank}.`);let i=["multiHot","oneHot"].includes(t),a=o,l;if(typeof r<"u"&&t==="count"?l=Cm(a,r,e,i):l=Cm(a,[],e,i),t!=="tfIdf")return l;if(r)return R(l,r);throw new P("When outputMode is 'tfIdf', weights must be provided.")}var l3=(()=>{class n extends we{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=Re(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return B(()=>{e=xe(e),e.dtype!=="int32"&&(e=Zn(e,"int32"));let o;if(typeof r.countWeights<"u"){if(this.outputMode!=="count")throw new P(`countWeights is not used when outputMode !== count.
              Received countWeights=${r.countWeights}`);o=xe(r.countWeights)}let s=vn(e),i=Yi(e),a=$t(this.numTokens,s).bufferSync().get(0),l=sr(i,0).bufferSync().get(0);if(!(a&&l))throw new P(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return a3(e,this.outputMode,this.numTokens,o)})}}return n.className="CategoryEncoding",n})();q.registerClass(l3);var Goe=["bilinear","nearest"],u3=new Set(Goe),c3=(()=>{class n extends we{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(u3.has(e.interpolation))this.interpolation=e.interpolation;else throw new P(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Re(e);let r=e[2];return[this.height,this.width,r]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>{let o=[this.height,this.width];if(this.interpolation==="bilinear")return Cr.resizeBilinear(e,o,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Cr.resizeNearestNeighbor(e,o,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...u3]} are supported`)})}}return n.className="Resizing",n})();q.registerClass(c3);var p3=(()=>{class n{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}return n.className="RandomSeed",n})();var f3=(()=>{class n extends we{constructor(e){super(e),this.randomGenerator=new p3(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BaseRandomLayer",n})();var Woe=["bilinear","nearest"],d3=new Set(Woe),h3=(()=>{class n extends f3{constructor(e){super(e);let{factor:r,interpolation:o="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new P(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new P(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new P(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(o)if(d3.has(o))this.interpolation=o;else throw new P(`Invalid interpolation parameter: ${o} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=Re(e);let r=e[2];return[this.imgHeight,-1,r]}call(e,r){return B(()=>{let o=xe(e);this.imgHeight=o.shape[o.shape.length-3];let s=o.shape[o.shape.length-2];this.widthFactor=Fr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);let a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Cr.resizeBilinear(e,a);case"nearest":return Cr.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...d3]} are supported`)}})}}return n.className="RandomWidth",n})();q.registerClass(h3);var Yoe=L();Yoe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Br=function(n){return n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",n}(Br||{}),m3;(function(n){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(m3||(m3={}));var Qoe={};function wv(n){return Qoe[n]}function C(n,t,e,r,o){let s=t.inputParams[n];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,u=a<0?t.inputNames.length+a:a;if(s.type==="tensor")return sn(t.inputNames[u],e,r,o);if(s.type==="tensors"){let f=t.inputs.slice(a,l);return t.inputNames.slice(a,l).filter((h,g)=>{var m;return((m=f[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(h=>sn(h,e,r,o))}let c=sn(t.inputNames[u],e,r,o),p=c.dataSync();return s.type==="number"?p[0]:b.toNestedArray(c.shape,p)}let i=t.attrParams[n];return i&&i.value}function sn(n,t,e,r){let[o,s]=dr(n,e);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[Cv(o,a)]);return i!==void 0?t[Cv(o,i)][s]:void 0}function XN(n,t,e){return t[Cv(n,e.currentContextId)]}function rs(n,t){let[e,r,o]=dr(n,t);return[Cv(e,t&&t.currentContextId),r,o]}function Cv(n,t){return t?`${n}-${t}`:n}function dr(n,t){if(n==="")return["",0,void 0];let e=t!=null&&t.parseNodeNameCache!=null;if(e){let s=t.parseNodeNameCache.get(n);if(s!=null)return s}let r=n.split(":"),o;if(r.length===1)o=[n,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return e&&t.parseNodeNameCache.set(n,o),o}function Xm(n,t,e){let r=C("pad",n,t,e);if(r==="explicit"){r=C("explicitPaddings",n,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function os(n){return n.kept?n:or(n)}var YN={};yt(YN,{json:()=>Joe});var Joe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var ZN={};yt(ZN,{json:()=>ese});var ese=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var QN={};yt(QN,{json:()=>tse});var tse=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var JN={};yt(JN,{json:()=>nse});var nse=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var eE={};yt(eE,{json:()=>rse});var rse=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var tE={};yt(tE,{json:()=>ose});var ose=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var nE={};yt(nE,{json:()=>sse});var sse=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var rE={};yt(rE,{json:()=>ise});var ise=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var oE={};yt(oE,{json:()=>ase});var ase=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var sE={};yt(sE,{json:()=>lse});var lse=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var iE={};yt(iE,{json:()=>use});var use=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var aE={};yt(aE,{json:()=>cse});var cse=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var lE={};yt(lE,{json:()=>pse});var pse=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var uE={};yt(uE,{json:()=>fse});var fse=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var cE={};yt(cE,{json:()=>dse});var dse=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var pE={};yt(pE,{json:()=>hse});var hse=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var fE={};yt(fE,{json:()=>mse});var mse=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var dE={};yt(dE,{json:()=>gse});var gse=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var hE={};yt(hE,{json:()=>yse});var yse=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Ym=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[YN,ZN,QN,JN,eE,tE,nE,rE,oE,sE,iE,aE,lE,uE,cE,pE,fE,dE,hE],e=[].concat(...t.map(r=>r.json));this.opMappers=e.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(t,e={}){let r=t.node,o=[],s=[],i=[],a=r.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?o.push(g[m.name]):m.op==="Const"?s.push(g[m.name]):(m.input==null||m.input.length===0)&&i.push(g[m.name]),g),{}),l=[],u=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let f=Object.keys(a);f.forEach(g=>{let m=a[g];m.inputNames.forEach((y,x)=>{let[v,,w]=rs(y),S=a[v];if(S.outputs!=null){let k=S.outputs.indexOf(w);if(k!==-1){let A=`${v}:${k}`;m.inputNames[x]=A}}m.inputs.push(S),S.children.push(m)})}),Object.keys(p).length===0?f.forEach(g=>{let m=a[g];m.children.length===0&&u.push(m)}):Object.keys(p).forEach(g=>{let[m]=rs(g),y=a[m];y!=null&&(y.signatureKey=p[g],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{let[m]=rs(g),y=a[m];y&&(y.signatureKey=c[g],l.push(y))}):l=o;let d={};t.library!=null&&t.library.function!=null&&(d=t.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));let h={nodes:a,inputs:l,outputs:u,weights:s,placeholders:o,signature:e,functions:d};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){let e=wv(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(r.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(r.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=Iv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Iv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Av(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Av(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=Tv(t.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=Tv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=kv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=kv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Sv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Sv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=_v(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=_v(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Dv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Dv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Rv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Rv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=Nv(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Nv(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=Ev(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Ev(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=g3(t.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=g3(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(t){let e=t.nodeDef,r=[],o=[],s={};e!=null&&(s=e.reduce((p,f)=>(p[f.name]=this.mapNode(f),f.op==="Const"&&o.push(p[f.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[f]=rs(p.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:mE(p.type),type:"dtype"}},children:[]};d.signatureKey=p.name,i.push(d),s[f]=d}),Object.keys(s).forEach(p=>{let f=s[p];f.inputNames.forEach((d,h)=>{let[g,,m]=rs(d),y=s[g];if(y.outputs!=null){let x=y.outputs.indexOf(m);if(x!==-1){let v=`${g}:${x}`;f.inputNames[h]=v}}f.inputs.push(y),y.children.push(f)})});let u=t.ret;t.signature.outputArg.forEach(p=>{let[f,d]=rs(u[p.name]),h=s[f];h!=null&&(h.defaultOutput=d,a.push(h))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return e!=null&&(r=e[r]),{name:r,dtype:t.type}}};function xse(n){let t=L().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function y3(n,t){let e=Array.isArray(n)?String.fromCharCode.apply(null,n):xse(n);return t?e:e.toLowerCase()}function Iv(n,t,e,r=!1){let o=n[t];return o!=null?y3(o.s,r):e}function Sv(n,t,e){let r=n[t];return r?r.b:e}function Tv(n,t,e){let r=n[t]||{},o=r.i!=null?r.i:r.f!=null?r.f:e;return typeof o=="number"?o:parseInt(o,10)}function mE(n){switch(typeof n=="string"&&(n=Br[n]),n){case Br.DT_FLOAT:case Br.DT_HALF:return"float32";case Br.DT_INT32:case Br.DT_INT64:case Br.DT_INT8:case Br.DT_UINT8:return"int32";case Br.DT_BOOL:return"bool";case Br.DT_DOUBLE:return"float32";case Br.DT_STRING:return"string";case Br.DT_COMPLEX64:case Br.DT_COMPLEX128:return"complex64";default:return null}}function g3(n,t,e){let r=n[t];return r&&r.func?r.func.name:e}function Nv(n,t,e){let r=n[t];return r&&r.type?mE(r.type):e}function Ev(n,t,e){let r=n[t];return r&&r.list&&r.list.type?r.list.type.map(o=>mE(o)):e}function x3(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Dv(n,t,e){let r=n[t];return r&&r.shape?x3(r.shape):e}function kv(n,t,e){let r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function Av(n,t,e,r=!1){let o=n[t];return o&&o.list&&o.list.s?o.list.s.map(s=>y3(s,r)):e}function Rv(n,t,e){let r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(o=>x3(o)):e}function _v(n,t,e){let r=n[t];return r&&r.list&&r.list.b?r.list.b:e}var Ov=class{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return sn(t,this.tensorMap,this.context)}getAttr(t,e){let r=this.node.rawAttrs[t];if(r.tensor!=null)return sn(t,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Tv(this.node.rawAttrs,t,e);if(r.s!=null)return Iv(this.node.rawAttrs,t,e);if(r.b!=null)return Sv(this.node.rawAttrs,t,e);if(r.shape!=null)return Dv(this.node.rawAttrs,t,e);if(r.type!=null)return Nv(this.node.rawAttrs,t,e);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return kv(this.node.rawAttrs,t,e);if(r.list.s!=null)return Av(this.node.rawAttrs,t,e);if(r.list.shape!=null)return Rv(this.node.rawAttrs,t,e);if(r.list.b!=null)return _v(this.node.rawAttrs,t,e);if(r.list.type!=null)return Ev(this.node.rawAttrs,t,e)}return e}};var et={};yt(et,{OP_SCOPE_SUFFIX:()=>bT,abs:()=>Tt,acos:()=>yx,acosh:()=>xx,add:()=>j,addN:()=>W2,all:()=>Qf,any:()=>oc,argMax:()=>Ts,argMin:()=>bx,asin:()=>vx,asinh:()=>wx,atan:()=>Cx,atan2:()=>Ix,atanh:()=>Sx,avgPool:()=>El,avgPool3d:()=>Tx,basicLSTMCell:()=>q2,batchNorm:()=>Es,batchNorm2d:()=>Nx,batchNorm3d:()=>Ex,batchNorm4d:()=>Dx,batchToSpaceND:()=>Dl,bincount:()=>kx,bitwiseAnd:()=>X2,booleanMaskAsync:()=>fee,broadcastArgs:()=>Y2,broadcastTo:()=>Ds,buffer:()=>de,cast:()=>Y,ceil:()=>Ax,clipByValue:()=>bn,clone:()=>or,complex:()=>xr,concat:()=>Je,concat1d:()=>Rx,concat2d:()=>_x,concat3d:()=>Ox,concat4d:()=>Mx,conv1d:()=>ed,conv2d:()=>br,conv2dTranspose:()=>nd,conv3d:()=>Fx,conv3dTranspose:()=>Px,cos:()=>kl,cosh:()=>rd,cosineWindow:()=>Dm,cumprod:()=>ic,cumsum:()=>od,denseBincount:()=>Cm,depthToSpace:()=>Lx,depthwiseConv2d:()=>ks,diag:()=>Z2,dilation2d:()=>Bx,div:()=>ne,divNoNan:()=>zx,dot:()=>Vx,dropout:()=>GT,einsum:()=>Al,elu:()=>As,enclosingPowerOfTwo:()=>WT,ensureShape:()=>J2,equal:()=>Yn,erf:()=>sd,euclideanNorm:()=>Ux,exp:()=>Ht,expandDims:()=>Xt,expm1:()=>Gx,eye:()=>ac,fft:()=>zl,fill:()=>xo,floor:()=>Rs,floorDiv:()=>Zf,fused:()=>Ul,gather:()=>_s,gatherND:()=>Cee,greater:()=>$t,greaterEqual:()=>sr,ifft:()=>ea,imag:()=>Rl,image:()=>Cr,inTopKAsync:()=>Tee,irfft:()=>yd,isFinite:()=>Wx,isInf:()=>jx,isNaN:()=>Hx,leakyRelu:()=>_l,less:()=>Qi,lessEqual:()=>Mr,linalg:()=>HT,linspace:()=>nO,localResponseNormalization:()=>qx,log:()=>wn,log1p:()=>Ol,logSigmoid:()=>Kx,logSoftmax:()=>id,logSumExp:()=>Ml,logicalAnd:()=>Bn,logicalNot:()=>Fl,logicalOr:()=>ad,logicalXor:()=>Xx,losses:()=>Ete,lowerBound:()=>rO,matMul:()=>Oe,max:()=>vn,maxPool:()=>$l,maxPool3d:()=>Zx,maxPoolWithArgmax:()=>oO,maximum:()=>wr,mean:()=>wt,meshgrid:()=>sO,min:()=>Yi,minimum:()=>to,mirrorPad:()=>Qx,mod:()=>Jx,moments:()=>lc,movingAverage:()=>mee,mul:()=>R,multiRNNCell:()=>iO,multinomial:()=>aO,neg:()=>Fe,norm:()=>Zi,notEqual:()=>Xo,oneHot:()=>uc,ones:()=>Pt,onesLike:()=>hn,op:()=>T,outerProduct:()=>lO,pad:()=>ir,pad1d:()=>uO,pad2d:()=>cO,pad3d:()=>pO,pad4d:()=>fO,pool:()=>eb,pow:()=>Ln,prelu:()=>Ll,print:()=>gx,prod:()=>tb,raggedGather:()=>dO,raggedRange:()=>hO,raggedTensorToTensor:()=>mO,rand:()=>gO,randomGamma:()=>OO,randomNormal:()=>fc,randomStandardNormal:()=>MO,randomUniform:()=>Fr,randomUniformInt:()=>FO,range:()=>Os,real:()=>Ji,reciprocal:()=>ib,relu:()=>_n,relu6:()=>ld,reshape:()=>O,reverse:()=>un,reverse1d:()=>$O,reverse2d:()=>PO,reverse3d:()=>LO,reverse4d:()=>BO,rfft:()=>Vl,round:()=>ud,rsqrt:()=>cd,scalar:()=>se,scatterND:()=>yee,searchSorted:()=>Sm,selu:()=>pd,separableConv2d:()=>fd,setdiff1dAsync:()=>zO,sigmoid:()=>Xn,sign:()=>ab,signal:()=>Nte,sin:()=>dd,sinh:()=>hd,slice:()=>Ne,slice1d:()=>md,slice2d:()=>Nm,slice3d:()=>gd,slice4d:()=>dc,softmax:()=>Bl,softplus:()=>Ko,spaceToBatchND:()=>Pl,sparse:()=>Dte,sparseToDense:()=>vee,spectral:()=>Tte,split:()=>cn,sqrt:()=>pt,square:()=>_e,squaredDifference:()=>xd,squeeze:()=>$r,stack:()=>Lt,step:()=>vo,stridedSlice:()=>lb,string:()=>kte,sub:()=>te,sum:()=>ie,tan:()=>ub,tanh:()=>qo,tensor:()=>ln,tensor1d:()=>Bt,tensor2d:()=>ta,tensor3d:()=>VO,tensor4d:()=>UO,tensor5d:()=>GO,tensor6d:()=>WO,tensorScatterUpdate:()=>qO,tile:()=>Rn,topk:()=>cb,transpose:()=>Me,truncatedNormal:()=>bd,unique:()=>pb,unsortedSegmentSum:()=>vd,unstack:()=>pn,upperBound:()=>KO,variable:()=>fb,where:()=>vt,whereAsync:()=>hb,zeros:()=>nt,zerosLike:()=>ye});var b3=(n,t,e,r=et)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(C("a",n,t,e),C("b",n,t,e))];case"AddN":return[r.addN(C("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(C("a",n,t,e),C("b",n,t,e))];case"Mul":return[r.mul(C("a",n,t,e),C("b",n,t,e))];case"RealDiv":case"Div":return[r.div(C("a",n,t,e),C("b",n,t,e))];case"DivNoNan":return[r.divNoNan(C("a",n,t,e),C("b",n,t,e))];case"FloorDiv":return[r.floorDiv(C("a",n,t,e),C("b",n,t,e))];case"Sub":return[r.sub(C("a",n,t,e),C("b",n,t,e))];case"Minimum":return[r.minimum(C("a",n,t,e),C("b",n,t,e))];case"Maximum":return[r.maximum(C("a",n,t,e),C("b",n,t,e))];case"Pow":return[r.pow(C("a",n,t,e),C("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(C("a",n,t,e),C("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var v3=(n,t,e,r=et)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(C("x",n,t,e))];case"Acos":return[r.acos(C("x",n,t,e))];case"Acosh":return[r.acosh(C("x",n,t,e))];case"Asin":return[r.asin(C("x",n,t,e))];case"Asinh":return[r.asinh(C("x",n,t,e))];case"Atan":return[r.atan(C("x",n,t,e))];case"Atan2":return[r.atan2(C("x",n,t,e),C("y",n,t,e))];case"Atanh":return[r.atanh(C("x",n,t,e))];case"Ceil":return[r.ceil(C("x",n,t,e))];case"Complex":return[r.complex(C("real",n,t,e),C("imag",n,t,e))];case"Cos":return[r.cos(C("x",n,t,e))];case"Cosh":return[r.cosh(C("x",n,t,e))];case"Elu":return[r.elu(C("x",n,t,e))];case"Erf":return[r.erf(C("x",n,t,e))];case"Exp":return[r.exp(C("x",n,t,e))];case"Expm1":return[r.expm1(C("x",n,t,e))];case"Floor":return[r.floor(C("x",n,t,e))];case"Log":return[r.log(C("x",n,t,e))];case"Log1p":return[r.log1p(C("x",n,t,e))];case"Imag":return[r.imag(C("x",n,t,e))];case"Neg":return[r.neg(C("x",n,t,e))];case"Reciprocal":return[r.reciprocal(C("x",n,t,e))];case"Real":return[r.real(C("x",n,t,e))];case"Relu":return[r.relu(C("x",n,t,e))];case"Round":return[r.round(C("x",n,t,e))];case"Selu":return[r.selu(C("x",n,t,e))];case"Sigmoid":return[r.sigmoid(C("x",n,t,e))];case"Sin":return[r.sin(C("x",n,t,e))];case"Sign":return[r.sign(C("x",n,t,e))];case"Sinh":return[r.sinh(C("x",n,t,e))];case"Softplus":return[r.softplus(C("x",n,t,e))];case"Sqrt":return[r.sqrt(C("x",n,t,e))];case"Square":return[r.square(C("x",n,t,e))];case"Tanh":return[r.tanh(C("x",n,t,e))];case"Tan":return[r.tan(C("x",n,t,e))];case"ClipByValue":return[r.clipByValue(C("x",n,t,e),C("clipValueMin",n,t,e),C("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(C("x",n,t,e))];case"Rsqrt":return[r.rsqrt(sn(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu(C("x",n,t,e),C("alpha",n,t,e))];case"Prelu":return[r.prelu(C("x",n,t,e),C("alpha",n,t,e))];case"IsNan":return[r.isNaN(sn(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(sn(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(sn(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function zr(n,t,e=""){if(!(typeof n=="number"||typeof t=="number")){b.assert(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){let o=n[r],s=t[r];b.assert(o<0||s<0||o===s,()=>e+` Shapes ${n} and ${t} must match`)}}}function w3(n){return!(typeof n=="number"||n.some(t=>t<0))}function zd(n,t,e){let r=Mv(n,e),o=!w3(r);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&t.forEach(s=>{r=Mv(s.shape,r)}),!w3(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Mv(n,t){if(typeof n=="number")return t;if(typeof t=="number")return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);let e=[];for(let r=0;r<n.length;++r){let o=n[r],s=t[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=o>=0?o:s}return e}var Fv=class{constructor(t,e,r,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=se(0),Et(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),zr(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,Et(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,o)=>this.write(r,e[o]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return ln([],[0].concat(this.elementShape));let r=this.readMany(t);return zr(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Lt(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return ln([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let r=this.readMany(e);return zr(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Je(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,pn(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0,o=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:e.size/r,i=[];B(()=>{e=O(e,[1,r,s]);for(let l=0;l<t.length;++l){let c=[0,l===0?0:o[l-1],0],p=[1,t[l],s];i[l]=O(Ne(e,c,p),this.elementShape)}return i});let a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,i)}};var Vd=class n{get id(){return this.idTensor.id}constructor(t,e,r,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);zr(e,s.shape,"TensorList shape mismatch: "),Et(s)}),this.idTensor=se(0),this.maxNumElements=o,Et(this.idTensor)}copy(){return new n([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);zr(t,this.elementShape,"TensorList shape mismatch: ");let o=zd(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>O(i,o));return Lt(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=zd(this.elementShape,this.tensors,t),o=this.tensors.pop();return o.kept=!1,zr(o.shape,t,"TensorList shape mismatch: "),O(o,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(zr(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Et(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new n([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);zr(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=zd(this.elementShape,this.tensors,e);return O(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);zr(this.elementShape,e.shape,"TensorList shape mismatch: "),Et(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);zr(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=zd(this.elementShape,this.tensors,r);return t.length===0?ln([],[0].concat(o)):B(()=>{let s=t.map(i=>O(this.tensors[i],o));return Lt(s,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);zr(this.elementShape,e,"TensorList shape mismatch: ");let r=zd(this.elementShape,this.tensors,e);return this.size()===0?ln([],[0].concat(r)):B(()=>{let o=this.tensors.map(s=>O(s,r));return Je(o,0)})}};function C3(n,t,e){let r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);let o=n.shape.slice(1);zr(o,t,"TensorList shape mismatch: ");let s=pn(n);return new Vd(s,t,r)}function I3(n,t,e,r){return new Vd([],n,t,r)}function S3(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);let o=Math.max(...t);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new Vd([],e,n.dtype,r),i=pn(n,0);return t.forEach((a,l)=>{s.setItem(a,i[l])}),s}function T3(n,t,e){let r=0,o=t.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);let s=n.shape.slice(1),i=Mv(s,e),a=r===0?0:n.size/r,l=B(()=>{let c=[];n=O(n,[1,r,a]);for(let p=0;p<t.length;++p){let d=[0,p===0?0:o[p-1],0],h=[1,t[p],a];c[p]=O(Ne(n,d,h),i)}return n.dispose(),c}),u=new Vd([],e,n.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var N3=(n,t,e)=>z(void 0,null,function*(){switch(n.op){case"If":case"StatelessIf":{let r=C("thenBranch",n,t,e),o=C("elseBranch",n,t,e),s=C("cond",n,t,e),i=C("args",n,t,e);return(yield s.data())[0]?e.functionMap[r].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let r=C("body",n,t,e),o=C("cond",n,t,e),s=C("args",n,t,e),i=yield e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),l=yield i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;l[0];){let c=u;u=yield e.functionMap[r].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap);let p=u.map(d=>d.id);c.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()});let f=yield e.functionMap[o].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap);l=yield f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()})}return u}case"LoopCond":{let r=C("pred",n,t,e);return[os(r)]}case"Switch":{let r=C("pred",n,t,e),o=C("data",n,t,e);return o.kept||(o=os(o)),(yield r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=n.inputNames.find(o=>sn(o,t,e)!==void 0);if(r){let o=sn(r,t,e);return[os(o)]}return}case"Enter":{let r=C("frameName",n,t,e),o=C("tensor",n,t,e);return e.enterFrame(r),[os(o)]}case"Exit":{let r=C("tensor",n,t,e);return e.exitFrame(),[os(r)]}case"NextIteration":{let r=C("tensor",n,t,e);return e.nextIteration(),[os(r)]}case"TensorArrayV3":{let r=C("size",n,t,e),o=C("dtype",n,t,e),s=C("elementShape",n,t,e),i=C("dynamicSize",n,t,e),a=C("clearAfterRead",n,t,e),l=C("identicalElementShapes",n,t,e),u=C("name",n,t,e),c=new Fv(u,o,r,s,l,i,a);return e.addTensorArray(c),[c.idTensor,se(1)]}case"TensorArrayWriteV3":{let r=C("tensorArrayId",n,t,e),o=C("index",n,t,e),s=C("tensor",n,t,e),i=e.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=C("tensorArrayId",n,t,e),o=C("index",n,t,e);return[e.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=C("tensorArrayId",n,t,e),o=C("indices",n,t,e),s=C("dtype",n,t,e);return[e.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=C("tensorArrayId",n,t,e),o=C("indices",n,t,e),s=C("tensor",n,t,e),i=e.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=C("tensorArrayId",n,t,e),o=e.getTensorArray(r.id),s=C("dtype",n,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let r=C("tensorArrayId",n,t,e),o=C("tensor",n,t,e),s=C("lengths",n,t,e),i=e.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=C("tensorArrayId",n,t,e),o=e.getTensorArray(r.id);return[se(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=C("tensorArrayId",n,t,e),o=e.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=C("tensorListId",n,t,e),o=C("index",n,t,e),s=C("tensor",n,t,e),i=e.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=C("tensorListId",n,t,e),o=C("index",n,t,e),s=C("elementShape",n,t,e),i=C("elementDType",n,t,e);return[e.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=C("indices",n,t,e),o=C("tensor",n,t,e),s=C("elementShape",n,t,e),i=C("numElements",n,t,e),a=S3(o,r,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=C("elementShape",n,t,e),o=C("elementDType",n,t,e),s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=C(s,n,t,e),a=n.op==="TensorListReserve"?-1:i,l=I3(r,o,i,a);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=C("tensorListId",n,t,e),o=C("indices",n,t,e),s=C("elementShape",n,t,e),i=C("elementDType",n,t,e);return[e.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=C("tensorListId",n,t,e),o=C("elementShape",n,t,e),s=C("elementDType",n,t,e),i=C("numElements",n,t,e);return[e.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=C("tensor",n,t,e),o=C("elementShape",n,t,e),s=C("elementDType",n,t,e),i=C3(r,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=C("tensorListId",n,t,e),o=e.getTensorList(r.id),s=C("dtype",n,t,e),i=C("elementShape",n,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let r=C("tensorListId",n,t,e),o=C("tensor",n,t,e),s=e.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=C("tensorListId",n,t,e),o=C("elementShape",n,t,e),s=C("elementDType",n,t,e);return[e.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=C("tensor",n,t,e),o=C("elementShape",n,t,e),s=C("lengths",n,t,e),i=T3(r,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=C("tensorListId",n,t,e),o=e.getTensorList(r.id);return[se(o.size(),"int32")]}case"TensorListResize":{let r=C("tensorListId",n,t,e),o=C("size",n,t,e),i=e.getTensorList(r.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});function E3(n,t,e){let[r,o]=C("fusedOps",n,t,e),s=r==="biasadd",i=!s,a=o==="prelu",l=r==="fusedbatchnorm",u=C("numArgs",n,t,e);if(s){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=C("strides",n,t,e),p=Xm(n,t,e),f=C("dataFormat",n,t,e).toUpperCase(),d=C("dilations",n,t,e),[h,g]=C("args",n,t,e);i&&(g=h,h=void 0);let m=C("leakyreluAlpha",n,t,e);return{stride:c,pad:p,dataFormat:f,dilations:d,biasArg:h,preluArg:g,activationFunc:o,leakyreluAlpha:m}}var D3=(n,t,e,r=et)=>{switch(n.op){case"Conv1D":{let o=C("stride",n,t,e),s=C("pad",n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),a=C("dilation",n,t,e);return[r.conv1d(C("x",n,t,e),C("filter",n,t,e),o,s,i,a)]}case"Conv2D":{let o=C("strides",n,t,e),s=Xm(n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),a=C("dilations",n,t,e);return[r.conv2d(C("x",n,t,e),C("filter",n,t,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:p}=E3(n,t,e);return[r.fused.conv2d({x:C("x",n,t,e),filter:C("filter",n,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:p}=E3(n,t,e);return[r.fused.depthwiseConv2d({x:C("x",n,t,e),filter:C("filter",n,t,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=C("outputShape",n,t,e),s=C("strides",n,t,e),i=Xm(n,t,e);return[r.conv2dTranspose(C("x",n,t,e),C("filter",n,t,e),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=C("strides",n,t,e),s=Xm(n,t,e),i=C("dilations",n,t,e),a=C("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(C("input",n,t,e),C("filter",n,t,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),a=C("dilations",n,t,e);return[r.conv3d(C("x",n,t,e),C("filter",n,t,e),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[r.avgPool(C("x",n,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[r.maxPool(C("x",n,t,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("kernelSize",n,t,e),a=C("includeBatchInIndex",n,t,e),{result:l,indexes:u}=r.maxPoolWithArgmax(C("x",n,t,e),[i[1],i[2]],[o[1],o[2]],s,a);return[l,u]}case"AvgPool3D":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[r.avgPool3d(C("x",n,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[r.maxPool3d(C("x",n,t,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=C("strides",n,t,e),s=C("pad",n,t,e),i=C("dilations",n,t,e),a=o[1],l=o[2],u=i[1],c=i[2];return[r.dilation2d(C("x",n,t,e),C("filter",n,t,e),[a,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};var k3=(n,t,e,r=et)=>{switch(n.op){case"Fill":{let o=C("shape",n,t,e),s=C("dtype",n,t,e),i=C("value",n,t,e);return[r.fill(o,i,s)]}case"LinSpace":{let o=C("start",n,t,e),s=C("stop",n,t,e),i=C("num",n,t,e);return[r.linspace(o,s,i)]}case"Multinomial":{let o=C("logits",n,t,e),s=C("numSamples",n,t,e),i=C("seed",n,t,e);return[r.multinomial(o,s,i)]}case"OneHot":{let o=C("indices",n,t,e),s=C("depth",n,t,e),i=C("onValue",n,t,e),a=C("offValue",n,t,e),l=C("dtype",n,t,e);return[r.oneHot(o,s,i,a,l)]}case"Ones":return[r.ones(C("shape",n,t,e),C("dtype",n,t,e))];case"OnesLike":return[r.onesLike(C("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(C("shape",n,t,e),C("dtype",n,t,e),C("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(C("shape",n,t,e),C("minval",n,t,e),C("maxval",n,t,e),C("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt(C("shape",n,t,e),C("minval",n,t,e),C("maxval",n,t,e),C("seed",n,t,e))];case"Range":{let o=C("start",n,t,e),s=C("stop",n,t,e),i=C("step",n,t,e);return[r.range(o,s,i,C("dtype",n,t,e))]}case"TruncatedNormal":{let o=C("shape",n,t,e),s=C("mean",n,t,e),i=C("stdDev",n,t,e),a=C("seed",n,t,e);return[r.truncatedNormal(o,s,i,C("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(C("shape",n,t,e),C("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function gE(n,t,e){let r=C("boxes",n,t,e),o=C("scores",n,t,e),s=C("maxOutputSize",n,t,e),i=C("iouThreshold",n,t,e),a=C("scoreThreshold",n,t,e),l=C("softNmsSigma",n,t,e);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}var A3=(s,i,a,l,...u)=>z(void 0,[s,i,a,l,...u],function*(n,t,e,r,o=et){switch(n.op){case"NonMaxSuppressionV5":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h,softNmsSigma:g}=gE(n,t,e),m=yield o.image.nonMaxSuppressionWithScoreAsync(c,p,f,d,h,g);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=gE(n,t,e),g=C("padToMaxOutputSize",n,t,e),m=yield o.image.nonMaxSuppressionPaddedAsync(c,p,f,d,h,g);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:c,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=gE(n,t,e);return[yield o.image.nonMaxSuppressionAsync(c,p,f,d,h)]}case"Where":{let c=o.cast(C("condition",n,t,e),"bool"),p=[yield o.whereAsync(c)];return c.dispose(),p}case"ListDiff":return o.setdiff1dAsync(C("x",n,t,e),C("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}});var R3=(n,t,e,r=et)=>{switch(n.op){case"LowerBound":{let o=C("sortedSequence",n,t,e),s=C("values",n,t,e);return[r.lowerBound(o,s)]}case"TopKV2":{let o=C("x",n,t,e),s=C("k",n,t,e),i=C("sorted",n,t,e),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=C("sortedSequence",n,t,e),s=C("values",n,t,e);return[r.upperBound(o,s)]}case"Unique":{let o=C("x",n,t,e),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=C("x",n,t,e),s=C("axis",n,t,e),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};var _3=(n,t,e,r=et)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":let o=C("default",n,t,e);return[sn(n.name,t,e)||o];case"Placeholder":return[sn(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=C("x",n,t,e);return[os(c)]}case"IdentityN":return C("x",n,t,e).map(c=>os(c));case"Snapshot":let s=C("x",n,t,e);return[os(s)];case"Shape":return[r.tensor1d(C("x",n,t,e).shape,"int32")];case"ShapeN":return C("x",n,t,e).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(C("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(C("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=C("x",n,t,e),a=C("data",n,t,e),l=C("message",n,t,e),u=C("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var $v=class{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=se(0),this.tensorMap=new Map,Et(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return se(this.size(),"int32")}import(t,e){return z(this,null,function*(){this.checkKeyAndValueTensor(t,e);let r=yield t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),B(()=>{let o=pn(e),s=r.length,i=o.length;b.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let l=r[a],u=o[a];Et(u),this.tensorMap.set(l,u)}return this.handle})})}find(t,e){return z(this,null,function*(){this.checkKeyAndValueTensor(t,e);let r=yield t.data();return B(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,e);o.push(a)}return Lt(o)})})}findWithDefault(t,e){let r=this.tensorMap.get(t);return r??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var O3=(n,t,e,r)=>z(void 0,null,function*(){switch(n.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(n.name);if(o!=null)return[o];{let s=C("keyDType",n,t,e),i=C("valueDType",n,t,e),a=new $v(s,i);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=C("tableHandle",n,t,e,r),s=C("keys",n,t,e),i=C("values",n,t,e);return[yield r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=C("tableHandle",n,t,e,r),s=C("keys",n,t,e),i=C("defaultValue",n,t,e);return[yield r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=C("tableHandle",n,t,e,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});var M3=(n,t,e,r=et)=>{switch(n.op){case"ResizeBilinear":{let o=C("images",n,t,e),s=C("size",n,t,e),i=C("alignCorners",n,t,e),a=C("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=C("images",n,t,e),s=C("size",n,t,e),i=C("alignCorners",n,t,e),a=C("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=C("image",n,t,e),s=C("boxes",n,t,e),i=C("boxInd",n,t,e),a=C("cropSize",n,t,e),l=C("method",n,t,e),u=C("extrapolationValue",n,t,e);return[r.image.cropAndResize(o,s,i,a,l,u)]}case"ImageProjectiveTransformV3":{let o=C("images",n,t,e),s=C("transforms",n,t,e),i=C("outputShape",n,t,e),a=C("fillValue",n,t,e),l=C("interpolation",n,t,e),u=C("fillMode",n,t,e);return[r.image.transform(o,s,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};var F3=(n,t,e,r=et)=>{switch(n.op){case"Equal":return[r.equal(C("a",n,t,e),C("b",n,t,e))];case"NotEqual":return[r.notEqual(C("a",n,t,e),C("b",n,t,e))];case"Greater":return[r.greater(C("a",n,t,e),C("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(C("a",n,t,e),C("b",n,t,e))];case"Less":return[r.less(C("a",n,t,e),C("b",n,t,e))];case"LessEqual":return[r.lessEqual(C("a",n,t,e),C("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(C("a",n,t,e),C("b",n,t,e))];case"LogicalNot":return[r.logicalNot(C("a",n,t,e))];case"LogicalOr":return[r.logicalOr(C("a",n,t,e),C("b",n,t,e))];case"Select":case"SelectV2":return[r.where(C("condition",n,t,e),C("a",n,t,e),C("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd(C("a",n,t,e),C("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var $3=(n,t,e,r=et)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(C("a",n,t,e),C("b",n,t,e),C("transposeA",n,t,e),C("transposeB",n,t,e))];case"Einsum":return[r.einsum(C("equation",n,t,e),...C("tensors",n,t,e))];case"Transpose":return[r.transpose(C("x",n,t,e),C("perm",n,t,e))];case"_FusedMatMul":let[o,s]=C("fusedOps",n,t,e),i=o==="biasadd",a=s==="prelu",l=C("numArgs",n,t,e),u=C("leakyreluAlpha",n,t,e);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,p]=C("args",n,t,e);return[r.fused.matMul({a:C("a",n,t,e),b:C("b",n,t,e),transposeA:C("transposeA",n,t,e),transposeB:C("transposeB",n,t,e),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(C("a",n,t,e),C("numLower",n,t,e),C("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var P3=(n,t,e,r=et)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(C("x",n,t,e),C("axis",n,t,e),C("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(C("x",n,t,e),C("mean",n,t,e),C("variance",n,t,e),C("offset",n,t,e),C("scale",n,t,e),C("epsilon",n,t,e))];case"FusedBatchNormV3":return[r.batchNorm(C("x",n,t,e),C("mean",n,t,e),C("variance",n,t,e),C("offset",n,t,e),C("scale",n,t,e),C("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(C("x",n,t,e),C("radius",n,t,e),C("bias",n,t,e),C("alpha",n,t,e),C("beta",n,t,e))];case"Softmax":return[r.softmax(C("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var L3=(n,t,e,r=et)=>{switch(n.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(C("paramsNestedSplits",n,t,e),C("paramsDenseValues",n,t,e),C("indices",n,t,e),C("outputRaggedRank",n,t,e));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(C("starts",n,t,e),C("limits",n,t,e),C("splits",n,t,e));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(C("shape",n,t,e),C("values",n,t,e),C("defaultValue",n,t,e),C("rowPartitionTensors",n,t,e),C("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var B3=(n,t,e,r=et)=>{switch(n.op){case"Max":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.max(C("x",n,t,e),a,l)]}case"Mean":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.mean(C("x",n,t,e),a,l)]}case"Min":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.min(C("x",n,t,e),a,l)]}case"Sum":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.sum(C("x",n,t,e),a,l)]}case"All":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.all(C("x",n,t,e),a,l)]}case"Any":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.any(C("x",n,t,e),a,l)]}case"ArgMax":{let a=C("axis",n,t,e);return[r.argMax(C("x",n,t,e),a)]}case"ArgMin":{let a=C("axis",n,t,e);return[r.argMin(C("x",n,t,e),a)]}case"Prod":{let a=C("axis",n,t,e),l=C("keepDims",n,t,e);return[r.prod(C("x",n,t,e),a,l)]}case"Cumprod":{let a=C("axis",n,t,e),l=C("exclusive",n,t,e),u=C("reverse",n,t,e);return[r.cumprod(C("x",n,t,e),a,l,u)]}case"Cumsum":{let a=C("axis",n,t,e),l=C("exclusive",n,t,e),u=C("reverse",n,t,e);return[r.cumsum(C("x",n,t,e),a,l,u)]}case"Bincount":let o=C("x",n,t,e),s=C("weights",n,t,e),i=C("size",n,t,e);return[r.bincount(o,s,i)];case"DenseBincount":{let a=C("x",n,t,e),l=C("weights",n,t,e),u=C("size",n,t,e),c=C("binaryOutput",n,t,e);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};var z3=(n,t,e,r=et)=>{switch(n.op){case"ConcatV2":case"Concat":{let o=C("n",n,t,e),s=C("axis",n,t,e),i=C("tensors",n,t,e);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=C("x",n,t,e),s=C("indices",n,t,e);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=C("axis",n,t,e),s=C("batchDims",n,t,e),i=C("x",n,t,e),a=C("indices",n,t,e);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=C("dims",n,t,e),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=C("x",n,t,e);return[r.reverse(i,s)]}case"ReverseV2":{let o=C("axis",n,t,e),s=C("x",n,t,e);return[r.reverse(s,o)]}case"Slice":{let o=C("begin",n,t,e),s=C("size",n,t,e);return[r.slice(C("x",n,t,e),o,s)]}case"StridedSlice":{let o=C("begin",n,t,e),s=C("end",n,t,e),i=C("strides",n,t,e),a=C("beginMask",n,t,e),l=C("endMask",n,t,e),u=C("ellipsisMask",n,t,e),c=C("newAxisMask",n,t,e),p=C("shrinkAxisMask",n,t,e),f=C("x",n,t,e);return[r.stridedSlice(f,o,s,i,a,l,u,c,p)]}case"Pack":return B(()=>{let o=C("axis",n,t,e),s=C("tensors",n,t,e),i=s[0].shape,a=r.squeeze(s[0]).shape,l=s.map(u=>{let c=b.arraysEqual(u.shape,i);if(!c&&!b.arraysEqual(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,o)]});case"Unpack":{let o=C("axis",n,t,e),s=C("tensor",n,t,e);return r.unstack(s,o)}case"Tile":{let o=C("reps",n,t,e);return[r.tile(C("x",n,t,e),o)]}case"Split":case"SplitV":{let o=C("axis",n,t,e),s=C("numOrSizeSplits",n,t,e),i=C("x",n,t,e);return r.split(i,s,o)}case"ScatterNd":{let o=C("indices",n,t,e),s=C("values",n,t,e),i=C("shape",n,t,e);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=C("x",n,t,e),s=C("indices",n,t,e);return[r.gatherND(o,s)]}case"SparseToDense":{let o=C("sparseIndices",n,t,e),s=C("outputShape",n,t,e),i=C("sparseValues",n,t,e),a=C("defaultValue",n,t,e);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=C("indices",n,t,e),s=C("values",n,t,e),i=C("tensor",n,t,e);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};var V3=(n,t,e,r=et)=>{switch(n.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(C("indices",n,t,e),C("values",n,t,e),C("denseShape",n,t,e),C("defaultValue",n,t,e));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(C("inputIndices",n,t,e),C("inputShape",n,t,e),C("newShape",n,t,e));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(C("data",n,t,e),C("indices",n,t,e),C("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(C("data",n,t,e),C("indices",n,t,e),C("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var U3=(n,t,e,r=et)=>{switch(n.op){case"FFT":return[r.fft(C("x",n,t,e))];case"IFFT":return[r.ifft(C("x",n,t,e))];case"RFFT":return[r.rfft(C("x",n,t,e))];case"IRFFT":return[r.irfft(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var G3=(n,t,e,r=et)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(C("input",n,t,e),C("pattern",n,t,e),C("rewrite",n,t,e),C("replaceGlobal",n,t,e))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(C("data",n,t,e),C("dataSplits",n,t,e),C("separator",n,t,e),C("nGramWidths",n,t,e),C("leftPad",n,t,e),C("rightPad",n,t,e),C("padWidth",n,t,e),C("preserveShortSequences",n,t,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(C("input",n,t,e),C("delimiter",n,t,e),C("skipEmpty",n,t,e));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(C("input",n,t,e),C("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};var W3=(n,t,e,r=et)=>{switch(n.op){case"Cast":return[r.cast(C("x",n,t,e),C("dtype",n,t,e))];case"ExpandDims":{let o=C("axis",n,t,e);return[r.expandDims(C("x",n,t,e),o)]}case"Squeeze":{let o=C("axis",n,t,e);return[r.squeeze(C("x",n,t,e),o)]}case"Reshape":return[r.reshape(C("x",n,t,e),C("shape",n,t,e))];case"EnsureShape":return[r.ensureShape(C("x",n,t,e),C("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(C("x",n,t,e),C("padding",n,t,e),C("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(C("x",n,t,e),C("padding",n,t,e),C("constantValue",n,t,e))];case"SpaceToBatchND":{let o=C("blockShape",n,t,e),s=C("paddings",n,t,e);return[r.spaceToBatchND(C("x",n,t,e),o,s)]}case"BatchToSpaceND":{let o=C("blockShape",n,t,e),s=C("crops",n,t,e);return[r.batchToSpaceND(C("x",n,t,e),o,s)]}case"DepthToSpace":{let o=C("blockSize",n,t,e),s=C("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(C("x",n,t,e),o,s)]}case"BroadcastTo":return[r.broadcastTo(C("x",n,t,e),C("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(C("s0",n,t,e),C("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function yE(n,t,e,r,o=B){let s=((i,a,l)=>{switch(i.category){case"arithmetic":return o(()=>b3(i,a,l));case"basic_math":return o(()=>v3(i,a,l));case"control":return N3(i,a,l);case"convolution":return o(()=>D3(i,a,l));case"creation":return o(()=>k3(i,a,l));case"dynamic":return A3(i,a,l);case"evaluation":return o(()=>R3(i,a,l));case"image":return o(()=>M3(i,a,l));case"graph":return o(()=>_3(i,a,l));case"logical":return o(()=>F3(i,a,l));case"matrices":return o(()=>$3(i,a,l));case"normalization":return o(()=>P3(i,a,l));case"ragged":return o(()=>L3(i,a,l));case"reduction":return o(()=>B3(i,a,l));case"slice_join":return o(()=>z3(i,a,l));case"sparse":return o(()=>V3(i,a,l));case"spectral":return o(()=>U3(i,a,l));case"string":return o(()=>G3(i,a,l));case"transformation":return o(()=>W3(i,a,l));case"hash_table":return O3(i,a,l,r);case"custom":let u=wv(i.op);if(u&&u.customExecutor)return u.customExecutor(new Ov(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return b.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var Zm=class{constructor(t={},e={},r={},o={},s){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function xE(n,t,e,r){let o=new Set,s=[],i=null,a=null,l=new Set,u=new Set(Object.keys(n).map(f=>dr(f)[0]));r=r||[];let c=new Set(r.map(f=>dr(f.name)[0])),p=[...t];for(;p.length>0;){let f=p.pop();if((Yl(f)||Wse(f)||jse(f))&&i==null&&(i=f,a=i.children.map(d=>d.name).filter(d=>o.has(d))),o.add(f.name),e[f.name]==null&&!u.has(f.name)&&!c.has(f.name)){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),p.push(d))})}}return{inputs:n,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function j3(n,t){let{usedNodes:e,inputs:r}=t,o=Object.keys(r).map(m=>dr(m)[0]).map(m=>n.nodes[m]),s=n.initNodes||[],i=m=>e.has(typeof m=="string"?m:m.name);function a(m){return[...new Map(m.map(y=>[y.name,y])).values()]}let l=a([...o,...n.weights,...s]).filter(i),u=a([...l,...Object.values(n.nodes)]).filter(i),c=new Map(u.map(m=>[m.name,m])),p={};for(let m of u){p[m.name]=p[m.name]||0;for(let y of m.children)i(y)||(p[y.name]=Number.POSITIVE_INFINITY),p[y.name]=(p[y.name]||0)+1}let f=Object.entries(p).filter(([,m])=>m===0).map(([m])=>m),d=[...f];for(;f.length>0;){let m=f.pop(),y=c.get(m);for(let x of y.children.filter(i))--p[x.name]===0&&(d.push(x.name),f.push(x.name))}let h=d.map(m=>c.get(m)),g=Bse(h,l);return zse(g,l),g}function Bse(n,t){let e=new Map(n.map(i=>[i.name,i])),r=t.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=e.get(i);for(let l of a.children)!e.has(l.name)||o.has(l.name)||(o.add(l.name),r.push(l.name))}return n.filter(i=>o.has(i.name))}var Ud=class extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}};function zse(n,t){let e=new Map(n.map((a,l)=>[a.name,l])),r=new Set(t.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(n.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of n){for(let l of a.children.filter(i)){if(!e.has(l.name))throw new Ud(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new Ud(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!o(a))for(let l of a.inputs){if(!e.has(l.name))throw new Ud(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new Ud(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function H3(n){let t=new Map(n.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>Yl(a)?e:l),o=a=>{let l=r[t.get(a.name)];return l??-1},s=n.map((a,l)=>a.children.map(o).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let a=0;a<n.length;++a){let l=s[a];if(l===e)continue;let u=n[a],c=n[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}var Vse=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Use=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Gse=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Yl(n){return Vse.has(n.op)}function Wse(n){return Use.has(n.op)}function jse(n){return Gse.has(n.op)}var Qm=class n{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(r=>t[r].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new n(t.functions[r],this)})}getCompilationKey(t,e){let r=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(t,e){let r=xE(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let u=e.map(p=>p.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${o}]`)}let a=j3(this.graph,r),l=H3(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let e=t.clone();return Et(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=r.map(f=>this.graph.nodes[dr(f)[0]]),s=e.map(f=>dr(f)[0]),i=new Set(s),a=s.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);let l=this.getCompilationKey(o,a),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=L().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}let c={},p={};return B(()=>{let f=new Zm(this.weightMap,c,p,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[x,v]=dr(y,f),w=[];w[v]=t[y],d[x]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(w))});let h=this.getFrozenTensorIds(d),{orderedNodes:g,nodeLiveUntilMap:m}=u;for(let y of g){if(d[y.name])continue;let x=yE(y,d,f,this._resourceManager);if(b.isPromise(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,h,i,m.get(y.name))}return this.parent==null&&f.dispose(h),e.map(y=>sn(y,d,f))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,r,o,s,i,a){if(!(Yl(e)||i.has(t))){for(let l of r[t])l!=null&&(a[l.id]=(a[l.id]||0)+e.children.length);for(let l of e.inputs){if(Yl(l))continue;let u=XN(l.name,r,o);if(u!=null)for(let c of u){if(!c||c.kept||s.has(c.id))continue;let p=a[c.id];p===1?(c.dispose(),delete a[c.id]):p!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,o,s,i){function a(l){return Yl(l)||s.has(l.name)}if(!(Yl(t)||i==null))for(let l of i){if(a(l))continue;let u=XN(l.name,e,r);for(let c of u)!c||c.kept||o.has(c.id)||c.dispose()}}executeAsync(t,e){return z(this,null,function*(){return this._executeAsync(t,e)})}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(i,a){return z(this,arguments,function*(t,e,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=L().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let l=new Zm(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let u=yield this.executeWithControlFlow(t,l,e,r),c=e.map(h=>sn(h,u,l)),p=c.map(h=>h.id),f=Object.keys(t).map(h=>t[h].id),d=new Set([...p,...f,...this.weightIds]);return Object.values(u).forEach(h=>{h.forEach(g=>{g&&!g.isDisposed&&!d.has(g.id)&&g.dispose()})}),this.parent==null&&l.dispose(d),c})}executeFunctionAsync(t,e,r){return z(this,null,function*(){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,r)})}executeWithControlFlow(t,e,r,o){return z(this,null,function*(){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[dr(w)[0]]),a=r.map(w=>dr(w)[0]),l=new Set(a),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:p,dynamicNode:f,syncInputs:d}=xE(t,u,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),g=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[S,k]=dr(w),A=[];A[k]=t[w],g[S]=A});let m={},y=this.getFrozenTensorIds(g),x={};for(;h.length>0;){let w=this.processStack(i,h,e,g,x,y,l,m,c);yield Promise.all(w)}f==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let v=u.filter(w=>!Yl(w)&&!sn(w.name,g,e)).map(w=>w.name);if(v.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${w}`)}return g})}processStack(t,e,r,o,s,i,a,l,u){let c=[];for(;e.length>0;){let p=e.pop();r.currentContext=p.contexts;let f="";if(p.node.op==="Enter"&&C("isConstant",p.node,o,r)&&([f]=rs(p.node.name,r)),o[p.node.name]==null){let d=yE(p.node,o,r,this._resourceManager);f||([f]=rs(p.node.name,r));let h=r.currentContext;b.isPromise(d)?c.push(d.then(g=>(o[f]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(g)),r.currentContext=h,this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,u),g))):(o[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,u))}else this.processChildNodes(p.node,e,r,o,s,u)}return c}processChildNodes(t,e,r,o,s,i){t.children.forEach(a=>{let[l]=rs(a.name,r);s[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!sn(u,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!sn(u,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let r=t[e],[o]=dr(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);b.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;let o={};for(let s in t){let i=(r=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=t[s]:o[s]=t[s]}return o}checkInputs(t){let e=Object.keys(t).filter(r=>{let[o]=dr(r);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[e];return s!=null?s.name:e},{})}checkOutputs(t){t.forEach(e=>{let[r]=dr(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}};var Pv=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var Hse="?tfjs-format=file",qse="model.json",Lv=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=Yo){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,e==null&&(this.loadOptions={}),this.resourceManager=new Pv}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{let e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=this.handler.load();return b.isPromise(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){let e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}loadStreaming(t){return z(this,null,function*(){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let e=yield px(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)})}loadWithWeightMap(t,e){this.artifacts=t;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Qm(Ym.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=Ym.Instance.transformGraph(t.modelInitializer);this.initializer=new Qm(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){return z(this,null,function*(){if(typeof t=="string"){let r=this.io.getSaveHandlers(t);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)})}addStructuredOutputNames(t){if(this.structuredOutputKeys){let e=t instanceof Ke?[t]:t,r={};return e.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return t}predict(t,e){let r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){return z(this,null,function*(){let r=yield this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(r)})}normalizeInputs(t){var e;if(!(t instanceof Ke)&&!Array.isArray(t)){let s=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(t[i]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];let r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,l,u;let c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||u===void 0?void 0:u.resourceId;return c!=null?s[i]=this.resourceIdToCapturedInput[c]:s[i]=t[o++],s},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){return z(this,null,function*(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))})}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){let e=this.initializerSignature.outputs,r=Object.keys(e);for(let o=0;o<r.length;o++){let s=r[o],i=e[s];this.resourceIdToCapturedInput[i.resourceId]=t[o]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){return z(this,null,function*(){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(yield this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let r=yield this.executor.executeAsync(t,e);return r.length>1?r:r[0]})}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Se(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};function Nc(r){return z(this,arguments,function*(n,t={},e=Yo){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof n=="string"&&(n=Kse(n));let o=new Lv(n,t,e);return yield o.load(),o})}function Kse(n){return n.endsWith("/")||(n=n+"/"),`${n}${qse}${Hse}`}var tie=gh(Tm());var Jse=gh(Tm());var fSt=Symbol("out"),dSt=Symbol("field"),hSt=Symbol("quote"),mSt=Symbol("quoteafterquote"),gSt=Symbol("quoteinquote");function Z(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var fie=Un.whereImpl,K3=(()=>{class n extends Js{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Au(this,yo())}write(e,r,o){this.firstUse&&(this.firstUse=!1,L().get("IS_NODE")&&N.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:o,refCount:1}),s}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let r=this.data.get(e);r.refCount++}decRef(e){if(this.data.has(e)){let r=this.data.get(e);r.refCount--}}move(e,r,o,s,i){this.data.set(e,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){return z(this,null,function*(){return this.readSync(e)})}readSync(e){let{dtype:r,complexTensorInfos:o}=this.data.get(e);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return N.mergeRealAndImagArrays(s,i)}return b.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return de(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return de(e.shape,e.dtype,r)}makeOutput(e,r,o){return yo().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return z(this,null,function*(){let r=b.now();return e(),{kernelMs:b.now()-r}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Z([e],"where");let r=this.readSync(e.dataId);return fie(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();var YE={};yt(YE,{addImpl:()=>CE,bincountImpl:()=>jd,bincountReduceImpl:()=>Bv,bitwiseAndImpl:()=>IE,castImpl:()=>wE,ceilImpl:()=>SE,concatImpl:()=>zv,equalImpl:()=>TE,expImpl:()=>EE,expm1Impl:()=>kE,floorDivImpl:()=>RE,floorImpl:()=>AE,gatherNdImpl:()=>Vv,gatherV2Impl:()=>Uv,greaterEqualImpl:()=>OE,greaterImpl:()=>_E,lessEqualImpl:()=>FE,lessImpl:()=>ME,linSpaceImpl:()=>Gv,logImpl:()=>$E,maxImpl:()=>Wv,maximumImpl:()=>PE,minimumImpl:()=>LE,multiplyImpl:()=>Jm,negImpl:()=>BE,notEqualImpl:()=>zE,prodImpl:()=>VE,raggedGatherImpl:()=>jv,raggedRangeImpl:()=>Hv,raggedTensorToTensorImpl:()=>qv,rangeImpl:()=>Kv,rsqrtImpl:()=>GE,scatterImpl:()=>ss,sigmoidImpl:()=>TB,simpleAbsImpl:()=>vE,sliceImpl:()=>jE,sparseFillEmptyRowsImpl:()=>Xv,sparseReshapeImpl:()=>Yv,sparseSegmentReductionImpl:()=>qd,sqrtImpl:()=>DB,squaredDifferenceImpl:()=>HE,staticRegexReplaceImpl:()=>qE,stridedSliceImpl:()=>Zv,stringNGramsImpl:()=>Qv,stringSplitImpl:()=>Jv,stringToHashBucketFastImpl:()=>ew,subImpl:()=>XE,tileImpl:()=>tw,topKImpl:()=>nw,transposeImpl:()=>Hd,uniqueImpl:()=>rw});function vE(n){let t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}var die=n=>{let{x:t}=n.inputs,e=n.backend;Z(t,"abs");let r=new Float32Array(b.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return r=vE(o),e.makeOutput(r,t.shape,t.dtype)},X3={kernelName:ka,backendName:"cpu",kernelFunc:die};function ze(n){return(t,e,r,o,s)=>{let i=N.assertAndGetBroadcastShape(t,e),a=i.length,l=b.computeStrides(i),u=b.sizeFromShape(i),c=b.getTypedArrayFromDType(s,u),p=t.length,f=e.length,d=b.computeStrides(t),h=b.computeStrides(e),g=N.getBroadcastDims(t,i),m=N.getBroadcastDims(e,i);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=n(r[y%r.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let x=b.indexToLoc(y,a,l),v=x.slice(-p);g.forEach(A=>v[A]=0);let w=b.locToIndex(v,p,d),S=x.slice(-f);m.forEach(A=>S[A]=0);let k=b.locToIndex(S,f,h);c[y]=n(r[w],o[k])}return[c,i]}}function mn(n){let{inputs:t,backend:e}=n,{real:r,imag:o}=t,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(r.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var Y3={kernelName:Up,backendName:"cpu",kernelFunc:mn};function Gd(n,t,e="float32"){if(e==="complex64"){let o=Gd(n,t,"float32"),s=Gd(n,t,"float32");return mn({inputs:{real:o,imag:s},backend:n})}let r=b.makeZerosTypedArray(b.sizeFromShape(t),e);return n.makeTensorInfo(t,e,r)}function Gn(n){let{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Z3={kernelName:vs,backendName:"cpu",kernelFunc:Gn};function ko(n){let{inputs:t,backend:e}=n,{input:r}=t,o=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var Q3={kernelName:wf,backendName:"cpu",kernelFunc:ko};function wE(n,t,e,r){if(r==="int32"){let o=Int32Array.from(n);return[t,"int32",o]}if(r==="bool"){let o=b.toTypedArray([0],e),[s,i]=ze((a,l)=>a!==l?1:0)(t,[],n,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Ao(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Gn({inputs:{x:o},backend:e});let c=Gd(e,o.shape,o.dtype),p=Ao({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),f=mn({inputs:{real:p,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),f}if(o.dtype==="complex64"){let c=ko({inputs:{input:o},backend:e}),p=Ao({inputs:{x:c},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(c),p}if(!b.hasEncodingLoss(o.dtype,s)){let c=Gn({inputs:{x:o},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=e.data.get(o.dataId).values,[a,l,u]=wE(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,u)}var J3={kernelName:bs,backendName:"cpu",kernelFunc:Ao};function Xe(n,t,e,r){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;Z([i,a],n);let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=i.dtype==="string"?N.fromUint8ToStringArray(u):u,f=i.dtype==="string"?N.fromUint8ToStringArray(c):c,d=r||i.dtype,[h,g]=t(i.shape,a.shape,p,f,d);return l.makeTensorInfo(g,d,h)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let u=Ao({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),p=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,d=l.data.get(p.dataId).values,h=l.data.get(f.dataId).values,g=Ao({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),y=m.complexTensorInfos.real,x=m.complexTensorInfos.imag,v=l.data.get(y.dataId).values,w=l.data.get(x.dataId).values,[S,k,A]=e(i.shape,a.shape,d,h,v,w),_=l.makeTensorInfo(A,"float32",S),F=l.makeTensorInfo(A,"float32",k),$=mn({inputs:{real:_,imag:F},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(F),$}else{let u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,p=r||i.dtype,[f,d]=t(i.shape,a.shape,u,c,p);return l.makeTensorInfo(d,p,f)}}}function Wd(n){return(t,e,r,o,s,i)=>{let a=N.assertAndGetBroadcastShape(t,e),l=b.sizeFromShape(a),u=a.length,c=b.computeStrides(a),p=b.getTypedArrayFromDType("float32",l),f=b.getTypedArrayFromDType("float32",l),d=N.getBroadcastDims(t,a),h=N.getBroadcastDims(e,a),g=N.mergeRealAndImagArrays(r,o),m=N.mergeRealAndImagArrays(s,i),y=t.length,x=b.computeStrides(t),v=e.length,w=b.computeStrides(e);if(d.length+h.length===0)for(let S=0;S<p.length;S++){let k=S%g.length,A=S%m.length,_=n(g[k*2],g[k*2+1],m[A*2],m[A*2+1]);p[S]=_.real,f[S]=_.imag}else for(let S=0;S<p.length;S++){let k=b.indexToLoc(S,u,c),A=k.slice(-y);d.forEach(U=>A[U]=0);let _=b.locToIndex(A,y,x),F=k.slice(-v);h.forEach(U=>F[U]=0);let $=b.locToIndex(F,v,w),V=n(g[_*2],g[_*2+1],m[$*2],m[$*2+1]);p[S]=V.real,f[S]=V.imag}return[p,f,a]}}var CE=ze((n,t)=>n+t),hie=Wd((n,t,e,r)=>({real:n+e,imag:t+r})),Ps=Xe(Go,CE,hie),eB={kernelName:Go,backendName:"cpu",kernelFunc:Ps};function jd(n,t,e,r,o){let s=b.sizeFromShape(r),i=b.makeZerosTypedArray(o,e);for(let a=0;a<n.length;a++){let l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(s>0?i[l]+=t[a]:i[l]+=1)}return i}function Bv(n,t,e,r=!1){let o=n.shape[0],s=n.shape[1],i=de([o,e],t.dtype);for(let a=0;a<o;a++)for(let l=0;l<s;l++){let u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||(r?i.set(1,a,u):t.size>0?i.set(i.get(a,u)+t.get(a,l),a,u):i.set(i.get(a,u)+1,a,u))}return i}var IE=ze((n,t)=>n&t),mie=Xe(Mu,IE),tB={kernelName:Mu,backendName:"cpu",kernelFunc:mie};function Tn(n){return(t,e,r)=>{let o=b.getArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=n(t[s],r);return o}}function Ce(n,t,e){let r=Tn(t);return Sr(n,r,e)}function Sr(n,t,e){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;Z(i,n);let a=s,l=a.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=N.fromUint8ToStringArray(l)}else u=l;let c=e||i.dtype,p=t(u,c,o);return a.makeTensorInfo(i.shape,c,p)}}var SE=Tn(n=>Math.ceil(n)),gie=Sr(li,SE),nB={kernelName:li,backendName:"cpu",kernelFunc:gie};function zv(n,t,e,r){let o=b.getArrayFromDType(e,b.sizeFromShape(t));if(r&&e!=="string"){let s=0;n.forEach(i=>{let a=b.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;n.forEach(i=>{let a=e==="string"?N.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[l++]}s+=i.shape[1]})}return o}var TE=ze((n,t)=>n===t?1:0),NE=Xe(Fu,TE,null,"bool"),rB={kernelName:Fu,backendName:"cpu",kernelFunc:NE};var EE=Tn(n=>Math.exp(n)),DE=Sr(mi,EE,"float32"),oB={kernelName:mi,backendName:"cpu",kernelFunc:DE};var kE=Tn(n=>Math.expm1(n)),yie=Sr(gi,kE),sB={kernelName:gi,backendName:"cpu",kernelFunc:yie};var AE=Tn(n=>Math.floor(n)),xie=Sr(yi,AE),iB={kernelName:yi,backendName:"cpu",kernelFunc:xie};var RE=ze((n,t)=>Math.floor(n/t)),bie=Xe(xi,RE,null,"int32"),aB={kernelName:xi,backendName:"cpu",kernelFunc:bie};function Vv(n,t,e,r,o,s,i,a,l){let u=de([r,s],e);for(let c=0;c<r;c++){let p=[],f=0;for(let d=0;d<o;d++){let h=n[c*o+d];f+=h*i[d],p.push(h)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let d=0;d<s;d++)u.values[c*s+d]=t.get(...t.indexToLoc(f*s+d))}return u}function Uv(n,t,e){let r=de(e,n.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],l=i[2],u=t.locToIndex([a,l]);i[2]=t.values[u];let c=n.locToIndex(i);0<=c&&c<n.values.length&&(r.values[o]=n.values[c])}return r}var _E=ze((n,t)=>n>t?1:0),vie=Xe($u,_E,null,"bool"),lB={kernelName:$u,backendName:"cpu",kernelFunc:vie};var OE=ze((n,t)=>n>=t?1:0),wie=Xe(bi,OE,null,"bool"),uB={kernelName:bi,backendName:"cpu",kernelFunc:wie};var ME=ze((n,t)=>n<t?1:0),Cie=Xe(Pu,ME,null,"bool"),cB={kernelName:Pu,backendName:"cpu",kernelFunc:Cie};var FE=ze((n,t)=>n<=t?1:0),Iie=Xe(Lu,FE,null,"bool"),pB={kernelName:Lu,backendName:"cpu",kernelFunc:Iie};function Gv(n,t,e){let r=(t-n)/(e-1),o=b.makeZerosTypedArray(e,"float32");o[0]=n;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}var $E=Tn(n=>Math.log(n)),Sie=Sr(Ii,$E),fB={kernelName:Ii,backendName:"cpu",kernelFunc:Sie};function Wv(n,t,e,r){let o=b.getTypedArrayFromDType(r,b.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=n[i];for(let l=0;l<t;++l){let u=n[i+l];(Number.isNaN(u)||u>a)&&(a=u)}o[s]=a}return o}var PE=ze((n,t)=>Math.max(n,t)),Tie=Xe(Ti,PE),dB={kernelName:Ti,backendName:"cpu",kernelFunc:Tie};var LE=ze((n,t)=>Math.min(n,t)),Nie=Xe(Ni,LE),hB={kernelName:Ni,backendName:"cpu",kernelFunc:Nie};var Jm=ze((n,t)=>n*t),Eie=Wd((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),Ec=Xe(Di,Jm,Eie),mB={kernelName:Di,backendName:"cpu",kernelFunc:Ec};function BE(n,t,e){let r=b.createScalarValue(-1,e);return Jm([],t,r,n,e)}function Die(n){let{inputs:t,backend:e}=n,{x:r}=t;Z(r,"neg");let o=e.data.get(r.dataId).values,[s,i]=BE(o,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,s)}var gB={kernelName:nl,backendName:"cpu",kernelFunc:Die};var zE=ze((n,t)=>n!==t?1:0),kie=Xe(Uu,zE,null,"bool"),yB={kernelName:Uu,backendName:"cpu",kernelFunc:kie};function Hd(n,t,e,r,o){let s=t.length,i=b.sizeFromShape(t),a=b.computeStrides(t),l=b.computeStrides(o),u=b.getTypedArrayFromDType(e,b.sizeFromShape(o));for(let c=0;c<i;++c){let p=b.indexToLoc(c,s,a),f=new Array(p.length);for(let h=0;h<f.length;h++)f[h]=p[r[h]];let d=b.locToIndex(f,s,l);u[d]=n[c]}return u}function Ut(n){let{inputs:t,attrs:e,backend:r}=n,{x:o}=t,{perm:s}=e;Z(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let l=r.data.get(o.dataId).values,u=Hd(l,o.shape,o.dtype,s,a);return{dataId:r.write(u,a,o.dtype),shape:a,dtype:o.dtype}}var xB={kernelName:Cs,backendName:"cpu",kernelFunc:Ut};function VE(n,t,e,r){let[o,s]=N.computeOutAndReduceShapes(n,r),i=nn(t,"int32"),a=b.makeZerosTypedArray(b.sizeFromShape(o),i),l=b.sizeFromShape(s);for(let u=0;u<a.length;++u){let c=u*l,p=1;for(let f=0;f<l;++f)p*=e[c+f];a[u]=p}return{outVals:a,outShape:o,outDtype:i}}function Aie(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;Z(o,"prod");let a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=N.getAxesPermutation(l,a),c=l,p=o,f=[];u!=null&&(p=Ut({inputs:{x:o},backend:e,attrs:{perm:u}}),f.push(p),c=N.getInnerMostAxes(c.length,a));let d=e.data.get(p.dataId).values,{outVals:h,outShape:g,outDtype:m}=VE(p.shape,p.dtype,d,c),y=g;return i&&(y=N.expandShapeToKeepDim(g,l)),f.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(y,m,h)}var bB={kernelName:ll,backendName:"cpu",kernelFunc:Aie};function Rie(n,t,e){n.forEach((r,o)=>{if(r<0||r>=e){let s=b.indexToLoc(o,t.length,b.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}function _ie(n,t){for(let e=0;e<n.length;++e){let r=n[e],o=e===n.length-1?t:n[e+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Oie(n,t,e,r){let o=[],s=0,i=t.length-1+e.length,a=new Array(i).fill(null).map(()=>[0]);_ie(e,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let p=1;p<l+1;++p)a[u].push(p*c)}for(let u=0;u<n.length;++u){let c=n[u],p=n[u]+1;for(let f=0;f<e.length;++f){let d=e[f],h=f+t.length-1;if(h>=0){let g=a[h],m=g[g.length-1]-d[c];for(let y=c;y<p;++y)a[h].push(d[y+1]+m)}c=d[c],p=d[p]}p!==c&&(o.push([c,p]),s+=p-c)}return{outSplits:a,valueSlices:o,numValues:s}}function Mie(n){let t=[];for(let e=0;e<n.length;++e){let r=n[e].length,o=b.getArrayFromDType("int32",r);t.push(o),n[e].forEach((s,i)=>o[i]=s)}return t}function vB(n,t){let e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function Fie(n,t,e,r,o,s){let i=vB(t,2)[1],a=vB(s,2)[1],l=0;for(let u of e)for(let c=u[0];c<u[1];++c){for(let p=0;p<r;++p)o[l*a+p]=n[c*i+p];++l}}function $ie(n,t,e,r,o){let s=t.slice();s[0]=o;let i=b.getArrayFromDType(e,b.sizeFromShape(s)),a=n.length,l=a===0?0:a/t[0];return Fie(n,t,r,l,i,s),[i,s]}function jv(n,t,e,r,o,s,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(Rie(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:p,numValues:f}=Oie(s,i,n,u),d=Mie(c),h=$ie(e,r,o,p,f);return[d,h[0],h[1]]}var wB=2147483647;function Hv(n,t,e,r,o,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=t.length===0,l=o.length===0,u=i.length===0,c=[];a||c.push(t[0]),l||c.push(o[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");let p=c.length===0?1:c[0],f=b.getArrayFromDType("int32",p+1);f[0]=0;for(let m=0;m<p;++m){let y=a?n[0]:n[m],x=l?r[0]:r[m],v=u?s[0]:s[m];if(v===0)throw new Error("Requires delta != 0");let w;if(v>0&&x<y||v<0&&x>y)w=0;else if(w=Math.ceil(Math.abs((x-y)/v)),w>wB)throw new Error(`Requires ((limit - start) / delta) <= ${wB}`);f[m+1]=f[m]+w}let d=f[p],h=b.getArrayFromDType(e,d),g=0;for(let m=0;m<p;++m){let y=f[m+1]-f[m],x=a?n[0]:n[m],v=u?s[0]:s[m];for(let w=0;w<y;++w)h[g++]=x,x+=v}return[f,h]}var Ro=N.RowPartitionType,UE=class n{constructor(t,e,r,o,s,i,a,l,u,c){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=N.getRowPartitionTypesHelper(c),this.raggedRank=N.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ro.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ro.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ro.VALUE_ROWIDS:return n.getMaxWidthValueRowID(e);case Ro.ROW_SPLITS:return n.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ro[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let e=t.length;if(e===0||e===1)return 0;let r=0;for(let o=0;o<e-1;++o){let s=t[o+1]-t[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){let e=t.length;if(e===0)return 0;let r=0,o=t[0],s=0;for(let i=1;i<e;++i){let a=t[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(e-r,s)}tensorShapeFromTensor(t,e,r=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return IB(t,r)}calculateOutputSize(t){let e=this.valuesShape,r=this.defaultValueShape;N.validateDefaultValueShape(r,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=N.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);i[0]<0&&(i[0]=t);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(t,e,r){let o=Math.min(t,r),s=[],i=0;for(let a=0;a<o;++a,i+=e)s.push(i);for(let a=o;a<t;++a)s.push(-1);return b.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,r,o){let s=t.length,i=[];for(let a=0;a<s-1;++a){let l=t[a+1]-t[a],u=Math.min(o,l),c=e[a];c===-1&&(u=0);for(let p=0;p<u;++p)i.push(c),c+=r;for(let p=0;p<l-u;++p)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,r,o){let s=t.length,i=[];if(s===0)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];i.push(u);for(let c=1;c<s;++c){let p=t[c];if(p===l)u>=0&&(++a,a<o?u+=r:u=-1);else{if(a=0,l=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);u=e[p]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,r,o){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Ro.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,o);case Ro.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,o);default:throw new Error(`Unsupported partition type: ${Ro[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Ro.FIRST_DIM_SIZE:return t[0];case Ro.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ro.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ro[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let l=o.length-2;l>=0;--l)o[l]=o[l+1]*r[l+1];let s=IB(r,!1),i=b.getArrayFromDType(this.valuesDType,b.sizeFromShape(s));if(o[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,o[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,o[u],r[u]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(t,e,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(t+1);let l=b.sizeFromShape(a),u=e.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let h=this.defaultValueShape;B(()=>{let g=O(c,h);c=Ds(g,a).dataSync()})}let p=0,f=0,d=0;for(let h=0;h<=u;++h){let g=h<u?e[h]:-1;if(g===d){++d;continue}if(f<d){let m=s.subarray(p*l),y=i.subarray(f*l),x=(d-f)*l;CB(y,m,x)}if(h>=u){let m=r.length;g=Math.floor(m/l)}if(g>d)if(this.defaultValue.length===1)i.subarray(d*l,g*l).fill(this.defaultValue[0]),d=g;else for(;g>d;){let m=i.slice(d*l);CB(m,c,l),++d}g<0?(p=h+1,f=d):(p=h,f=d,d=f+1)}}};function CB(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function IB(n,t){let e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function qv(n,t,e,r,o,s,i,a,l,u){return new UE(n,t,e,r,o,s,i,a,l,u).compute()}function Kv(n,t,e,r){let o=n===t,s=n<t&&e<0,i=t<n&&e>1;if(o||s||i)return b.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-n)/e)),l=b.makeZerosTypedArray(a,r);t<n&&e===1&&(e=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}var GE=Tn(n=>1/Math.sqrt(n)),Pie=Sr(Mi,GE),SB={kernelName:Mi,backendName:"cpu",kernelFunc:Pie};function ss(n,t,e,r,o,s,i,a,l,u){let c=[r/o,o],p=n.values,f=t.values;if(r===0)return de(e,t.dtype);let d=l instanceof tt?l:de(c,t.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let h=0;h<s;h++){let g=[],m=0;for(let y=0;y<i;y++){let x=p[h*i+y];g.push(x),m+=x*a[y]}if(m<0||m>=r/o)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<o;y++)u?d.values[m*o+y]+=f[h*o+y]:d.values[m*o+y]=t.rank===0?f[0]:f[h*o+y]}return d}var TB=Tn(n=>1/(1+Math.exp(-n))),WE=Ce(Bi,n=>1/(1+Math.exp(-n))),NB={kernelName:Bi,backendName:"cpu",kernelFunc:WE};function jE(n,t,e,r,o){let s=Cn.isSliceContinous(r,t,e),i=b.sizeFromShape(e),a=b.computeStrides(r);if(s){let p=Cn.computeFlatOffset(t,a);return o==="string"?n.slice(p,p+i):n.subarray(p,p+i)}let l=o==="string"?N.fromUint8ToStringArray(n):n,u=de(r,o,l),c=de(e,o);for(let p=0;p<c.size;++p){let f=c.indexToLoc(p),d=f.map((h,g)=>h+t[g]);c.set(u.get(...d),...f)}return o==="string"?N.fromStringArrayToUint8(c.values):c.values}function _o(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{begin:s,size:i}=r;Z(o,"slice");let[a,l]=Cn.parseSliceParams(o,s,i);Cn.assertParamsValid(o,a,l);let u=e.data.get(o.dataId).values,c=jE(u,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,c)}var EB={kernelName:hl,backendName:"cpu",kernelFunc:_o};function Xv(n,t,e,r,o,s,i){let a=t[0],l=s[0],u=new Array(l),c=new Array(a),p=t[1];if(l===0){if(a!==0)throw new Error(N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let m=b.getArrayFromDType(e,0),y=b.getArrayFromDType(o,0);return[m,[0,p],y,u,c]}let f=!0,d=0,h=new Array(l).fill(0);for(let m=0;m<a;++m){let y=n[m*p];if(y<0)throw new Error(N.getSparseFillEmptyRowsNegativeIndexErrorMessage(m,y));if(y>=l)throw new Error(N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(m,y,l));++h[y],f=f&&y>=d,d=y}let g=!0;for(let m=0;m<l;++m){let y=h[m]===0;u[m]=y,g=g&&!y,h[m]=Math.max(h[m],1),m>0&&(h[m]+=h[m-1])}if(g&&f){let m=n,y=r;for(let x=0;x<a;++x)c[x]=x;return[m,[a,p],y,u,c]}else{let m=h[l-1],y=b.getArrayFromDType(e,m*p),x=b.getArrayFromDType(o,m),v=new Array(l).fill(0);for(let w=0;w<a;++w){let S=n[w*p],k=v[S],A=(S===0?0:h[S-1])+k;v[S]++;for(let _=0;_<p;++_)y[A*p+_]=n[w*p+_];x[A]=r[w],c[w]=A}for(let w=0;w<l;++w)if(v[w]===0){let k=w===0?0:h[w-1];y[k*p+0]=w;for(let A=1;A<p;++A)y[k*p+A]=0;x[k]=i}return[y,[m,p],x,u,c]}}function Yv(n,t,e,r,o){let s=b.sizeFromShape(r),i=t[0],a=o.length,l=[],u=1,c=-1;for(let m=0;m<a;++m){let y=o[m];if(y===-1){if(c!==-1)throw new Error(N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(N.getSparseReshapeNegativeOutputDimErrorMessage(m,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/u);if(u*m!==s)throw new Error(N.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=m}if(b.sizeFromShape(l)!==s)throw new Error(N.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let f=r.length,d=[];if(f>0){d[f-1]=1;for(let m=f-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let h=[];if(a>0){h[a-1]=1;for(let m=a-2;m>=0;--m)h[m]=h[m+1]*l[m+1]}let g=b.getArrayFromDType(e,i*a);for(let m=0;m<i;++m){let y=0;for(let x=0;x<f;++x)y+=n[m*f+x]*d[x];for(let x=0;x<a;++x)g[m*a+x]=Math.trunc(y/h[x]),y%=h[x]}return[g,[i,a],l]}function qd(n,t,e,r,o,s=!1,i=0){let a=r.length,l=[t[0],n.length/t[0]],u=l[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=t.slice();f[0]=p;let d=f.reduce((v,w)=>v*w,1),h=b.getArrayFromDType(e,d);if(a===0)return p>0&&h.fill(i),[h,f];if(p<=0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,m=1,y=0,x=o[g];for(;;){let v=0;if(m<a){if(v=o[m],x===v){++m;continue}if(x>=v)throw new Error(N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=p)throw new Error(N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,p));x>y&&h.fill(i,y*u,x*u);for(let w=g;w<m;++w){let S=r[w];if(S<0||S>=l[0])throw new Error(N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,r[w],l[0]));for(let k=0;k<u;k++)h[x*u+k]+=n[S*u+k]}if(s)for(let w=0;w<u;w++)h[x*u+w]/=m-g;if(g=m,++m,y=x+1,x=v,m>a)break}return y<p&&h.fill(i,y*u,p*u),[h,f]}var DB=Tn(n=>Math.sqrt(n)),Lie=Ce(Vi,n=>Math.sqrt(n)),kB={kernelName:Vi,backendName:"cpu",kernelFunc:Lie};var HE=ze((n,t)=>{let e=n-t;return e*e}),Bie=Xe(Ui,HE),AB={kernelName:Ui,backendName:"cpu",kernelFunc:Bie};var qE=Tn((n,t)=>{let{pattern:e,replaceGlobal:r,rewrite:o}=t;return n.replace(new RegExp(e,r?"g":""),o)}),zie=Sr(Gu,qE),RB={kernelName:Gu,backendName:"cpu",kernelFunc:zie};function Zv(n,t,e,r){let o=de(n,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];o.set(t.get(...a),...i)}return o}var KE=class{constructor(t,e,r,o,s,i){this.separator=b.encodeString(t),this.nGramWidths=e,this.leftPad=b.encodeString(r),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,o,s,i){for(let a=0;a<s;++a){let l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(s-(a+1))),p=i-(u+c),f=e+(u>0?0:a-l),d=0;d+=u*this.leftPad.length;for(let x=0;x<p;++x)d+=t[f+x].length;d+=c*this.rightPad.length;let h=u+c+p-1;d+=h*this.separator.length,r[o+a]=new Uint8Array(d);let g=r[o+a],m=0,y=x=>x.forEach(v=>g[m++]=v);for(let x=0;x<u;++x)y(this.leftPad),y(this.separator);for(let x=0;x<p-1;++x)y(t[f+x]),y(this.separator);if(p>0){y(t[f+p-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let r=t.length,o=e.length;if(o>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<o;++u){let c=e[u]>=l;if(c=c&&e[u]<=r,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${r}]`);l=e[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}let s=o-1,i=b.getArrayFromDType("int32",o);if(r===0||o===0){let l=new Array(r);for(let u=0;u<=s;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){let u=e[l]-e[l-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(u,p)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}let a=new Array(i[s]);for(let l=0;l<s;++l){let u=e[l],c=i[l];if(this.nGramWidths.forEach(p=>{let f=e[l+1]-e[l],d=this.getNumNGrams(f,p);this.createNGrams(t,u,a,c,d,p),c+=d}),this.preserveShort&&c===i[l]){let p=e[l+1]-e[l];if(p===0)continue;let f=p+2*this.padWidth;this.createNGrams(t,u,a,c,1,f)}}return[a,i]}};function Qv(n,t,e,r,o,s,i,a){return new KE(e,r,o,s,i,a).compute(n,t)}function Vie(n,t,e,r){if(!n.length)return;if(t.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=n.indexOf(s);for(;i!==-1;){let a=n.subarray(0,i);(!e||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(s)}(!e||n.length!==0)&&r.push(n);return}let o=0;for(let s=0;s<n.length+1;s++)if(s===n.length||t.indexOf(n[s])!==-1){let i=n.subarray(o,s);(!e||i.length!==0)&&r.push(i),o=s+1}}function Jv(n,t,e){let r=n.length,o=[],s=0,i=0,a=new Array(r);for(let f=0;f<r;++f){let d=o.length;Vie(n[f],t,e,o);let h=o.length-d;a[f]=h,s+=h,i=Math.max(i,h)}let l=b.getArrayFromDType("int32",s*2),u=new Array(s),c=[r,i],p=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[p*2]=f,l[p*2+1]=d,u[p]=o[p],++p;return[l,u,c]}function ew(n,t){let e=b.getArrayFromDType("int32",n.length);for(let r=0;r<n.length;++r)e[r]=b.fingerPrint64(n[r]).modulo(t).getLowBitsUnsigned();return e}var XE=ze((n,t)=>n-t),Uie=Wd((n,t,e,r)=>({real:n-e,imag:t-r})),eg=Xe(Gi,XE,Uie),_B={kernelName:Gi,backendName:"cpu",kernelFunc:eg};function tw(n,t){let e=new Array(n.rank);for(let o=0;o<e.length;o++)e[o]=n.shape[o]*t[o];let r=de(e,n.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%n.shape[l];let a=n.locToIndex(i);r.values[o]=n.values[a]}return r}var tg=(n,t)=>{let e=t.value-n.value;return e===0?n.index-t.index:e};function OB(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){let a=r-e+1,l=t-e+1,u=Math.log(a),c=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),f=Math.max(e,Math.floor(t-l*c/a+p)),d=Math.min(r,Math.floor(t+(a-l)*c/a+p));OB(n,t,f,d)}let o=n[t],s=e,i=r;for(b.swap(n,e,t),tg(n[r],o)>0&&b.swap(n,e,r);s<i;){for(b.swap(n,s,i),s++,i--;tg(n[s],o)<0;)s=s+1;for(;tg(n[i],o)>0;)i=i-1}tg(n[e],o)===0?b.swap(n,e,i):(i=i+1,b.swap(n,i,r)),i<=t&&(e=i+1),t<=i&&(r=i-1)}}function nw(n,t,e,r,o){let s=t[t.length-1],[i,a]=[n.length/s,s],l=b.getTypedArrayFromDType(e,i*r),u=b.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let f=p*a,d=n.subarray(f,f+a),h=new Array(d.length);d.forEach((x,v)=>h[v]={value:x,index:v}),r<h.length&&(OB(h,r),h=h.slice(0,r)),o&&h.sort(tg);let g=p*r,m=l.subarray(g,g+r),y=u.subarray(g,g+r);for(let x=0;x<r;x++)m[x]=h[x].value,y[x]=h[x].index}let c=t.slice();return c[c.length-1]=r,[de(c,e,l),de(c,"int32",u)]}function rw(n,t,e,r){let o=b.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let h=0;h<o;h++)s[0]*=e[h];s[1]=e[o];for(let h=o+1;h<e.length;h++)s[2]*=e[h];let i=new Map,a=new Int32Array(e[o]),l=new tt(s,r,n),u=[],c=s[0]===1&&s[2]===1;for(let h=0;h<e[o];h++){let g;if(c)g=n[h].toString();else{let y=[];for(let x=0;x<s[0];x++)for(let v=0;v<s[2];v++)y.push(l.get(x,h,v));g=y.join(",")}let m=i.get(g);if(m!=null)a[h]=m;else{let y=i.size;i.set(g,y),a[h]=y,u.push(h)}}let p=s.slice();p[1]=i.size;let f=new tt(p,r);u.forEach((h,g)=>{for(let m=0;m<s[0];m++)for(let y=0;y<s[2];y++)f.set(l.get(m,h,y),m,g,y)});let d=e.slice();return d[o]=p[1],{outputValues:f.values,outputShape:d,indices:a}}lx("cpu",()=>new K3,1);var ZE=Ce(di,n=>n>=0?n:Math.exp(n)-1),MB={kernelName:di,backendName:"cpu",kernelFunc:ZE};function QE(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{alpha:s}=r;Z([o],"leakyRelu");let i=b.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,l=b.getTypedArrayFromDType("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?s*a[u]:a[u];return e.makeTensorInfo(o.shape,"float32",l)}var FB={kernelName:Ka,backendName:"cpu",kernelFunc:QE};var Gie=ze((n,t)=>n<0?t*n:n);function JE(n){let{inputs:t,backend:e}=n,{x:r,alpha:o}=t;Z([r,o],"prelu");let s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,[a,l]=Gie(r.shape,o.shape,s,i,"float32");return e.makeTensorInfo(l,"float32",a)}var $B={kernelName:al,backendName:"cpu",kernelFunc:JE};var e1=Ce(Ri,n=>Math.max(0,n)),PB={kernelName:Ri,backendName:"cpu",kernelFunc:e1};var t1=Ce(_i,n=>Math.min(Math.max(0,n),6)),LB={kernelName:_i,backendName:"cpu",kernelFunc:t1};function Dc(n,t,e,r,o){if(e==="linear")return Gn({inputs:{x:t},backend:n});if(e==="relu")return e1({inputs:{x:t},backend:n});if(e==="elu")return ZE({inputs:{x:t},backend:n});if(e==="relu6")return t1({inputs:{x:t},backend:n});if(e==="prelu")return JE({inputs:{x:t,alpha:r},backend:n});if(e==="leakyrelu")return QE({inputs:{x:t},backend:n,attrs:{alpha:o}});if(e==="sigmoid")return WE({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Ve(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{shape:s}=r,i=b.sizeFromShape(o.shape),a=b.inferFromImplicitShape(s,i),l=b.sizeFromShape(a);b.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let u=e.data.get(o.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var BB={kernelName:ul,backendName:"cpu",kernelFunc:Ve};function n1(n){let{inputs:t,backend:e,attrs:r}=n,{a:o,b:s}=t,{transposeA:i,transposeB:a}=r;Z([o,s],"matMul");let l=o.shape.length,u=s.shape.length,c=i?o.shape[l-2]:o.shape[l-1],p=a?s.shape[u-1]:s.shape[u-2],f=i?o.shape[l-1]:o.shape[l-2],d=a?s.shape[u-2]:s.shape[u-1],h=o.shape.slice(0,-2),g=s.shape.slice(0,-2),m=b.sizeFromShape(h),y=b.sizeFromShape(g),v=Or.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,d]);b.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let w=i?[m,c,f]:[m,f,c],S=a?[y,d,p]:[y,p,d],k=Ve({inputs:{x:o},backend:e,attrs:{shape:w}}),A=Ve({inputs:{x:s},backend:e,attrs:{shape:S}}),_=i?k.shape[1]:k.shape[2],F=i?k.shape[2]:k.shape[1],$=a?A.shape[1]:A.shape[2],V=Math.max(m,y),U=e.data.get(k.dataId).values,W=e.data.get(A.dataId).values,G=b.computeStrides(k.shape),H=b.computeStrides(A.shape),[K,Q,X]=i?[G[0],1,G[1]]:[G[0],G[1],1],[J,re,oe]=a?[1,H[1],H[0]]:[H[1],1,H[0]],le=F*$,ae=de([V,F,$],k.dtype),pe=ae.values,ue=e.blockSize;for(let he=0;he<V;he++){let Ie=he%m,Ae=he%y;for(let Ee=0;Ee<F;Ee+=ue){let Ge=Math.min(Ee+ue,F);for(let He=0;He<$;He+=ue){let It=Math.min(He+ue,$);for(let Rt=0;Rt<_;Rt+=ue){let tn=Math.min(Rt+ue,_);for(let _t=Ee;_t<Ge;_t++)for(let Nt=He;Nt<It;Nt++){let en=0;for(let qt=Rt;qt<tn;qt++){let Us=U[Ie*K+_t*Q+qt*X],Fn=W[qt*J+Nt*re+Ae*oe];en+=Us*Fn}pe[he*le+(_t*$+Nt)]+=en}}}}}return e.disposeIntermediateTensorInfo(k),e.disposeIntermediateTensorInfo(A),e.makeTensorInfo(v,ae.dtype,ae.values)}var zB={kernelName:Fa,backendName:"cpu",kernelFunc:n1};function Wie(n){let{inputs:t,backend:e,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,f,d,h,g=[];f=n1({inputs:{a:o,b:s},attrs:{transposeA:l,transposeB:u},backend:e}),i&&(d=Ps({inputs:{a:f,b:i},backend:e}),g.push(f),f=d),c&&(h=Dc(e,f,c,a,p),g.push(f),f=h);for(let y of g)e.disposeIntermediateTensorInfo(y);return f}var VB={kernelName:Wu,backendName:"cpu",kernelFunc:Wie};var jie=Ce(ti,n=>Math.acos(n)),UB={kernelName:ti,backendName:"cpu",kernelFunc:jie};var Hie=Ce(ni,n=>Math.acosh(n)),GB={kernelName:ni,backendName:"cpu",kernelFunc:Hie};function qie(n){let{inputs:t,backend:e}=n,r=t;Z(t,"addN");let o=r.map(a=>e.data.get(a.dataId).values),s=de(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let l=o[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var WB={kernelName:Aa,backendName:"cpu",kernelFunc:qie};function Kie(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;Z(o,"all");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Ut({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let S=g[x+w];v=v&&S}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=Ve({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var jB={kernelName:$p,backendName:"cpu",kernelFunc:Kie};function Xie(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;Z(o,"any");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Ut({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let S=g[x+w];v=v||S}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=Ve({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var HB={kernelName:Pp,backendName:"cpu",kernelFunc:Xie};function Yie(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s}=r;Z(o,"argMax");let i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Ut({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,p]=N.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(c),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],v=0;for(let w=0;w<h;++w){let S=g[y+w];S>x&&(x=S,v=w)}d[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",d)}var qB={kernelName:Ra,backendName:"cpu",kernelFunc:Yie};function Zie(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s}=r;Z(o,"argMin");let i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=Ut({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,p]=N.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(c),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],v=0;for(let w=0;w<h;++w){let S=g[y+w];S<x&&(x=S,v=w)}d[m]=v}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",d)}var KB={kernelName:_a,backendName:"cpu",kernelFunc:Zie};var Qie=Ce(ri,n=>Math.asin(n)),XB={kernelName:ri,backendName:"cpu",kernelFunc:Qie};var Jie=Ce(oi,n=>Math.asinh(n)),YB={kernelName:oi,backendName:"cpu",kernelFunc:Jie};var eae=Ce(si,n=>Math.atan(n)),ZB={kernelName:si,backendName:"cpu",kernelFunc:eae};var tae=ze((n,t)=>Math.atan2(n,t)),nae=Xe(ai,tae),QB={kernelName:ai,backendName:"cpu",kernelFunc:nae};var rae=Ce(ii,n=>Math.atanh(n)),JB={kernelName:ii,backendName:"cpu",kernelFunc:rae};function Kd(n,t,e,r,o,s){let i=o.strideHeight,a=o.strideWidth,l=o.dilationHeight,u=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,f=o.padInfo.top,d=o.padInfo.left,h=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=de(o.outShape,e),m=g.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],v=o.outShape[3];for(let w=0;w<o.batchSize;++w){let S=w*y,k=w*r[0];for(let A=0;A<o.inChannels;++A)for(let _=0;_<o.outHeight;++_){let F=_*i-f,$=Math.max(0,F),V=Math.min(o.inHeight,c+F),U=S+_*x;for(let W=0;W<o.outWidth;++W){let G=W*a-d,H=Math.max(0,G),K=Math.min(o.inWidth,p+G),Q=h,X=0,J=0;for(let oe=$;oe<V;oe+=l){let le=k+oe*r[1];for(let ae=H;ae<K;ae+=u){let pe=le+ae*r[2],ue=n[pe+A];s==="max"&&ue>Q?Q=ue:s==="avg"&&(X+=ue,J++)}if(isNaN(Q))break}let re=U+W*v+A;m[re]=s==="avg"?X/J:Q}}}return g}function ow(n,t,e,r,o=!1,s=!1){let i=de(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,h=r.padInfo.left,g=de(t,e,n);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let x=0;x<r.outHeight;++x){let v=x*a-d,w=v;for(;w<0;)w+=u;let S=Math.min(r.inHeight,p+v);for(let k=0;k<r.outWidth;++k){let A=k*l-h,_=A;for(;_<0;)_+=c;let F=Math.min(r.inWidth,f+A),$=Number.NEGATIVE_INFINITY,V=-1;for(let U=w;U<S;U+=u){let W=U-v;for(let G=_;G<F;G+=c){let H=G-A,K=g.get(m,U,G,y);K>$&&($=K,o?V=s?((m*r.inHeight+U)*r.inWidth+G)*r.inChannels+y:(U*r.inWidth+G)*r.inChannels+y:V=W*f+H)}}i.set(V,m,x,k,y)}}return i}function sw(n,t,e,r,o,s){let i=o.strideDepth,a=o.strideHeight,l=o.strideWidth,u=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,f=o.effectiveFilterDepth,d=o.effectiveFilterHeight,h=o.effectiveFilterWidth,g=o.padInfo.front,m=o.padInfo.top,y=o.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=de(o.outShape,e),w=v.values,S=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],k=o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[3]*o.outShape[4],_=o.outShape[4];for(let F=0;F<o.batchSize;++F){let $=F*S,V=F*r[0];for(let U=0;U<o.inChannels;++U)for(let W=0;W<o.outDepth;++W){let G=W*i-g,H=G;for(;H<0;)H+=u;let K=Math.min(o.inDepth,f+G),Q=$+W*k;for(let X=0;X<o.outHeight;++X){let J=X*a-m,re=J;for(;re<0;)re+=c;let oe=Math.min(o.inHeight,d+J),le=Q+X*A;for(let ae=0;ae<o.outWidth;++ae){let pe=ae*l-y,ue=pe;for(;ue<0;)ue+=p;let he=Math.min(o.inWidth,h+pe),Ie=le+ae*_,Ae=x,Ee=0,Ge=0;for(let It=H;It<K;It+=u){let Rt=V+It*r[1];for(let tn=re;tn<oe;tn+=c){let _t=Rt+tn*r[2];for(let Nt=ue;Nt<he;Nt+=p){let en=_t+Nt*r[3],qt=n[en+U];if(s==="max"&&qt>Ae?Ae=qt:s==="avg"&&(Ee+=qt,Ge++),isNaN(Ae))break}if(isNaN(Ae))break}if(isNaN(Ae))break}let He=Ie+U;w[He]=s==="avg"?Ee/Math.max(Ge,1):Ae}}}}return v}function ez(n,t){let e=de(t.outShape,"int32"),r=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=t.padInfo.front,d=t.padInfo.top,h=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let y=0;y<t.outDepth;++y){let x=y*r-f,v=x;for(;v<0;)v+=i;let w=Math.min(t.inDepth,u+x);for(let S=0;S<t.outHeight;++S){let k=S*o-d,A=k;for(;A<0;)A+=a;let _=Math.min(t.inHeight,c+k);for(let F=0;F<t.outWidth;++F){let $=F*s-h,V=$;for(;V<0;)V+=l;let U=Math.min(t.inWidth,p+$),W=Number.NEGATIVE_INFINITY,G=-1;for(let H=v;H<w;H+=i){let K=H-x;for(let Q=A;Q<_;Q+=a){let X=Q-k;for(let J=V;J<U;J+=l){let re=J-$,oe=n.get(g,H,Q,J,m);oe>=W&&(W=oe,G=K*c*p+X*c+re)}}}e.set(G,g,y,S,F,m)}}}return e}function oae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t;Z(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=Gn({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=Kd(f,o.shape,o.dtype,d,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var tz={kernelName:Oa,backendName:"cpu",kernelFunc:oae};function sae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Z(o,"avgPool3d");let c=N.computePool3DInfo(o.shape,s,i,1,a,l,u),p=e.data.get(o.dataId).values,f=sw(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(f.shape,"float32",f.values)}var nz={kernelName:Ma,backendName:"cpu",kernelFunc:sae};function iae(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Z([o,s],"avgPool3DGrad");let c=N.computePool3DInfo(s.shape,i,a,1,l,u),p=c.strideDepth,f=c.strideHeight,d=c.strideWidth,h=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,S=c.effectiveFilterHeight,k=c.effectiveFilterWidth,A=w-1-c.padInfo.front,_=k-1-c.padInfo.left,F=S-1-c.padInfo.top,$=de(s.shape,"float32"),V=1/(h*g*m),U=e.bufferSync(o);for(let W=0;W<c.batchSize;++W)for(let G=0;G<c.inChannels;++G)for(let H=0;H<c.inDepth;++H)for(let K=0;K<c.inHeight;++K)for(let Q=0;Q<c.inWidth;++Q){let X=H-A,J=K-F,re=Q-_,oe=0;for(let le=0;le<w;le+=y){let ae=(X+le)/p;if(!(ae<0||ae>=c.outDepth||Math.floor(ae)!==ae))for(let pe=0;pe<S;pe+=x){let ue=(J+pe)/f;if(!(ue<0||ue>=c.outHeight||Math.floor(ue)!==ue))for(let he=0;he<k;he+=v){let Ie=(re+he)/d;if(Ie<0||Ie>=c.outWidth||Math.floor(Ie)!==Ie)continue;let Ae=U.get(W,ae,ue,Ie,G);oe+=Ae}}}$.set(oe*V,W,H,K,Q,G)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var rz={kernelName:Bp,backendName:"cpu",kernelFunc:iae};function aae(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,i=s;Z([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=r,c=N.computePool2DInfo(i.shape,a,l,1,u),p=c.strideHeight,f=c.strideWidth,d=c.filterHeight,h=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=x-1-c.padInfo.left,w=y-1-c.padInfo.top,S=de(i.shape,"float32"),k=1/(d*h),A=e.data.get(o.dataId).values,_=de(o.shape,"float32",A);for(let F=0;F<c.batchSize;++F)for(let $=0;$<c.inChannels;++$)for(let V=0;V<c.inHeight;++V)for(let U=0;U<c.inWidth;++U){let W=V-w,G=U-v,H=0;for(let K=0;K<y;K+=g){let Q=(W+K)/p;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let X=0;X<x;X+=m){let J=(G+X)/f;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;let re=_.get(F,Q,J,$);H+=re}}S.set(H*k,F,V,U,$)}return e.makeTensorInfo(S.shape,S.dtype,S.values)}var oz={kernelName:Lp,backendName:"cpu",kernelFunc:aae};function lae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,scale:s,offset:i,mean:a,variance:l}=t;b.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Z([o,a,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,f=e.data.get(l.dataId).values,d=s?e.data.get(s.dataId).values:new Float32Array([1]),h=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=h.length,y=d.length,x=f.length,v=p.length,w=0,S=0,k=0,A=0;for(let _=0;_<c.length;++_)g[_]=h[w++]+(c[_]-p[S++])*d[k++]/Math.sqrt(f[A++]+u),w>=m&&(w=0),S>=v&&(S=0),k>=y&&(k=0),A>=x&&(A=0);return e.makeTensorInfo(o.shape,o.dtype,g)}var sz={kernelName:Ha,backendName:"cpu",kernelFunc:lae};function uae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockShape:s,crops:i}=r;Z([o],"batchToSpaceND");let a=s.reduce((y,x)=>y*x),l=N.getReshaped(o.shape,s,a),u=N.getPermuted(l.length,s.length),c=N.getReshapedPermuted(o.shape,s,a),p=N.getSliceBeginCoords(i,s.length),f=N.getSliceSize(c,i,s.length),d=Ve({inputs:{x:o},backend:e,attrs:{shape:l}}),h=Ut({inputs:{x:d},backend:e,attrs:{perm:u}}),g=Ve({inputs:{x:h},backend:e,attrs:{shape:c}}),m=_o({inputs:{x:g},backend:e,attrs:{begin:p,size:f}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var iz={kernelName:$a,backendName:"cpu",kernelFunc:uae};function cae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,weights:s}=t,{size:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,u=jd(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var az={kernelName:zp,backendName:"cpu",kernelFunc:cae};function pae(n){let{inputs:t,backend:e}=n,{s0:r,s1:o}=t,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var lz={kernelName:Vp,backendName:"cpu",kernelFunc:pae};var fae=Ce(ui,(n,t)=>{let e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),uz={kernelName:ui,backendName:"cpu",kernelFunc:fae};var dae=n=>{let{x:t}=n.inputs,e=n.backend,r=new Float32Array(b.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values;for(let u=0;u<a.length;u++){let c=a[u],p=l[u];r[u]=Math.hypot(c,p)}return e.makeOutput(r,t.shape,"float32")},cz={kernelName:Pa,backendName:"cpu",kernelFunc:dae};function Ls(n){let{inputs:t,backend:e}=n,{input:r}=t,o=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var pz={kernelName:af,backendName:"cpu",kernelFunc:Ls};function Zl(n){let{inputs:t,backend:e,attrs:r}=n,{axis:o}=r,s=b.parseAxisParam(o,t[0].shape)[0],i=t.map(g=>g.shape);N.assertParamsConsistent(i,s);let a=N.computeOutShape(t.map(g=>g.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(g=>b.sizeFromShape(g.shape)>0);if(l.length===1)return Gn({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){let g=l.map(w=>ko({inputs:{input:w},backend:e})),m=l.map(w=>Ls({inputs:{input:w},backend:e})),y=Zl({inputs:g,backend:e,attrs:{axis:s}}),x=Zl({inputs:m,backend:e,attrs:{axis:s}}),v=mn({inputs:{real:y,imag:x},backend:e});return g.forEach(w=>e.disposeIntermediateTensorInfo(w)),m.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),v}let u=l.map(g=>{let y=[-1,b.sizeFromShape(g.shape.slice(s))];return Ve({inputs:{x:g},backend:e,attrs:{shape:y}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=N.computeOutShape(u.map(g=>g.shape),1);let p=u[0].shape[0]===1,f=zv(c,a,t[0].dtype,p),d=N.computeOutShape(l.map(g=>g.shape),s),h=e.makeTensorInfo(d,t[0].dtype,f);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var fz={kernelName:La,backendName:"cpu",kernelFunc:Zl};function r1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Z([o,s],"conv2d");let p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),d=f.filterHeight,h=f.filterWidth,g=f.dilationHeight,m=f.dilationWidth,y=f.padInfo.left,x=f.padInfo.top,v=f.dataFormat==="channelsLast",w=new tt(f.outShape,o.dtype),S=b.computeStrides(o.shape),k=b.computeStrides(s.shape),A=S[0],_=v?S[1]:S[2],F=v?S[2]:1,$=v?1:S[1],V=w.strides[0],U=v?w.strides[1]:w.strides[2],W=v?w.strides[2]:1,G=v?1:w.strides[1],H=e.data.get(o.dataId).values,K=e.data.get(s.dataId).values,Q=w.values;for(let X=0;X<f.batchSize;++X){let J=X*A,re=X*V;for(let oe=0;oe<f.outHeight;++oe){let le=re+oe*U,ae=oe*f.strideHeight-x;for(let pe=0;pe<d;++pe){let ue=ae+pe*g;if(ue<0||ue>=f.inHeight)continue;let he=pe*k[0],Ie=J+ue*_;for(let Ae=0;Ae<f.outWidth;++Ae){let Ee=le+Ae*W,Ge=Ae*f.strideWidth-y;for(let He=0;He<h;++He){let It=Ge+He*m;if(It<0||It>=f.inWidth)continue;let Rt=he+He*k[1],tn=Ie+It*F,_t=Rt;for(let Nt=0;Nt<f.inChannels;++Nt){let en=H[tn+Nt*$];for(let qt=0;qt<f.outChannels;++qt)Q[Ee+qt*G]+=en*K[_t+qt];_t+=f.outChannels}}}}}}return e.makeTensorInfo(w.shape,w.dtype,Q)}var dz={kernelName:Ba,backendName:"cpu",kernelFunc:r1};function hae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Z([o,s],"conv2dBackpropFilter");let p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),{strideHeight:d,strideWidth:h,filterHeight:g,filterWidth:m}=f,y=f.dataFormat==="channelsLast",x=new tt(f.filterShape,"float32"),v=f.padInfo.left,w=f.padInfo.top,S=e.data.get(o.dataId).values,k=e.data.get(s.dataId).values,A=new tt(o.shape,o.dtype,S),_=new tt(s.shape,s.dtype,k);for(let F=0;F<g;++F){let $=Math.max(0,Math.ceil((w-F)/d)),V=Math.min(f.outHeight,(f.inHeight+w-F)/d);for(let U=0;U<m;++U){let W=Math.max(0,Math.ceil((v-U)/h)),G=Math.min(f.outWidth,(f.inWidth+v-U)/h);for(let H=0;H<f.inChannels;++H)for(let K=0;K<f.outChannels;++K){let Q=0;for(let X=0;X<f.batchSize;++X)for(let J=$;J<V;++J){let re=F+J*d-w;for(let oe=W;oe<G;++oe){let le=U+oe*h-v;y?Q+=A.get(X,re,le,H)*_.get(X,J,oe,K):Q+=A.get(X,H,re,le)*_.get(X,K,J,oe)}}x.set(Q,F,U,H,K)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var hz={kernelName:Gp,backendName:"cpu",kernelFunc:hae};function mae(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Z([o,s],"conv2dBackpropInput");let p=b.computeStrides(s.shape),f=b.computeStrides(o.shape),d=N.convertConv2DDataFormat(u),h=N.computeConv2DInfo(i,s.shape,a,1,l,c,!1,d),g=new tt(h.inShape,"float32"),m=g.values,y=e.data.get(o.dataId).values,x=e.data.get(s.dataId).values,[v,w,S]=p,{batchSize:k,filterHeight:A,filterWidth:_,inChannels:F,inHeight:$,inWidth:V,outChannels:U,outHeight:W,outWidth:G,strideHeight:H,strideWidth:K}=h;d=h.dataFormat;let Q=A-1-h.padInfo.top,X=_-1-h.padInfo.left,J=d==="channelsLast",re=g.strides[0],oe=J?g.strides[1]:g.strides[2],le=J?g.strides[2]:1,ae=J?1:g.strides[1],pe=f[0],ue=J?f[1]:f[2],he=J?f[2]:1,Ie=J?1:f[1];for(let Ae=0;Ae<k;++Ae)for(let Ee=0;Ee<F;++Ee)for(let Ge=0;Ge<$;++Ge){let He=Ge-Q,It=Math.max(0,Math.ceil(He/H)),Rt=Math.min(W,(A+He)/H);for(let tn=0;tn<V;++tn){let _t=tn-X,Nt=Math.max(0,Math.ceil(_t/K)),en=Math.min(G,(_+_t)/K),qt=0;for(let Fn=It;Fn<Rt;++Fn){let ga=Fn*H-He;for(let jr=Nt;jr<en;++jr){let ou=jr*K-_t,Mo=pe*Ae+ue*Fn+he*jr,Gs=v*(A-1-ga)+w*(_-1-ou)+S*Ee;for(let ya=0;ya<U;++ya){let xa=y[Mo+Ie*ya],ba=x[Gs+ya];qt+=xa*ba}}}let Us=re*Ae+oe*Ge+le*tn+ae*Ee;m[Us]=qt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var mz={kernelName:za,backendName:"cpu",kernelFunc:mae};function gae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=r;Z([o,s],"conv3d");let u=N.computeConv3DInfo(o.shape,s.shape,i,l,a),{filterDepth:c,filterHeight:p,filterWidth:f,dilationDepth:d,dilationHeight:h,dilationWidth:g,padInfo:m}=u,y=m.front,x=m.left,v=m.top,w=new tt(u.outShape,o.dtype),S=e.data.get(o.dataId).values,k=e.data.get(s.dataId).values,A=w.values,_=b.computeStrides(o.shape),F=b.computeStrides(s.shape);for(let $=0;$<u.batchSize;++$){let V=$*_[0],U=$*w.strides[0];for(let W=0;W<u.outDepth;++W){let G=U+W*w.strides[1],H=W*u.strideDepth-y;for(let K=0;K<c;++K){let Q=H+K*d;if(Q<0||Q>=u.inDepth)continue;let X=K*F[0],J=V+Q*_[1];for(let re=0;re<u.outHeight;++re){let oe=G+re*w.strides[2],le=re*u.strideHeight-v;for(let ae=0;ae<p;++ae){let pe=le+ae*h;if(pe<0||pe>=u.inHeight)continue;let ue=X+ae*F[1],he=J+pe*_[2];for(let Ie=0;Ie<u.outWidth;++Ie){let Ae=oe+Ie*u.outChannels,Ee=Ie*u.strideWidth-x;for(let Ge=0;Ge<f;++Ge){let He=Ee+Ge*g;if(He<0||He>=u.inWidth)continue;let It=ue+Ge*F[2],Rt=he+He*u.inChannels,tn=It;for(let _t=0;_t<u.inChannels;++_t){let Nt=S[Rt+_t];for(let en=0;en<u.outChannels;++en)A[Ae+en]+=Nt*k[tn+en];tn+=u.outChannels}}}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}var gz={kernelName:Va,backendName:"cpu",kernelFunc:gae};function yae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:l}=r;Z([o,s],"conv3dBackpropFilterV2");let u=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=N.computeConv3DInfo(o.shape,l,i,1,a),f=p.strideDepth,d=p.strideHeight,h=p.strideWidth,g=p.filterDepth,m=p.filterHeight,y=p.filterWidth,x=new tt(p.filterShape,"float32"),v=x.values,[w,S,k,A]=x.strides,_=e.data.get(s.dataId).values,[F,$,V,U]=c,W=e.data.get(o.dataId).values,[G,H,K,Q]=u,X=p.padInfo.front,J=p.padInfo.left,re=p.padInfo.top;for(let oe=0;oe<g;++oe){let le=Math.max(0,Math.ceil((X-oe)/f)),ae=Math.min(p.outDepth,(p.inDepth+X-oe)/f),pe=oe*w;for(let ue=0;ue<m;++ue){let he=Math.max(0,Math.ceil((re-ue)/d)),Ie=Math.min(p.outHeight,(p.inHeight+re-ue)/d),Ae=ue*S+pe;for(let Ee=0;Ee<y;++Ee){let Ge=Math.max(0,Math.ceil((J-Ee)/h)),He=Math.min(p.outWidth,(p.inWidth+J-Ee)/h),It=Ee*k+Ae;for(let Rt=0;Rt<p.inChannels;++Rt){let tn=Rt*A+It;for(let _t=0;_t<p.outChannels;++_t){let Nt=0;for(let en=0;en<p.batchSize;++en){let qt=en*G,Us=en*F;for(let Fn=le;Fn<ae;++Fn){let jr=(oe+Fn*f-X)*H+qt,ou=Fn*$+Us;for(let Mo=he;Mo<Ie;++Mo){let ya=(ue+Mo*d-re)*K+jr,xa=Mo*V+ou;for(let ba=Ge;ba<He;++ba){let XC=(Ee+ba*h-J)*Q+ya,YC=ba*U+xa;Nt+=W[XC+Rt]*_[YC+_t]}}}}v[tn+_t]=Nt}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var yz={kernelName:Wp,backendName:"cpu",kernelFunc:yae};function xae(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:l}=r;Z([o],"conv3dBackpropInputV2");let u=b.computeStrides(o.shape),c=b.computeStrides(s.shape),p=N.computeConv3DInfo(l,s.shape,a,1,i),f=new tt(p.inShape,"float32"),d=f.values,[h,g,m,y]=f.strides,x=e.data.get(o.dataId).values,[v,w,S,k]=u,A=e.data.get(s.dataId).values,[_,F,$,V]=c,{batchSize:U,filterDepth:W,filterHeight:G,filterWidth:H,inChannels:K,inDepth:Q,inHeight:X,inWidth:J,outChannels:re,outDepth:oe,outHeight:le,outWidth:ae,strideDepth:pe,strideHeight:ue,strideWidth:he}=p,Ie=W-1-p.padInfo.front,Ae=G-1-p.padInfo.top,Ee=H-1-p.padInfo.left;for(let Ge=0;Ge<U;++Ge)for(let He=0;He<K;++He)for(let It=0;It<Q;++It){let Rt=It-Ie,tn=Math.max(0,Math.ceil(Rt/pe)),_t=Math.min(oe,(W+Rt)/pe);for(let Nt=0;Nt<X;++Nt){let en=Nt-Ae,qt=Math.max(0,Math.ceil(en/ue)),Us=Math.min(le,(G+en)/ue);for(let Fn=0;Fn<J;++Fn){let ga=Fn-Ee,jr=Math.max(0,Math.ceil(ga/he)),ou=Math.min(ae,(H+ga)/he),Mo=0;for(let Gs=tn;Gs<_t;++Gs){let ya=Gs*pe-Rt;for(let xa=qt;xa<Us;++xa){let ba=xa*ue-en;for(let mh=jr;mh<ou;++mh){let XC=mh*he-ga,YC=v*Ge+w*Gs+S*xa+k*mh,JH=_*(W-1-ya)+F*(G-1-ba)+$*(H-1-XC)+V*He;for(let wg=0;wg<re;++wg){let e6=x[YC+wg],t6=A[JH+wg];Mo+=e6*t6}}}}d[h*Ge+g*It+m*Nt+y*Fn+He]=Mo}}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}var xz={kernelName:jp,backendName:"cpu",kernelFunc:xae};var bae=Ce(ci,n=>Math.cos(n)),bz={kernelName:ci,backendName:"cpu",kernelFunc:bae};var vae=Ce(pi,n=>Math.cosh(n)),vz={kernelName:pi,backendName:"cpu",kernelFunc:vae};function wae(n){let{inputs:t,backend:e,attrs:r}=n,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,[c,p,f,d]=o.shape,h=s.shape[0],[g,m]=a,y=de([h,g,m,d],"float32"),x=e.data.get(s.dataId).values,v=e.data.get(i.dataId).values,w=e.data.get(o.dataId).values,S=b.computeStrides(o.shape),k=b.computeStrides(y.shape);for(let A=0;A<h;A++){let _=A*4,F=x[_],$=x[_+1],V=x[_+2],U=x[_+3],W=v[A];if(W>=c)continue;let G=g>1?(V-F)*(p-1)/(g-1):0,H=m>1?(U-$)*(f-1)/(m-1):0;for(let K=0;K<g;K++){let Q=g>1?F*(p-1)+K*G:.5*(F+V)*(p-1);if(Q<0||Q>p-1){for(let X=0;X<m;X++)for(let J=0;J<d;J++){let re=J+X*k[2]+K*k[1]+A*k[0];y.values[re]=u}continue}if(l==="bilinear"){let X=Math.floor(Q),J=Math.ceil(Q),re=Q-X;for(let oe=0;oe<m;oe++){let le=m>1?$*(f-1)+oe*H:.5*($+U)*(f-1);if(le<0||le>f-1){for(let he=0;he<d;he++){let Ie=he+oe*k[2]+K*k[1]+A*k[0];y.values[Ie]=u}continue}let ae=Math.floor(le),pe=Math.ceil(le),ue=le-ae;for(let he=0;he<d;he++){let Ie=he+ae*S[2]+X*S[1]+W*S[0],Ae=w[Ie];Ie=he+pe*S[2]+X*S[1]+W*S[0];let Ee=w[Ie];Ie=he+ae*S[2]+J*S[1]+W*S[0];let Ge=w[Ie];Ie=he+pe*S[2]+J*S[1]+W*S[0];let He=w[Ie],It=Ae+(Ee-Ae)*ue,Rt=Ge+(He-Ge)*ue;Ie=he+oe*k[2]+K*k[1]+A*k[0],y.values[Ie]=It+(Rt-It)*re}}}else for(let X=0;X<m;++X){let J=m>1?$*(f-1)+X*H:.5*($+U)*(f-1);if(J<0||J>f-1){for(let le=0;le<d;le++){let ae=le+X*k[2]+K*k[1]+A*k[0];y.values[ae]=u}continue}let re=Math.round(J),oe=Math.round(Q);for(let le=0;le<d;le++){let ae=le+re*S[2]+oe*S[1]+W*S[0],pe=le+X*k[2]+K*k[1]+A*k[0];y.values[pe]=w[ae]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var wz={kernelName:qp,backendName:"cpu",kernelFunc:wae};function Cae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,exclusive:i,reverse:a}=r;Z(o,"cumprod");let l=N.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Ut({inputs:{x:o},backend:e,attrs:{perm:l}}));let c=N.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=nn(u.dtype,"int32"),f=b.makeOnesTypedArray(b.sizeFromShape(u.shape),p),d=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let v=g(y,x);if(x===0)f[v]=i?1:d[v];else{let w=g(y,x-1);f[v]=i?d[w]*f[w]:d[v]*f[w]}}let m=e.makeTensorInfo(u.shape,p,f);if(l!=null){let y=N.getUndoAxesPermutation(l),x=Ut({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}var Cz={kernelName:Hp,backendName:"cpu",kernelFunc:Cae};function Iae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,exclusive:i,reverse:a}=r;Z(o,"cumsum");let l=N.getAxesPermutation([s],o.shape.length),u=o;l!=null&&(u=Ut({inputs:{x:o},backend:e,attrs:{perm:l}}));let c=N.getInnerMostAxes(1,o.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=nn(u.dtype,"int32"),f=b.makeZerosTypedArray(b.sizeFromShape(u.shape),p),d=e.data.get(u.dataId).values,h=u.shape[u.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let v=g(y,x);if(x===0)f[v]=i?0:d[v];else{let w=g(y,x-1);f[v]=i?d[w]+f[w]:d[v]+f[w]}}let m=e.makeTensorInfo(u.shape,p,f);if(l!=null){let y=N.getUndoAxesPermutation(l),x=Ut({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}var Iz={kernelName:Ua,backendName:"cpu",kernelFunc:Iae};function Sae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,weights:s}=t,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=jd(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=e.bufferSync(o),u=e.bufferSync(s),c=Bv(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Sz={kernelName:Kp,backendName:"cpu",kernelFunc:Sae};function Tae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockSize:s,dataFormat:i}=r;b.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],l=o.shape[1],u=o.shape[2],c=o.shape[3],p=l*s,f=u*s,d=c/(s*s),h=e.data.get(o.dataId).values,g=new Float32Array(a*p*f*d),m=0;for(let y=0;y<a;++y)for(let x=0;x<p;++x){let v=Math.floor(x/s),w=x%s;for(let S=0;S<f;++S){let k=Math.floor(S/s),A=S%s,_=(w*s+A)*d;for(let F=0;F<d;++F){let V=F+_+c*(k+u*(v+l*y));g[m++]=h[V]}}}return e.makeTensorInfo([a,p,f,d],o.dtype,g)}var Tz={kernelName:Xp,backendName:"cpu",kernelFunc:Tae};function o1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Z([o,s],"depthwiseConv2DNative");let c=b.computeStrides(o.shape),p=b.computeStrides(s.shape),f=l;f==null&&(f=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);let d=N.computeConv2DInfo(o.shape,s.shape,i,f,a,u,!0),{filterHeight:h,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:x}=d,v=x.left,w=x.top,S=d.outChannels/d.inChannels,k=new tt(d.outShape,o.dtype),A=e.data.get(o.dataId).values,_=e.data.get(s.dataId).values,F=k.values;for(let $=0;$<d.batchSize;++$){let V=$*c[0],U=$*k.strides[0];for(let W=0;W<d.outHeight;++W){let G=U+W*k.strides[1],H=W*d.strideHeight-w;for(let K=0;K<h;++K){let Q=H+K*m;if(Q<0||Q>=d.inHeight)continue;let X=K*p[0],J=V+Q*c[1];for(let re=0;re<d.outWidth;++re){let oe=G+re*k.strides[2],le=re*d.strideWidth-v;for(let ae=0;ae<g;++ae){let pe=le+ae*y;if(pe<0||pe>=d.inWidth)continue;let ue=X+ae*p[1],he=J+pe*d.inChannels,Ie=oe,Ae=ue;for(let Ee=0;Ee<d.inChannels;++Ee){let Ge=A[he+Ee];for(let He=0;He<S;++He)F[Ie+He]+=Ge*_[Ae+He];Ie+=S,Ae+=S}}}}}}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var Nz={kernelName:Ga,backendName:"cpu",kernelFunc:o1};function Nae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Z([o,s],"depthwiseConv2dNativeBackpropFilter");let p=N.computeConv2DInfo(o.shape,c,i,a,l,u,!0),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=p,m=new tt(p.filterShape,"float32"),y=p.padInfo.left,x=p.padInfo.top,v=p.outChannels/p.inChannels,w=e.data.get(o.dataId).values,S=new tt(o.shape,o.dtype,w),k=e.data.get(s.dataId).values,A=new tt(s.shape,s.dtype,k);for(let _=0;_<h;++_){let F=Math.max(0,Math.ceil((x-_)/f)),$=Math.min(p.outHeight,(p.inHeight+x-_)/f);for(let V=0;V<g;++V){let U=Math.max(0,Math.ceil((y-V)/d)),W=Math.min(p.outWidth,(p.inWidth+y-V)/d);for(let G=0;G<p.outChannels;++G){let H=Math.trunc(G/v),K=G%v,Q=0;for(let X=0;X<p.batchSize;++X)for(let J=F;J<$;++J){let re=_+J*f-x;for(let oe=U;oe<W;++oe){let le=V+oe*d-y;Q+=S.get(X,re,le,H)*A.get(X,J,oe,G)}}m.set(Q,_,V,H,K)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var Ez={kernelName:Yp,backendName:"cpu",kernelFunc:Nae};function Eae(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Z([o,s],"depthwiseConv2DNativeBackpropInput");let p=b.computeStrides(o.shape),f=b.computeStrides(s.shape),d=N.computeConv2DInfo(c,s.shape,i,a,l,u,!0),h=new tt(d.inShape,"float32"),g=h.values,[m,y,x]=h.strides,v=e.data.get(o.dataId).values,[w,S,k]=p,A=e.data.get(s.dataId).values,[_,F,$]=f,{batchSize:V,filterHeight:U,filterWidth:W,inChannels:G,inHeight:H,inWidth:K,outChannels:Q,outHeight:X,outWidth:J,strideHeight:re,strideWidth:oe}=d,le=U-1-d.padInfo.top,ae=W-1-d.padInfo.left,pe=Q/G;for(let ue=0;ue<V;++ue)for(let he=0;he<G;++he)for(let Ie=0;Ie<H;++Ie){let Ae=Ie-le,Ee=Math.max(0,Math.ceil(Ae/re)),Ge=Math.min(X,(U+Ae)/re);for(let He=0;He<K;++He){let It=He-ae,Rt=Math.max(0,Math.ceil(It/oe)),tn=Math.min(J,(W+It)/oe),_t=0;for(let Nt=Ee;Nt<Ge;++Nt){let en=Nt*re-Ae;for(let qt=Rt;qt<tn;++qt){let Us=qt*oe-It,Fn=w*ue+S*Nt+k*qt,ga=_*(U-1-en)+F*(W-1-Us)+$*he;for(let jr=0;jr<pe;++jr){let ou=he*pe+jr,Mo=v[Fn+ou],Gs=A[ga+jr];_t+=Mo*Gs}}}g[m*ue+y*Ie+x*He+he]=_t}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var Dz={kernelName:Zp,backendName:"cpu",kernelFunc:Eae};function Dae(n){let{inputs:t,backend:e}=n,{x:r}=t,o=b.sizeFromShape(r.shape),s=e.data.get(r.dataId).values,i=de([o,o],r.dtype),a=i.values;for(let u=0;u<s.length;u++)a[u*o+u]=s[u];let l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}var kz={kernelName:Qp,backendName:"cpu",kernelFunc:Dae};var Az={kernelName:Wa,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:o}=n,{strides:s,pad:i,dilations:a}=e,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,p=l.data.get(o.dataId).values,f=o.shape.length,{batchSize:d,inHeight:h,inWidth:g,inChannels:m,outHeight:y,outWidth:x,padInfo:v,strideHeight:w,strideWidth:S,filterHeight:k,filterWidth:A,dilationHeight:_,dilationWidth:F,outShape:$}=N.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),V=b.sizeFromShape($),U=$.length,W=b.getArrayFromDType(r.dtype,V);for(let H=0;H<d;++H)for(let K=0;K<y;++K){let Q=K*w-v.top;for(let X=0;X<x;++X){let J=X*S-v.left;for(let re=0;re<m;++re){let oe=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<k;++ae){let pe=Q+ae*_;if(pe>=0&&pe<h)for(let ue=0;ue<A;++ue){let he=J+ue*F;if(he>=0&&he<g){let Ie=b.locToIndex([H,pe,he,re],c,b.computeStrides(r.shape)),Ae=b.locToIndex([ae,ue,re],f,b.computeStrides(o.shape)),Ee=u[Ie]+p[Ae];Ee>oe&&(oe=Ee)}}}let le=b.locToIndex([H,K,X,re],U,b.computeStrides($));W[le]=oe}}}return{dataId:l.write(b.toTypedArray(W,r.dtype),$,r.dtype),shape:$,dtype:r.dtype}}};var Rz={kernelName:dm,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=b.toNestedArray(r.shape,u.data.get(r.dataId).values),p=b.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:A,dilationWidth:_,outShape:F}=N.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===F.length,()=>`Error in ${dm}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let $=b.toNestedArray(F,u.data.get(s.dataId).values),V=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let W=0;W<f;++W)for(let G=0;G<m;++G){let H=G*v-x.top;for(let K=0;K<y;++K){let Q=K*w-x.left;for(let X=0;X<g;++X){let J=Number.MIN_SAFE_INTEGER,re=0,oe=0;for(let le=0;le<S;++le){let ae=H+le*A;if(ae>=0&&ae<d)for(let pe=0;pe<k;++pe){let ue=Q+pe*_;if(ue>=0&&ue<h){let he=c[W][ae][ue][X]+p[le][pe][X];he>J&&(J=he,re=le,oe=pe)}}}V[re][oe][X]+=$[W][G][K][X]}}}return{dataId:u.write(b.toTypedArray(V,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var _z={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:o,dy:s}=n,{strides:i,pad:a,dilations:l}=e,u=t,c=b.toNestedArray(r.shape,u.data.get(r.dataId).values),p=b.toNestedArray(o.shape,u.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:S,filterWidth:k,dilationHeight:A,dilationWidth:_,outShape:F}=N.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===F.length,()=>`Error in ${fm}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let $=b.toNestedArray(F,u.data.get(s.dataId).values),V=b.makeZerosNestedTypedArray(r.shape,r.dtype);for(let W=0;W<f;++W)for(let G=0;G<m;++G){let H=G*v-x.top;for(let K=0;K<y;++K){let Q=K*w-x.left;for(let X=0;X<g;++X){let J=Number.MIN_SAFE_INTEGER,re=H<0?0:H,oe=Q<0?0:Q;for(let le=0;le<S;++le){let ae=H+le*A;if(ae>=0&&ae<d)for(let pe=0;pe<k;++pe){let ue=Q+pe*_;if(ue>=0&&ue<h){let he=c[W][ae][ue][X]+p[le][pe][X];he>J&&(J=he,re=ae,oe=ue)}}}V[W][re][oe][X]+=$[W][G][K][X]}}}return{dataId:u.write(b.toTypedArray(V,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function kae(n){let{inputs:t,backend:e,attrs:r}=n,{image:o}=t,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:l}=i||{},u=l?.alpha||1,c=a?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(c,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${c} type.`);let[f,d]=o.shape.slice(0,2),h=o.shape.length===2?1:o.shape[2],g=e.data.get(o.dataId).values,m=o.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let v=0;v<f*d;++v){let w=[0,0,0,255*u];for(let k=0;k<h;k++){let A=g[v*h+k];if(o.dtype==="float32"){if(A<0||A>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${A}.`)}else if(o.dtype==="int32"&&(A<0||A>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${A}.`);h===1?(w[0]=A*m,w[1]=A*m,w[2]=A*m):w[k]=A*m}let S=v*4;y[S+0]=Math.round(w[0]),y[S+1]=Math.round(w[1]),y[S+2]=Math.round(w[2]),y[S+3]=Math.round(w[3])}s.width=d,s.height=f;let x=new ImageData(y,d,f);return p.putImageData(x,0,0),o}var Oz={kernelName:$_,backendName:"cpu",kernelFunc:kae};function pa(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;Z(o,"sum");let a;o.dtype==="bool"?a=Ao({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=Gn({inputs:{x:o},backend:e});let l=a.shape.length,u=b.parseAxisParam(s,a.shape),c=N.getAxesPermutation(u,l),p=u,f=a;c!=null&&(f=Ut({inputs:{x:a},backend:e,attrs:{perm:c}}),p=N.getInnerMostAxes(p.length,l)),N.assertAxesAreInnerMostDims("sum",p,f.shape.length);let[d,h]=N.computeOutAndReduceShapes(f.shape,p),g=N.upcastType(f.dtype,"int32"),m=Gd(e,d,g),y=b.sizeFromShape(h),x=e.data.get(m.dataId).values,v=e.data.get(f.dataId).values;for(let w=0;w<x.length;++w){let S=w*y,k=0;for(let A=0;A<y;++A)k+=v[S+A];x[w]=k}if(i){let w=N.expandShapeToKeepDim(m.shape,u),S=m;m=Ve({inputs:{x:m},backend:e,attrs:{shape:w}}),e.disposeIntermediateTensorInfo(S)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(f),m}var Mz={kernelName:ml,backendName:"cpu",kernelFunc:pa};function Aae(n){let{inputs:t,backend:e,attrs:r}=n,{equation:o}=r,s=t,{allDims:i,summedDims:a,idDims:l}=N.decodeEinsumEquation(o,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=N.getEinsumComputePath(a,l),p=c.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of c[g]){let{permutationIndices:y,expandDims:x}=N.getEinsumPermutation(d,l[m]),v;N.isIdentityPermutation(y)?v=s[m]:(v=Ut({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(v));let w=v.shape.slice();for(let S=0;S<x.length;++S)w.splice(x[S],0,1);b.arraysEqual(v.shape,w)||(v=Ve({inputs:{x:v},backend:e,attrs:{shape:w}}),h.push(v)),f===null?f=v:(f=Ec({inputs:{a:v,b:f},backend:e}),h.push(f))}g<p-1&&(u[g]>=0&&(f=pa({inputs:{x:f},backend:e,attrs:{axis:u[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var Fz={kernelName:Jp,backendName:"cpu",kernelFunc:Aae};function Rae(n){let{inputs:t,backend:e}=n,{dy:r,y:o}=t;Z([r,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=a[l]:s[l]=a[l]*(u+1)}return e.makeTensorInfo(o.shape,"float32",s)}var $z={kernelName:ef,backendName:"cpu",kernelFunc:Rae};var _ae=N.ERF_P,Oae=N.ERF_A1,Mae=N.ERF_A2,Fae=N.ERF_A3,$ae=N.ERF_A4,Pae=N.ERF_A5,Lae=Ce(hi,n=>{let t=Math.sign(n),e=Math.abs(n),r=1/(1+_ae*e);return t*(1-((((Pae*r+$ae)*r+Fae)*r+Mae)*r+Oae)*r*Math.exp(-e*e))}),Pz={kernelName:hi,backendName:"cpu",kernelFunc:Lae};function Xd(n){let{inputs:t,backend:e,attrs:r}=n,{input:o}=t,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),l=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),Ve({inputs:{x:o},backend:e,attrs:{shape:a}})}var Lz={kernelName:ja,backendName:"cpu",kernelFunc:Xd};var Bae=ze((n,t)=>n/t),ng=Xe(fi,Bae),rg={kernelName:fi,backendName:"cpu",kernelFunc:ng};function iw(n,t,e){let r=n.shape,o=r[0],s=r[1],i=e.data.get(n.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[o,s],c=b.sizeFromShape(u),p=b.getTypedArrayFromDType("float32",c),f=b.getTypedArrayFromDType("float32",c);for(let m=0;m<o;m++){let y=_o({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,s]}}),x=_o({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,s]}}),v=mn({inputs:{real:y,imag:x},backend:e}),{real:w,imag:S}=zae(v,t,e),k=N.mergeRealAndImagArrays(w,S);for(let A=0;A<s;A++){let _=N.getComplexWithIndex(k,A);p[m*s+A]=_.real,f[m*s+A]=_.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(v)}let d=e.makeTensorInfo(u,"float32",p),h=e.makeTensorInfo(u,"float32",f),g=mn({inputs:{real:d,imag:h},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}function zae(n,t,e){let r=b.sizeFromShape(n.shape),o=e.data.get(n.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(Vae(r)){let a=s1(s,i,r,t,e),l=[n.shape[0],n.shape[1]];if(t){let u=e.makeTensorInfo(l,"float32",a.real),c=e.makeTensorInfo(l,"float32",a.imag),p=e.makeTensorInfo([],"float32",b.createScalarValue(r,"float32")),f=Gn({inputs:{x:p},backend:e}),d=rg.kernelFunc({inputs:{a:u,b:p},backend:e}),h=rg.kernelFunc({inputs:{a:c,b:f},backend:e}),g=e.data.get(d.dataId).values,m=e.data.get(h.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),{real:g,imag:m}}return a}else{let a=N.mergeRealAndImagArrays(s,i),l=Uae(a,r,t);return N.splitRealAndImagArrays(l)}}function Vae(n){return(n&n-1)===0}function s1(n,t,e,r,o){if(e===1)return{real:n,imag:t};let s=N.mergeRealAndImagArrays(n,t),i=e/2,a=N.complexWithEvenIndex(s),l=a.real,u=a.imag,c=[l.length],p=o.makeTensorInfo(c,"float32",l),f=o.makeTensorInfo(c,"float32",u),d=mn({inputs:{real:p,imag:f},backend:o}),h=N.complexWithOddIndex(s),g=h.real,m=h.imag,y=[g.length],x=o.makeTensorInfo(y,"float32",g),v=o.makeTensorInfo(y,"float32",m),w=mn({inputs:{real:x,imag:v},backend:o}),S=s1(l,u,i,r,o),k=S.real,A=S.imag,_=[k.length],F=o.makeTensorInfo(_,"float32",k),$=o.makeTensorInfo(_,"float32",A),V=mn({inputs:{real:F,imag:$},backend:o}),U=s1(g,m,i,r,o),W=U.real,G=U.imag,H=[W.length],K=o.makeTensorInfo(H,"float32",W),Q=o.makeTensorInfo(H,"float32",G),X=mn({inputs:{real:K,imag:Q},backend:o}),J=N.exponents(e,r),re=[J.real.length],oe=o.makeTensorInfo(re,"float32",J.real),le=o.makeTensorInfo(re,"float32",J.imag),ae=mn({inputs:{real:oe,imag:le},backend:o}),pe=Ec({inputs:{a:ae,b:X},backend:o}),ue=Ps({inputs:{a:V,b:pe},backend:o}),he=eg({inputs:{a:V,b:pe},backend:o}),Ie=ko({inputs:{input:ue},backend:o}),Ae=ko({inputs:{input:he},backend:o}),Ee=Ls({inputs:{input:ue},backend:o}),Ge=Ls({inputs:{input:he},backend:o}),He=Zl({inputs:[Ie,Ae],backend:o,attrs:{axis:0}}),It=Zl({inputs:[Ee,Ge],backend:o,attrs:{axis:0}}),Rt=o.data.get(He.dataId).values,tn=o.data.get(It.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(le),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(pe),o.disposeIntermediateTensorInfo(ue),o.disposeIntermediateTensorInfo(he),o.disposeIntermediateTensorInfo(Ie),o.disposeIntermediateTensorInfo(Ee),o.disposeIntermediateTensorInfo(Ae),o.disposeIntermediateTensorInfo(Ge),o.disposeIntermediateTensorInfo(He),o.disposeIntermediateTensorInfo(It),{real:Rt,imag:tn}}function Uae(n,t,e){let r=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let l=N.exponent(o*a,t,e),u=N.getComplexWithIndex(n,a);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}e&&(s/=t,i/=t),N.assignToTypedArray(r,s,i,o)}return r}function Gae(n){let{inputs:t,backend:e}=n,{input:r}=t,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=Ve({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=iw(a,!1,e),u=Ve({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var Bz={kernelName:tf,backendName:"cpu",kernelFunc:Gae};function og(n){let{backend:t,attrs:e}=n,{shape:r,value:o,dtype:s}=e,i=s||b.inferDtype(o),a=b.getArrayFromDType(i,b.sizeFromShape(r));return Wae(a,o,i),t.makeTensorInfo(r,i,a)}var zz={kernelName:nf,backendName:"cpu",kernelFunc:og};function Wae(n,t,e){n.fill(t)}var Vz={kernelName:rf,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,o=e,s=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[i,a,l,u]=r.shape,c=o.data.get(r.dataId).values;for(let f=0;f<i;f++){let d=f*l*a*u;for(let h=0;h<a;h++){let g=h*(l*u);for(let m=0;m<l;m++){let y=m*u;for(let x=0;x<u;x++){let v=Math.round(l-m-1),w=d+g+y+x,S=c[w];if(v>=0&&v<l){let k=v*u,A=d+g+k+x;S=c[A]}s[w]=S}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function jae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=r1({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let m=g;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=Ve({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=Ps({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Ps({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(d){let m=g;if(c==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let y=Ve({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=Dc(e,g,d,y,h),e.disposeIntermediateTensorInfo(y)}else g=Dc(e,g,d,a,h);e.disposeIntermediateTensorInfo(m)}return g}var Uz={kernelName:ju,backendName:"cpu",kernelFunc:jae};function Hae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=o1({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f}});if(i){let m=g;g=Ps({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(d){let m=g;g=Dc(e,g,d,a,h),e.disposeIntermediateTensorInfo(m)}return g}var Gz={kernelName:Hu,backendName:"cpu",kernelFunc:Hae};function qae(n){let{inputs:t,backend:e}=n,{params:r,indices:o}=t,s=b.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[l,u,c,p]=N.prepareAndValidate(r,o);if(u===0)return e.makeTensorInfo(l,r.dtype,[]);let f=e.data.get(o.dataId).values,d=e.bufferSync(r),h=Vv(f,d,r.dtype,u,a,c,p,r.shape,s);return e.makeTensorInfo(l,r.dtype,h.values)}var Wz={kernelName:of,backendName:"cpu",kernelFunc:qae};function Kae(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,indices:s}=t,{axis:i,batchDims:a}=r;Z([o,s],"gatherV2");let l=b.parseAxisParam(i,o.shape)[0],u=e.data.get(s.dataId).values,c=o.shape[l];for(let w=0;w<u.length;++w){let S=u[w];b.assert(S<=c-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let f=b.sizeFromShape(s.shape),d=N.segment_util.collectGatherOpShapeInfo(o,s,l,p),h=Ve({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=Ve({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,f/d.batchSize]}}),m=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=e.bufferSync(g),x=e.bufferSync(h),v=Uv(x,y,m);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(d.outputShape,v.dtype,v.values)}var jz={kernelName:qa,backendName:"cpu",kernelFunc:Kae};function Xae(n){let{inputs:t,backend:e}=n,{input:r}=t,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=Ve({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=iw(a,!0,e),u=Ve({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}var Hz={kernelName:sf,backendName:"cpu",kernelFunc:Xae};var Yae=Ce(vi,n=>Number.isFinite(n)?1:0,"bool"),qz={kernelName:vi,backendName:"cpu",kernelFunc:Yae};var Zae=Ce(wi,n=>Math.abs(n)===1/0?1:0,"bool"),Kz={kernelName:wi,backendName:"cpu",kernelFunc:Zae};var Qae=Ce(Ci,n=>Number.isNaN(n)?1:0,"bool"),Xz={kernelName:Ci,backendName:"cpu",kernelFunc:Qae};function Jae(n){let{backend:t,attrs:e}=n,{start:r,stop:o,num:s}=e,i=Gv(r,o,s);return t.makeTensorInfo([i.length],"float32",i)}var Yz={kernelName:lf,backendName:"cpu",kernelFunc:Jae};var ele=Ce(Si,n=>Math.log1p(n)),Zz={kernelName:Si,backendName:"cpu",kernelFunc:ele};var tle=ze((n,t)=>n&&t),nle=Xe(Bu,tle,null,"bool"),Qz={kernelName:Bu,backendName:"cpu",kernelFunc:nle};var rle=Ce(zu,n=>n?0:1,"bool"),Jz={kernelName:zu,backendName:"cpu",kernelFunc:rle};var ole=ze((n,t)=>n||t),sle=Xe(Vu,ole,null,"bool"),eV={kernelName:Vu,backendName:"cpu",kernelFunc:sle};function ile(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=r;Z(o,"LRN");let u=o.shape[3],c=u-1,p=e.data.get(o.dataId).values,f=b.sizeFromShape(o.shape),d=new Float32Array(f);function h(g){let m=g%u,y=g-m+Math.max(0,m-s),x=g-m+Math.min(m+s,c),v=0;for(;y<=x;y++){let w=p[y];v+=w*w}return v}for(let g=0;g<f;g++){let m=h(g),y=p[g]*Math.pow(i+a*m,-l);d[g]=y}return e.makeTensorInfo(o.shape,o.dtype,d)}var tV={kernelName:Xa,backendName:"cpu",kernelFunc:ile};function ale(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Z(i,"LRNGrad");let p=b.sizeFromShape(i.shape),f=i.shape[3],d=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,g=e.data.get(s.dataId).values,m=new Float32Array(p),y=p;for(let x=0;x<y;x++){let v=x%f,w=x-v+Math.max(0,v-a),S=x-v+Math.min(f,v+a+1),k=0;for(let A=w;A<S;A++)k+=Math.pow(h[A],2);k=u*k+l;for(let A=w;A<S;A++){let _=-2*u*c*h[A]*g[x]/k;x===A&&(_+=Math.pow(k,-c)),_*=d[x],m[A]+=_}}return e.makeTensorInfo(i.shape,o.dtype,m)}var nV={kernelName:uf,backendName:"cpu",kernelFunc:ale};function i1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{reductionIndices:s,keepDims:i}=r,a=e,l=o.shape,u=l.length,c=b.parseAxisParam(s,l),p=c,f=N.getAxesPermutation(p,u),d=a.data.get(o.dataId).values;if(f!=null){let w=new Array(u);for(let S=0;S<w.length;S++)w[S]=l[f[S]];d=Hd(d,l,o.dtype,f,w),p=N.getInnerMostAxes(p.length,u),l=w}Z(o,"max"),N.assertAxesAreInnerMostDims("max",p,u);let[h,g]=N.computeOutAndReduceShapes(l,p),m=b.sizeFromShape(g),y=Wv(d,m,h,o.dtype),x=a.write(y,h,o.dtype),v=h;return i&&(v=N.expandShapeToKeepDim(h,c)),{dataId:x,shape:v,dtype:o.dtype}}var rV={kernelName:Ya,backendName:"cpu",kernelFunc:i1};function lle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t;Z(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l),p;if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))p=Gn({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=Kd(f,o.shape,o.dtype,d,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,h.values)}return p}var oV={kernelName:Za,backendName:"cpu",kernelFunc:lle};function ule(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Z(o,"maxPool3d");let c=N.computePool3DInfo(o.shape,s,i,1,a,l,u),p=e.data.get(o.dataId).values,f=sw(p,o.shape,o.dtype,b.computeStrides(o.shape),c,"max");return e.makeTensorInfo(f.shape,"float32",f.values)}var sV={kernelName:Qa,backendName:"cpu",kernelFunc:ule};function cle(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Z([o,s],"maxPool3DGrad");let c=N.computePool3DInfo(s.shape,i,a,1,l,u),p=e.bufferSync(s),f=ez(p,c),d=c.strideDepth,h=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,S=c.effectiveFilterWidth,k=v-1-c.padInfo.front,A=S-1-c.padInfo.left,_=w-1-c.padInfo.top,F=de(s.shape,"float32"),$=e.bufferSync(o);for(let V=0;V<c.batchSize;++V)for(let U=0;U<c.inChannels;++U)for(let W=0;W<c.inDepth;++W)for(let G=0;G<c.inHeight;++G)for(let H=0;H<c.inWidth;++H){let K=W-k,Q=G-_,X=H-A,J=0;for(let re=0;re<v;re+=m){let oe=(K+re)/d;if(!(oe<0||oe>=c.outDepth||Math.floor(oe)!==oe))for(let le=0;le<w;le+=y){let ae=(Q+le)/h;if(!(ae<0||ae>=c.outHeight||Math.floor(ae)!==ae))for(let pe=0;pe<S;pe+=x){let ue=(X+pe)/g;if(ue<0||ue>=c.outWidth||Math.floor(ue)!==ue)continue;let he=v*w*S-1-f.get(V,oe,ae,ue,U),Ie=re*w*S+le*S+pe,Ae=he===Ie?1:0;if(Ae===0)continue;let Ee=$.get(V,oe,ae,ue,U);J+=Ee*Ae}}}F.set(J,V,W,G,H,U)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}var iV={kernelName:pf,backendName:"cpu",kernelFunc:cle};function ple(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s,output:i}=t,a=s;Z([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,f=N.computePool2DInfo(a.shape,l,u,1,c,p),d=e.data.get(a.dataId).values,h=de(f.outShape,a.dtype,ow(d,a.shape,a.dtype,f).values),g=f.strideHeight,m=f.strideWidth,y=f.dilationHeight,x=f.dilationWidth,v=f.effectiveFilterHeight,w=f.effectiveFilterWidth,S=w-1-f.padInfo.left,k=v-1-f.padInfo.top,A=de(a.shape,"float32"),_=e.data.get(o.dataId).values,F=de(o.shape,"float32",_);for(let $=0;$<f.batchSize;++$)for(let V=0;V<f.inChannels;++V)for(let U=0;U<f.inHeight;++U)for(let W=0;W<f.inWidth;++W){let G=U-k,H=W-S,K=0;for(let Q=0;Q<v;Q+=y){let X=(G+Q)/g;if(!(X<0||X>=f.outHeight||Math.floor(X)!==X))for(let J=0;J<w;J+=x){let re=(H+J)/m;if(re<0||re>=f.outWidth||Math.floor(re)!==re)continue;let oe=v*w-1-h.get($,X,re,V),le=Q*w+J,ae=oe===le?1:0;if(ae===0)continue;let pe=F.get($,X,re,V);K+=pe*ae}}A.set(K,$,U,W,V)}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var aV={kernelName:cf,backendName:"cpu",kernelFunc:ple};function lV(n,t,e,r,o){let s=b.computeStrides(t),i=Kd(n,t,e,s,o,"max"),a=ow(n,t,e,o,!0,r);return[i.values,a.values]}var uV={kernelName:ff,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,l=e;Z(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=N.computePool2DInfo(r.shape,o,s,[1,1],i),[p,f]=lV(u,r.shape,r.dtype,a,c),d=l.write(p,c.outShape,r.dtype),h=l.write(f,c.outShape,r.dtype);return[{dataId:d,shape:c.outShape,dtype:r.dtype},{dataId:h,shape:c.outShape,dtype:"int32"}]}};function fle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r,a=b.parseAxisParam(s,o.shape),u=N.computeOutAndReduceShapes(o.shape,a)[1],c=b.sizeFromShape(u),p=[],f=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(f);let d=Ao({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(d);let h=ng({inputs:{a:d,b:f},backend:e});p.push(h);let g=pa({inputs:{x:h},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}var cV={kernelName:Ja,backendName:"cpu",kernelFunc:fle};function dle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;Z(o,"min");let a=b.parseAxisParam(s,o.shape),l=a,u=N.getAxesPermutation(l,o.shape.length),c=o;u!=null&&(c=Ut({inputs:{x:o},backend:e,attrs:{perm:u}}),l=N.getInnerMostAxes(l.length,o.shape.length)),N.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,f]=N.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,v=g[x];for(let w=0;w<d;++w){let S=g[x+w];(Number.isNaN(S)||S<v)&&(v=S)}h[y]=v}u!=null&&e.disposeIntermediateTensorInfo(c);let m=e.makeTensorInfo(p,c.dtype,h);if(i){let y=N.expandShapeToKeepDim(p,a),x=Ve({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var pV={kernelName:el,backendName:"cpu",kernelFunc:dle};function hle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{paddings:s,mode:i}=r;Z(o,"mirrorPad");let a=s.map((v,w)=>v[0]+o.shape[w]+v[1]),l=s.map(v=>v[0]),u=s.map((v,w)=>v[0]+o.shape[w]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,f=o.shape.length,d=b.computeStrides(o.shape),h=b.sizeFromShape(a),g=a.length,m=b.computeStrides(a),y=b.getTypedArrayFromDType(o.dtype,h);for(let v=0;v<h;v++){let w=b.indexToLoc(v,g,m);for(let k=0;k<g;k++)w[k]<l[k]?w[k]=l[k]*2-w[k]-c:w[k]>=u[k]&&(w[k]=(u[k]-1)*2-w[k]+c);w=w.map((k,A)=>k-l[A]);let S=b.locToIndex(w,f,d);y[v]=p[S]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var fV={kernelName:tl,backendName:"cpu",kernelFunc:hle};var mle=ze((n,t)=>{let e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),gle=Xe(Ei,mle),dV={kernelName:Ei,backendName:"cpu",kernelFunc:gle};var mV=gh(Tm());function a1(n){let{inputs:t,backend:e,attrs:r}=n,{logits:o}=t,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let l=b.parseAxisParam([a],o.shape),u=i1({inputs:{x:o},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=N.expandShapeToKeepDim(u.shape,l),p=Ve({inputs:{x:u},backend:e,attrs:{shape:c}}),f=eg({inputs:{a:o,b:p},backend:e}),d=DE({inputs:{x:f},backend:e}),h=pa({inputs:{x:d},backend:e,attrs:{axis:l,keepDims:!1}}),g=Ve({inputs:{x:h},backend:e,attrs:{shape:c}}),m=ng({inputs:{a:d,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var hV={kernelName:xl,backendName:"cpu",kernelFunc:a1};function yle(n){let{inputs:t,backend:e,attrs:r}=n,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=r;Z(o,"multinomial");let l=a?o:a1({inputs:{logits:o},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=e.data.get(l.dataId).values,f=[u,s],d=b.makeZerosTypedArray(b.sizeFromShape(f),"int32");for(let h=0;h<u;++h){let g=h*c,m=new Float32Array(c-1);m[0]=p[g];for(let v=1;v<m.length;++v)m[v]=m[v-1]+p[g+v];let y=mV.alea(i.toString()),x=h*s;for(let v=0;v<s;++v){let w=y();d[x+v]=m.length;for(let S=0;S<m.length;S++)if(w<m[S]){d[x+v]=S;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(f,"int32",d)}var gV={kernelName:df,backendName:"cpu",kernelFunc:yle};var xle=Un.nonMaxSuppressionV3Impl;function ble(n){let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Z(o,"NonMaxSuppression");let u=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=xle(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var yV={kernelName:hf,backendName:"cpu",kernelFunc:ble};var vle=Un.nonMaxSuppressionV4Impl;function wle(n){let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Z(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:f,validOutputs:d}=vle(c,p,i,a,l,u);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var xV={kernelName:mf,backendName:"cpu",kernelFunc:wle};var Cle=Un.nonMaxSuppressionV5Impl;function Ile(n){let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Z(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,f=i,d=a,h=l,g=u,{selectedIndices:m,selectedScores:y}=Cle(c,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var bV={kernelName:gf,backendName:"cpu",kernelFunc:Ile};function Sle(n){let{inputs:t,backend:e,attrs:r}=n,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:l}=r;Z(o,"oneHot");let u=b.sizeFromShape(o.shape),c=new Float32Array(u*i);c.fill(l);let p=e.data.get(o.dataId).values;for(let f=0;f<u;++f)p[f]>=0&&p[f]<i&&(c[f*i+p[f]]=a);return e.makeTensorInfo([...o.shape,i],s,c)}var vV={kernelName:ol,backendName:"cpu",kernelFunc:Sle};function sg(n){let{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=ko({inputs:{input:r},backend:e}),s=sg({inputs:{x:o},backend:e}),i=Ls({inputs:{input:r},backend:e}),a=sg({inputs:{x:i},backend:e}),l=mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return og({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var wV={kernelName:wl,backendName:"cpu",kernelFunc:sg};function CV(n){let{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=ko({inputs:{input:r},backend:e}),s=CV({inputs:{x:o},backend:e}),i=Ls({inputs:{input:r},backend:e}),a=sg({inputs:{x:i},backend:e}),l=mn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return og({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var IV={kernelName:rl,backendName:"cpu",kernelFunc:CV};function l1(n){let{inputs:t,backend:e,attrs:r}=n,{axis:o}=r;if(t.length===1)return Xd({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=Xd({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),u=Zl({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var SV={kernelName:sl,backendName:"cpu",kernelFunc:l1};function Tle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{paddings:s,constantValue:i}=r;Z(o,"pad");let a=s.map((x,v)=>x[0]+o.shape[v]+x[1]),l=s.map(x=>x[0]),u=e.data.get(o.dataId).values,c=b.sizeFromShape(o.shape),p=o.shape.length,f=b.computeStrides(o.shape),d=b.sizeFromShape(a),h=a.length,g=b.computeStrides(a),m=b.getTypedArrayFromDType(o.dtype,d);i!==0&&m.fill(i);for(let x=0;x<c;x++){let w=b.indexToLoc(x,p,f).map((k,A)=>k+l[A]),S=b.locToIndex(w,h,g);m[S]=u[x]}return{dataId:e.write(m,a,o.dtype),shape:a,dtype:o.dtype}}var aw={kernelName:il,backendName:"cpu",kernelFunc:Tle};var Nle=ze((n,t)=>Math.pow(n,t)),Ele=Xe(ki,Nle),TV={kernelName:ki,backendName:"cpu",kernelFunc:Ele};function Dle(n){let{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=r,l=o.map(y=>e.data.get(y.dataId).values),u=o.map(y=>y.shape),c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,[f,d,h]=jv(l,u,c,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var NV={kernelName:yf,backendName:"cpu",kernelFunc:Dle};function kle(n){let{inputs:t,backend:e}=n,{starts:r,limits:o,deltas:s}=t,i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=Hv(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),f=e.makeTensorInfo([c.length],r.dtype,c);return[p,f]}var EV={kernelName:xf,backendName:"cpu",kernelFunc:kle};function Ale(n){let{inputs:t,backend:e,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,f=a.map(m=>e.data.get(m.dataId).values),d=a.map(m=>m.shape),[h,g]=qv(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var DV={kernelName:bf,backendName:"cpu",kernelFunc:Ale};function Rle(n){let{backend:t,attrs:e}=n,{start:r,stop:o,dtype:s,step:i}=e,a=Kv(r,o,i,s);return t.makeTensorInfo([a.length],s,a)}var kV={kernelName:vf,backendName:"cpu",kernelFunc:Rle};var _le=Ce(Ai,n=>1/n),AV={kernelName:Ai,backendName:"cpu",kernelFunc:_le};function Ole(n){let{inputs:t,backend:e,attrs:r}=n,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=r;Z(o,"resizeBilinear");let l=b.computeStrides(o.shape),[u,c]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(b.sizeFromShape([p,u,c,h])),y=[s&&u>1?f-1:f,s&&c>1?d-1:d],x=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=0,w=y[0]/x[0],S=y[1]/x[1];for(let k=0;k<p;k++)for(let A=0;A<u;A++){let _;i?_=w*(A+.5)-.5:_=w*A;let F=Math.max(0,Math.floor(_)),$=_-F,V=Math.min(f-1,Math.ceil(_)),U=k*l[0]+F*l[1],W=k*l[0]+V*l[1];for(let G=0;G<c;G++){let H;i?H=S*(G+.5)-.5:H=S*G;let K=Math.max(0,Math.floor(H)),Q=H-K,X=Math.min(d-1,Math.ceil(H)),J=U+K*l[2],re=W+K*l[2],oe=U+X*l[2],le=W+X*l[2];for(let ae=0;ae<h;ae++){let pe=g[J+ae],ue=g[re+ae],he=g[oe+ae],Ie=g[le+ae],Ae=pe+(he-pe)*Q,Ee=ue+(Ie-ue)*Q,Ge=Ae+(Ee-Ae)*$;m[v++]=Ge}}}return e.makeTensorInfo([p,u,c,h],"float32",m)}var RV={kernelName:pl,backendName:"cpu",kernelFunc:Ole};function Mle(n){let{inputs:t,backend:e,attrs:r}=n,{images:o,dy:s}=t,{alignCorners:i}=r;Z([s,o],"resizeBilinearGrad");let a=b.computeStrides(o.shape),[l,u,c,p]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*u*c*p),g=[i&&f>1?u-1:u,i&&d>1?c-1:c],m=[i&&f>1?f-1:f,i&&d>1?d-1:d],y=g[0]/m[0],x=g[1]/m[1],v=e.data.get(s.dataId).values,w=0;for(let S=0;S<l;S++){let k=S*a[0];for(let A=0;A<f;A++){let _=A*y,F=Math.floor(_),$=Math.min(Math.ceil(_),u-1),V=k+F*a[1],U=k+$*a[1],W=_-F,G=1-W;for(let H=0;H<d;H++){let K=H*x,Q=Math.floor(K),X=Math.min(Math.ceil(K),c-1),J=K-Q,re=1-J,oe=V+Q*a[2],le=V+X*a[2],ae=U+Q*a[2],pe=U+X*a[2],ue=G*re,he=G*J,Ie=W*re,Ae=W*J;for(let Ee=0;Ee<p;Ee++){let Ge=v[w++];h[oe+Ee]+=Ge*ue,h[le+Ee]+=Ge*he,h[ae+Ee]+=Ge*Ie,h[pe+Ee]+=Ge*Ae}}}}return e.makeTensorInfo([l,c,u,p],"float32",h)}var _V={kernelName:If,backendName:"cpu",kernelFunc:Mle};function Fle(n){let{inputs:t,backend:e,attrs:r}=n,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=r;Z(o,"resizeNearestNeighbor");let l=b.computeStrides(o.shape),[u,c]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(p*u*c*h),y=[s&&u>1?f-1:f,s&&c>1?d-1:d],x=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/x[0],w=y[1]/x[1],S=0;for(let k=0;k<p;k++){let A=k*l[0];for(let _=0;_<u;_++){let F=i?v*(_+.5):v*_,$=Math.min(f-1,s?Math.round(F):Math.floor(F));i&&($=Math.max(0,$));let V=A+$*l[1];for(let U=0;U<c;U++){let W=i?w*(U+.5):w*U,G=Math.min(d-1,s?Math.round(W):Math.floor(W));i&&(G=Math.max(0,G));let H=V+G*l[2];for(let K=0;K<h;K++){let Q=g[H+K];m[S++]=Q}}}}return e.makeTensorInfo([p,u,c,h],o.dtype,m)}var OV={kernelName:cl,backendName:"cpu",kernelFunc:Fle};function $le(n){let{inputs:t,backend:e,attrs:r}=n,{images:o,dy:s}=t,{alignCorners:i}=r;Z([s,o],"resizeNearestNeighborGrad");let a=b.computeStrides(o.shape),l=b.computeStrides(s.shape),[u,c,p,f]=o.shape,[,d,h]=s.shape,g=new Float32Array(u*c*p*f),m=e.data.get(s.dataId).values,y=[i&&d>1?c-1:c,i&&h>1?p-1:p],x=[i&&d>1?d-1:d,i&&h>1?h-1:h],v=y[0]/x[0],w=y[1]/x[1],S=1/v,k=1/w,A=Math.ceil(S)*2+2,_=Math.ceil(k)*2+2;for(let F=0;F<u;F++){let $=F*a[0];for(let V=0;V<c;V++){let U=$+V*a[1],W=Math.floor(V*S),G=Math.floor(W-A/2);for(let H=0;H<p;H++){let K=U+H*a[2],Q=Math.floor(H*k),X=Math.floor(Q-_/2);for(let J=0;J<f;J++){let re=0;for(let oe=0;oe<A;oe++){let le=oe+G;if(le<0||le>=d)continue;let ae=$+le*l[1],pe=le*v,ue=Math.min(c-1,i?Math.round(pe):Math.floor(pe));if(V===ue)for(let he=0;he<_;he++){let Ie=he+X;if(Ie<0||Ie>=h)continue;let Ae=ae+Ie*l[2],Ee=Ie*w,Ge=Math.min(p-1,i?Math.round(Ee):Math.floor(Ee));H===Ge&&(re+=m[Ae+J])}}g[K+J]=re}}}}return e.makeTensorInfo(o.shape,o.dtype,g)}var MV={kernelName:Cf,backendName:"cpu",kernelFunc:$le};function Ple(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{dims:s}=r;Z(o,"reverse");let i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Gn({inputs:{x:o},backend:e});let l=new tt(o.shape,o.dtype),u=e.bufferSync(o);for(let c=0;c<l.size;c++){let p=l.indexToLoc(c),f=p.slice();a.forEach(d=>f[d]=o.shape[d]-1-f[d]),l.set(u.get(...f),...p)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}var FV={kernelName:fl,backendName:"cpu",kernelFunc:Ple};var $V={kernelName:zf,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=t,a=e,l=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[u,c,p,f]=r.shape,[d,h]=N.getImageCenter(i,c,p),g=255,m=Math.sin(o),y=Math.cos(o),x=a.data.get(r.dataId).values;for(let w=0;w<u;w++){let S=w*p*c*f;for(let k=0;k<c;k++){let A=k*(p*f);for(let _=0;_<p;_++){let F=_*f;for(let $=0;$<f;$++){let V=[u,k,_,$],U=V[2],W=V[1],G=(U-d)*y-(W-h)*m,H=(U-d)*m+(W-h)*y;G=Math.round(G+d),H=Math.round(H+h);let K=s;if(typeof s!="number"&&($===3?K=g:K=s[$]),G>=0&&G<p&&H>=0&&H<c){let X=H*(p*f),J=G*f,re=S+X+J+$;K=x[re]}let Q=S+A+F+$;l[Q]=K}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var Lle=Ce(Oi,n=>{let t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),PV={kernelName:Oi,backendName:"cpu",kernelFunc:Lle};function Ble(n){let{inputs:t,backend:e,attrs:r}=n,{indices:o,updates:s}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(s,o,i),f=!0,d=e.bufferSync(o),h=e.bufferSync(s),g=ss(d,h,i,p,u,l,a,c,0,f);return e.makeTensorInfo(i,g.dtype,g.values)}var LV={kernelName:Sf,backendName:"cpu",kernelFunc:Ble};function zle(n,t){let e=0,r=n.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),n[o]<t?e=o+1:r=o;return r}function Vle(n,t){let e=0,r=n.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),n[o]<=t?e=o+1:r=o;return r}function BV(n,t,e,r,o,s){let i=b.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let l=n.slice(a*r,(a+1)*r),u=a*o;for(let c=0;c<o;++c)i[u+c]=s==="left"?zle(l,t[c+u]):Vle(l,t[c+u])}return i}function Ule(n){let{inputs:t,backend:e,attrs:r}=n,{sortedSequence:o,values:s}=t,{side:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,u=BV(a,l,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",u)}var zV={kernelName:Nf,backendName:"cpu",kernelFunc:Ule};function Gle(n){let{inputs:t,backend:e}=n,{condition:r,t:o,e:s}=t;Z([r,o,s],"select");let i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=nn(o.dtype,s.dtype),p=b.makeZerosTypedArray(b.sizeFromShape(o.shape),c),f=0,d=i===0||i>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let h=0;h<a.length;h++)for(let g=0;g<d;g++)a[h]===1?p[f++]=l[h]:p[f++]=u[h];return e.makeTensorInfo(o.shape,c,p)}var VV={kernelName:dl,backendName:"cpu",kernelFunc:Gle};var Wle=N.SELU_SCALEALPHA,jle=N.SELU_SCALE,Hle=Ce(Fi,n=>n>=0?jle*n:Wle*(Math.exp(n)-1)),UV={kernelName:Fi,backendName:"cpu",kernelFunc:Hle};var qle=Ce(Li,n=>n<0?-1:n>0?1:0),GV={kernelName:Li,backendName:"cpu",kernelFunc:qle};var Kle=Ce($i,n=>Math.sin(n)),WV={kernelName:$i,backendName:"cpu",kernelFunc:Kle};var Xle=Ce(Pi,n=>Math.sinh(n)),jV={kernelName:Pi,backendName:"cpu",kernelFunc:Xle};var Yle=11920928955078125e-23,HV=Math.log(Yle)+2,Zle=Ce(zi,n=>{let t=n>-HV,e=n<HV,r=Math.exp(n),o;return e?o=r:t?o=n:o=Math.log(1+r),o}),qV={kernelName:zi,backendName:"cpu",kernelFunc:Zle};function Qle(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockShape:s,paddings:i}=r;Z([o],"spaceToBatchND");let a=b.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let k=1+s.length;k<o.shape.length;++k)l.push([0,0]);let u=aw.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),c=N.getReshaped(u.shape,s,a,!1),p=N.getPermuted(c.length,s.length,!1),f=N.getReshapedPermuted(u.shape,s,a,!1),g=Ve({inputs:{x:u},backend:e,attrs:{shape:c}}),x=Ut({inputs:{x:g},backend:e,attrs:{perm:p}}),S=Ve({inputs:{x},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),S}var KV={kernelName:gl,backendName:"cpu",kernelFunc:Qle};function Jle(n){let{inputs:t,backend:e}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,f,d,h,g]=Xv(a,r.shape,r.dtype,l,o.dtype,u,c);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var XV={kernelName:Ef,backendName:"cpu",kernelFunc:Jle};function eue(n){let{inputs:t,backend:e}=n,{inputIndices:r,inputShape:o,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(s.dataId).values),[u,c,p]=Yv(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var YV={kernelName:Df,backendName:"cpu",kernelFunc:eue};function tue(n){let{inputs:t,backend:e}=n,{data:r,indices:o,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=qd(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}var ZV={kernelName:kf,backendName:"cpu",kernelFunc:tue};function nue(n){let{inputs:t,backend:e}=n,{data:r,indices:o,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[u,c]=qd(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}var QV={kernelName:Af,backendName:"cpu",kernelFunc:nue};function rue(n){let{inputs:t,backend:e,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=N.calculateShapes(s,o,a),d=!1,h=e.bufferSync(o),g;switch(s.dtype){case"bool":{let m=e.bufferSync(s),y=!!e.data.get(i.dataId).values[0];g=ss(h,m,a,f,c,u,l,p,y,d);break}case"float32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=ss(h,m,a,f,c,u,l,p,y,d);break}case"int32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=ss(h,m,a,f,c,u,l,p,y,d);break}case"string":{let m=e.bufferSync(s),y=b.decodeString(e.data.get(i.dataId).values[0]);g=ss(h,m,a,f,c,u,l,p,y,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}var JV={kernelName:Rf,backendName:"cpu",kernelFunc:rue};function oue(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=N.prepareSplitSize(o,s,a),u=new Array(o.shape.length).fill(0),c=o.shape.slice();return l.map(p=>{let f=[...c];f[a]=p;let d=_o({inputs:{x:o},backend:e,attrs:{begin:u,size:f}});return u[a]+=p,d})}var eU={kernelName:yl,backendName:"cpu",kernelFunc:oue};var tU={kernelName:_f,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{let{x:e}=n,r=t;Z(e,"square");let o=r.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let l=o[a];s[a]=l*l}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var sue=Ce(Hi,(n,t)=>{let e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),nU={kernelName:Hi,backendName:"cpu",kernelFunc:sue};function iue(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=r;Z(o,"stridedSlice");let{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:v,strides:w}=Cn.sliceInfo(o.shape,s,i,a,l,u,c,p,f),S;if(g)S=Ve({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let k=Cn.computeOutShape(x,v,w),A=_o({inputs:{x:o},backend:e,attrs:{begin:x,size:k}});S=Ve({inputs:{x:A},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(A)}else{let k=e.bufferSync(o),A=Zv(d,k,w,x);S=e.makeTensorInfo(h,A.dtype,A.values)}return S}var rU={kernelName:Of,backendName:"cpu",kernelFunc:iue};function aue(n){let{inputs:t,backend:e,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,f=e.data.get(c.dataId).values,d=e.data.get(p.dataId).values,[h,g]=Qv(f,d,o,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var oU={kernelName:Mf,backendName:"cpu",kernelFunc:aue};function lue(n){let{inputs:t,backend:e,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values[0],[u,c,p]=Jv(a,l,o),f=c.length;return[e.makeTensorInfo([f,2],"int32",u),e.makeTensorInfo([f],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var sU={kernelName:Ff,backendName:"cpu",kernelFunc:lue};function uue(n){let{inputs:t,backend:e,attrs:r}=n,{numBuckets:o}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=ew(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var iU={kernelName:$f,backendName:"cpu",kernelFunc:uue};var cue=Ce(Wi,n=>Math.tan(n)),aU={kernelName:Wi,backendName:"cpu",kernelFunc:cue};var pue=Ce(ji,n=>Math.tanh(n)),lU={kernelName:ji,backendName:"cpu",kernelFunc:pue};function fue(n){let{inputs:t,backend:e}=n,{tensor:r,indices:o,updates:s}=t,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=N.calculateShapes(s,o,r.shape),p=!1,f=e.bufferSync(o),d=e.bufferSync(s),h=e.bufferSync(r),g=ss(f,d,r.shape,c,l,a,i,u,h,p);return e.makeTensorInfo(r.shape,g.dtype,g.values)}var uU={kernelName:Tf,backendName:"cpu",kernelFunc:fue};function due(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{reps:s}=r;Z(o,"tile");let i=tw(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var cU={kernelName:ws,backendName:"cpu",kernelFunc:due};function hue(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{k:s,sorted:i}=r;Z(o,"topk");let a=e.data.get(o.dataId).values,[l,u]=nw(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}var pU={kernelName:Pf,backendName:"cpu",kernelFunc:hue};function mue(n){let{inputs:t,attrs:e,backend:r}=n,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=e,[c,p,f,d]=o.shape,[h,g]=u??[p,f],m=[c,h,g,d],y=b.computeStrides(o.shape),x=y[0],v=y[1],w=y[2],S=b.computeStrides(m),k=S[0],A=S[1],_=S[2],F=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(m));F.fill(l);let $=r.data.get(o.dataId).values,V=r.data.get(s.dataId).values;for(let W=0;W<c;++W){let G=s.shape[0]===1?V:V.subarray(W*8,W*8+8);for(let H=0;H<h;++H)for(let K=0;K<g;++K)for(let Q=0;Q<d;++Q){let X,J=G[6]*K+G[7]*H+1;if(J===0)continue;let re=(G[0]*K+G[1]*H+G[2])/J,oe=(G[3]*K+G[4]*H+G[5])/J,le=fU(re,f,a),ae=fU(oe,p,a);switch(i){case"nearest":X=vue($,p,f,x,v,w,W,ae,le,Q,l);break;case"bilinear":X=wue($,p,f,x,v,w,W,ae,le,Q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let pe=W*k+H*A+K*_+Q;F[pe]=X}return r.makeTensorInfo(m,o.dtype,F)}return{dataId:r.write(F,m,o.dtype),shape:o.shape,dtype:o.dtype}}var dU={kernelName:Lf,backendName:"cpu",kernelFunc:mue};function fU(n,t,e){switch(e){case"reflect":return gue(n,t);case"wrap":return yue(n,t);case"nearest":return bue(n,t);case"constant":default:return xue(n,t)}}function gue(n,t){let e=n;if(e<0)if(t<=1)e=0;else{let r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{let r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return b.clamp(0,e,t-1)}function yue(n,t){let e=n;if(e<0)if(t<=1)e=0;else{let r=t-1;e+=t*(Math.trunc(-e/r)+1)}else if(e>t-1)if(t<=1)e=0;else{let r=t-1;e-=t*Math.trunc(e/r)}return b.clamp(0,e,t-1)}function xue(n,t){return n}function bue(n,t){return b.clamp(0,n,t-1)}function ig(n,t,e,r,o,s,i,a,l,u,c){let p=i*r+a*o+l*s+u;return 0<=a&&a<t&&0<=l&&l<e?n[p]:c}function vue(n,t,e,r,o,s,i,a,l,u,c){let p=Math.round(a),f=Math.round(l);return ig(n,t,e,r,o,s,i,p,f,u,c)}function wue(n,t,e,r,o,s,i,a,l,u,c){let p=Math.floor(a),f=Math.floor(l),d=p+1,h=f+1,g=(h-l)*ig(n,t,e,r,o,s,i,p,f,u,c)+(l-f)*ig(n,t,e,r,o,s,i,p,h,u,c),m=(h-l)*ig(n,t,e,r,o,s,i,d,f,u,c)+(l-f)*ig(n,t,e,r,o,s,i,d,h,u,c);return(d-a)*g+(a-p)*m}function Cue(n){let{inputs:t,attrs:e,backend:r}=n,{axis:o}=e,{x:s}=t;Z(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:u}=rw(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var hU={kernelName:Bf,backendName:"cpu",kernelFunc:Cue};function Iue(n){let{inputs:t,backend:e,attrs:r}=n,{value:o}=t,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],l=new Array(i-1),u=0;for(let d=0;d<i;d++)d!==s&&(l[u++]=o.shape[d]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let f=new Array(a);for(let d=0;d<f.length;d++){c[s]=d;let h=_o({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});f[d]=Ve({inputs:{x:h},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(h)}return f}var mU={kernelName:bl,backendName:"cpu",kernelFunc:Iue};function Sue(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,segmentIds:s}=t,{numSegments:i}=r;Z(o,"unsortedSegmentSum");let a=o.shape.length,l=s.shape.length,u=[],c=[],p=a-l,f=s;for(let h=0;h<p;++h){let g=Xd({inputs:{input:f},backend:e,attrs:{dim:h+1}});f=g,c.push(g)}for(let h=0;h<i;++h){let g=b.createScalarValue(h,"int32"),m=e.makeTensorInfo([],"int32",g),y=NE({inputs:{a:m,b:f},backend:e}),x=Ao({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),v=Ec({inputs:{a:x,b:o},backend:e}),w=pa({inputs:{x:v},backend:e,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(m),c.push(y),c.push(x),c.push(v),c.push(w)}let d=l1({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var gU={kernelName:vl,backendName:"cpu",kernelFunc:Sue};var Tue=[VB,X3,UB,GB,eB,WB,jB,HB,qB,KB,XB,YB,ZB,QB,JB,tz,nz,rz,oz,zB,sz,iz,az,tB,lz,J3,nB,uz,Y3,cz,fz,dz,hz,mz,gz,yz,xz,bz,vz,wz,Cz,Iz,Sz,Tz,Nz,Ez,Dz,kz,Az,Rz,_z,Oz,Fz,MB,$z,rB,Pz,oB,Lz,sB,Bz,zz,Vz,iB,aB,Uz,Gz,Wz,jz,lB,uB,Z3,Hz,pz,qz,Kz,Xz,FB,cB,pB,Yz,fB,Zz,Qz,Jz,eV,tV,nV,rV,dB,oV,sV,iV,aV,uV,cV,pV,hB,fV,dV,gV,mB,gB,yV,xV,bV,yB,vV,IV,SV,aw,TV,$B,bB,NV,EV,DV,kV,Q3,rg,AV,PB,LB,BB,RV,_V,OV,MV,FV,$V,PV,SB,LV,zV,VV,UV,NB,GV,WV,jV,EB,hV,qV,KV,XV,YV,ZV,QV,JV,eU,kB,tU,AB,RB,nU,rU,oU,sU,iU,_B,Mz,aU,lU,uU,cU,pU,dU,xB,hU,mU,gU,wV];for(let n of Tue)Qy(n);var kc={},lw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function yU(n,t){kc[n]=t}function Vr(n,t){if(!(n in kc)||t!=null){let r=Eue(n,t);if(r!==null)kc[n]=r;else return console.log("Could not get context for WebGL version",n),null}let e=kc[n];return e==null||e.isContextLost()?(delete kc[n],Vr(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),kc[n])}function Nue(n){if(!L().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Eue(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t??Nue(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete kc[n]},!1),L().getBool("SOFTWARE_WEBGL_ENABLED")&&(lw.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",lw)||e.getContext("experimental-webgl",lw):e.getContext("webgl2",lw)}var Ac=function(n){return n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",n}(Ac||{}),Jn=function(n){return n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",n}(Jn||{}),Wn=function(n){return n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",n}(Wn||{});function Rc(n,t){return[t,n]}function xU(n,t){return n*t}function ag(n){let t=b.sizeFromShape(n),e=Math.ceil(t/4);return b.sizeToSquarishShape(e)}function Bs(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function bU(n,t){let[e,r]=Bs(n,t);return e*r*4}function lg(n,t){let e=n,r,o,s,i,a,l,u,c,p,f;return L().getNumber("WEBGL_VERSION")===2?(r=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,u=4,c=1,p=e.HALF_FLOAT,f=e.FLOAT,l=e.RGBA8):(r=n.RGBA,o=n.RGBA,s=n.RGBA,i=e.RGBA,a=n.RGBA,u=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:f}}function fe(n,t){let e=t();return L().getBool("DEBUG")&&Due(n),e}function Due(n){let t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+Rue(n,t))}var kue=596e-10,Aue=65504;function vU(n){return!!(L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||kue<Math.abs(n)&&Math.abs(n)<Aue)}function Rue(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ug(n,t){return fa(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function wU(n,t){let e=fa(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(fe(n,()=>n.shaderSource(e,t)),fe(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function CU(n,t){let e=fa(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(fe(n,()=>n.shaderSource(e,t)),fe(n,()=>n.compileShader(e)),L().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw d1(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var _ue=/ERROR: [0-9]+:([0-9]+):/g;function d1(n,t){let e=_ue.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}let r=+e[1],o=n.split(`
`),s=o.length.toString().length+2,i=o.map((p,f)=>b.rightPad((f+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${b.rightPad(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function IU(n){return fa(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function SU(n,t){if(fe(n,()=>n.linkProgram(t)),!L().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function cw(n,t){if(fe(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function TU(n,t){let e=fa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return fe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),fe(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function NU(n,t){let e=fa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return fe(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),fe(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function EU(n){return fa(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function DU(n,t){let e=L().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){let r=`[${n}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>e||t>e){let r=`[${n}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function kU(n){return fa(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function h1(n,t,e,r,o,s,i){let a=n.getAttribLocation(t,e);return a===-1?!1:(fe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),fe(n,()=>n.vertexAttribPointer(a,o,n.FLOAT,!1,s,i)),fe(n,()=>n.enableVertexAttribArray(a)),!0)}function Oue(n,t,e){Fue(n,e),fe(n,()=>n.activeTexture(n.TEXTURE0+e)),fe(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function AU(n,t,e){return fa(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function RU(n,t,e){return n.getUniformLocation(t,e)}function _U(n,t,e,r){fe(n,()=>Oue(n,t,r)),fe(n,()=>n.uniform1i(e,r))}function pw(n,t,e){fe(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),fe(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function m1(n,t){fe(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),fe(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function cg(n){let t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Mue(n,t))}function Mue(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function fa(n,t,e){let r=fe(n,()=>t());if(r==null)throw new Error(e);return r}function Fue(n,t){let e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Ql(n,t=2){return b.sizeFromShape(n.slice(0,n.length-t))}function Jl(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function pg(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[Ql(n),...Jl(n)]),t}function OU(n,t=!1){let e=L().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=L().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&L().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e=e*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?b.nearestLargerEven(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=b.squeezeShape(n).newShape);let o=b.sizeFromShape(n),s=null;n.length<=1&&o<=e?s=[1,o]:n.length===2&&n[0]<=e&&n[1]<=e?s=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(s=[n[0],n[1]*n[2]*n[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let a=Ql(n),l=2,u=2;n.length&&([l,u]=Jl(n)),o=a*(l/2)*(u/2),s=b.sizeToSquarishShape(o).map(c=>c*2)}else s=b.sizeToSquarishShape(o);return s}function uw(n){return n%2===0}function _c(n,t){if(n=n.slice(-2),t=t.slice(-2),b.arraysEqual(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){let e=n[n.length-1],r=t[t.length-1];if(e===r||uw(e)&&uw(r)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&uw(n[0])&&uw(t[0])}var c1,p1;function MU(n){if(c1==null){let t=Vr(n);c1=t.getParameter(t.MAX_TEXTURE_SIZE)}return c1}function FU(n){if(p1==null){let t=Vr(n);p1=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,p1)}function $U(n){if(n===0)return 0;let t,e=Vr(n);return oo(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:oo(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function oo(n,t){return n.getExtension(t)!=null}function g1(n){try{if(Vr(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function PU(n){if(n===0)return!1;let t=Vr(n);if(n===1){if(!oo(t,"OES_texture_float"))return!1}else if(!oo(t,"EXT_color_buffer_float"))return!1;return f1(t)}function LU(n){if(n===0)return!1;let t=Vr(n);if(n===1){if(!oo(t,"OES_texture_float")||!oo(t,"WEBGL_color_buffer_float"))return!1}else{if(oo(t,"EXT_color_buffer_float"))return f1(t);let r="EXT_color_buffer_half_float";if(oo(t,r)){let o=t.getExtension(r);return $ue(t,o)}return!1}return f1(t)}function f1(n){let t=lg(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);let i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(s),i}function $ue(n,t){let e=lg(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);let a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}function BU(n){return n!==2?!1:Vr(n).fenceSync!=null}function zs(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var be=L();be.registerFlag("HAS_WEBGL",()=>be.getNumber("WEBGL_VERSION")>0);be.registerFlag("WEBGL_VERSION",()=>g1(2)?2:g1(1)?1:0);be.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);be.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>be.get("WEBGL_VERSION")===2);be.registerFlag("WEBGL_CPU_FORWARD",()=>!0);be.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);be.registerFlag("WEBGL_PACK",()=>be.getBool("HAS_WEBGL"));be.registerFlag("WEBGL_PACK_NORMALIZATION",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_CLIP",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_REDUCE",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_LAZILY_UNPACK",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_CONV_IM2COL",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>be.getBool("WEBGL_PACK"));be.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>MU(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>FU(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let n=be.getNumber("WEBGL_VERSION");return n===0?0:$U(n)});be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>be.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Sl.isMobile());be.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>PU(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>be.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:be.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));be.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>LU(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_FENCE_API_ENABLED",()=>BU(be.getNumber("WEBGL_VERSION")));be.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>be.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);be.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});be.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Sl.isMobile()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});be.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);be.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);be.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);be.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);be.registerFlag("WEBGL_EXP_CONV",()=>!1);be.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>be.getBool("IS_TEST"));be.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);be.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);be.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);be.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Gt(){let n,t,e,r,o,s,i,a,l,u;return L().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=L().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function is(n,t,e="index"){let r=b.computeStrides(t);return r.map((o,s)=>{let i=`int ${n[s]} = ${e} / ${o}`,a=s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * ${o}`:`index -= ${n[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Oc(n,t,e="index"){let r=b.computeStrides(t);return r.map((o,s)=>{let i=`int ${n[s]} = ${e} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Pue(n,t){let e=n.length,r=n.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=r[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function zU(n,t,e="index"){let r=n.map((s,i)=>i),o=Pue(r,t);return o.map((s,i)=>{let a=`int ${n[i]} = ${e} / ${o[i]}`,l=i===o.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${o[i]}`:`index -= ${n[i]} * ${o[i]}`;return`${a}; ${l};`}).join("")}function Yd(n){let t=b.computeStrides(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Zd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var dw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:VU}=N;function UU(n,t,e){let r=[];if(n.forEach(d=>{let h=b.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),e.enableShapeUniforms){let{uniformShape:g}=hw(e.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=r.join(`
`),s=n.map(d=>Lue(d,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=Gt(),l=Vue(a),u,c,p=Wue(a);return t.isPacked?(u=Bue(t.logicalShape,i,e.enableShapeUniforms),c=Gue(a)):(u=zue(t.logicalShape,i,e.enableShapeUniforms),c=Uue(a)),e.packedInputs&&(p+=Kue),[p,l,c,o,u,s,e.userCode].join(`
`)}function Jd(n,t=!1){let e=n.shapeInfo.logicalShape;switch(e.length){case 0:return ice(n,t);case 1:return lce(n,t);case 2:return cce(n,t);case 3:return fce(n,t);case 4:return hce(n,t);case 5:return mce(n);case 6:return gce(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function GU(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return sce(n);case 1:return ace(n,t);case 2:return uce(n,t);case 3:return pce(n,t);default:return dce(n,t)}}function Lue(n,t,e=!1,r){let o="";e?o+=GU(n,r):o+=Jd(n,r);let s=n.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=yce(n,t):o+=xce(n,t)),o}function Bue(n,t,e){switch(n.length){case 0:return WU();case 1:return Xue(n,t,e);case 2:return rce(n,t,e);case 3:return Zue(n,t,e);default:return Jue(n,t,e)}}function zue(n,t,e){switch(n.length){case 0:return WU();case 1:return Yue(n,t,e);case 2:return oce(n,t,e);case 3:return Que(n,t,e);case 4:return ece(n,t,e);case 5:return tce(n,t);case 6:return nce(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Vue(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Uue(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Gue(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Wue(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${jue}
    ${Hue}
    ${que}
  `}var jue=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Hue=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,que=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Kue=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function WU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Xue(n,t,e){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Yue(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Zue(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[2]/2),s=o*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Que(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Oc(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;let r=is(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Jue(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[n.length-1]/2),s=o*Math.ceil(n[n.length-2]/2),i=s,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)i*=n[n.length-u-1],a=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${n.length}(${l});
    }
  `}function ece(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Oc(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;let r=is(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function tce(n,t){let e=is(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function nce(n,t){let e=is(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function rce(n,t,e){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(b.arraysEqual(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function oce(n,t,e){return b.arraysEqual(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Mc(n){return`offset${n}`}function sce(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Gt();return`
    vec4 ${e}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function ice(n,t){let e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;let[o,s]=n.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Mc(e);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function ace(n,t){let e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=n.shapeInfo.texShape,s=Gt();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function lce(n,t){let e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${eh(n)}
      }
    `;let o=n.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Mc(e);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function uce(n,t){let e=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=s[0],a=s[1],l=Gt();if(s!=null&&b.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function cce(n,t){let e=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&b.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let f=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=b.squeezeShape(e),l=i;if(l.length<e.length){let f=th(n,l),d=["row","col"];return`
      ${Jd(f,t)}
      float ${o}(int row, int col) {
        return ${o}(${nh(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${eh(n)}
      }
    `;let u=s[0],c=s[1],p=Mc(r);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function pce(n,t){let e=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let f=e.slice(1),d=[1,2],h=th(n,f),g=["b","row","col"];return`
        ${GU(h,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${nh(g,d)});
        }
      `}let a=Gt();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function fce(n,t){let e=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=b.squeezeShape(e),u=a;if(u.length<e.length){let g=th(n,u),m=["row","col","depth"];return`
        ${Jd(g,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${nh(m,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${eh(n)}
      }
    `;let c=n.shapeInfo.texShape,p=c[0],f=c[1],d=n.shapeInfo.flatOffset;if(f===s&&d==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===i&&d==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let h=Mc(r);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function dce(n,t){let e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=Gt();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=n.shapeInfo.logicalShape,i=s.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],p=Math.ceil(s[i-1]/2),f=p*Math.ceil(s[i-2]/2),d="int b, int row, int col",h=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let g=2;g<i-1;g++)d=`int b${g}, `+d,f*=s[i-g-1],h=`b${g} * ${f} + `+h;return`
    vec4 ${r}(${d}) {
      int index = ${h};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${o.texture2D}(${e}, uv);
    }
  `}function hce(n,t){let e=n.shapeInfo.logicalShape,r=n.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:l,keptDims:u}=b.squeezeShape(e);if(l.length<e.length){let x=th(n,l),v=["row","col","depth","depth2"];return`
      ${Jd(x,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${nh(v,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${eh(n)}
      }
    `;let c=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,f=p[0],d=p[1],h=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${h}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Mc(r);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function mce(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:l,keptDims:u}=b.squeezeShape(t);if(l.length<t.length){let g=th(n,l),m=["row","col","depth","depth2","depth3"];return`
      ${Jd(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${nh(m,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${eh(n)}
      }
    `;let c=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,f=p[0],d=p[1];if(d===a&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Mc(e);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function gce(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(t);if(o.length<t.length){let m=th(n,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Jd(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${nh(y,s)});
      }
    `}let i=t[5],a=t[4]*i,l=t[3]*a,u=t[2]*l,c=t[1]*u;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${eh(n)}
      }
    `;let p=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],h=f[1];if(h===c&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let g=Mc(e);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function eh(n){let t=n.name,e=b.sizeFromShape(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function yce(n,t){let e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=VU(n.shapeInfo.logicalShape,t.logicalShape),l=ke(i),u=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(x=>`coords.${p[x+u]} = 0;`).join(`
`);let f="";i<2&&s>0?f="coords":f=n.shapeInfo.logicalShape.map((x,v)=>`coords.${p[v+u]}`).join(", ");let d="return outputValue;",g=b.sizeFromShape(n.shapeInfo.logicalShape)===1,y=b.sizeFromShape(t.logicalShape)===1;if(s===1&&!g&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){let x=s-2,v=s-1;a.indexOf(x)>-1&&a.indexOf(v)>-1?d="return vec4(outputValue.x);":a.indexOf(x)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(v)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function xce(n,t){let e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=t.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&b.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let u=ke(l),c=VU(n.shapeInfo.logicalShape,t.logicalShape),p=l-a,f,d=["x","y","z","w","u","v"];a===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(g=>`coords.${d[g+p]} = 0;`).join(`
`);let h="";return l<2&&a>0?h="coords":h=n.shapeInfo.logicalShape.map((g,m)=>`coords.${d[m+p]}`).join(", "),`
    float ${o}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${r}(${h});
    }
  `}function ke(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function hw(n,t,e){let{newShape:r,keptDims:o}=b.squeezeShape(t),s=t.length,i=n&&s===3&&t[0]===1,a=i?t.slice(1):r,l=!n&&s>1&&!b.arraysEqual(t,e)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:o}}function th(n,t){let e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function nh(n,t){return t.map(e=>n[e]).join(", ")}function HU(n,t,e,r){let o=e.map((c,p)=>{let f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:f}}),s=o.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=UU(o,i,t),l=CU(n.gl,a),u=n.createProgram(l);return L().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},y1(n,t,u)))}function y1(n,t,e){let r=[],o=[],s,i,a,l=null,u=null;u=n.getUniformLocation(e,"NAN",!1),L().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(e,"INFINITY",!1));let c=!1;for(let p of t.variableNames){let f={name:p,uniform:n.getUniformLocation(e,p,c),offset:n.getUniformLocation(e,`offset${p}`,c)};t.enableShapeUniforms&&(f.shape=n.getUniformLocation(e,`${p}Shape`,c),f.texShape=n.getUniformLocation(e,`${p}TexShape`,c)),r.push(f)}if(t.enableShapeUniforms&&(s=n.getUniformLocation(e,"outShape",c),a=n.getUniformLocation(e,"outShapeStrides",c),i=n.getUniformLocation(e,"outTexShape",c)),t.customUniforms)for(let p of t.customUniforms)o.push(n.getUniformLocation(e,p.name,c));return{variablesLocations:r,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function jU(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{let o=e.logicalShape,s=t[r],i=s.shape;if(!b.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function qU(n,t,e,r,o){t.program.enableShapeUniforms||(jU(t.inShapeInfos,e),jU([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):n.setOutputMatrixTexture(s.texture,i[0],i[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),L().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){let u=e[l],{uniform:c,offset:p,shape:f,texShape:d}=t.variablesLocations[l];if(f){let{uniformShape:h}=hw(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:n.gl.uniform1iv(f,new Int32Array(h));break;case 2:n.gl.uniform2iv(f,new Int32Array(h));break;case 3:n.gl.uniform3iv(f,new Int32Array(h));break;case 4:n.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&n.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(b.sizeFromShape(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),n.gl.uniform1fv(c,h)}continue}u.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let l=b.computeStrides(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&o)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],p=o[l];if(u.type==="float")n.gl.uniform1fv(c,p);else if(u.type==="vec2")n.gl.uniform2fv(c,p);else if(u.type==="vec3")n.gl.uniform3fv(c,p);else if(u.type==="vec4")n.gl.uniform4fv(c,p);else if(u.type==="int")n.gl.uniform1iv(c,p);else if(u.type==="ivec2")n.gl.uniform2iv(c,p);else if(u.type==="ivec3")n.gl.uniform3iv(c,p);else if(u.type==="ivec4")n.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function KU(n,t,e){let r="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:p}=hw(n.packedInputs,i.shape,l),f="",d="",h="";if(c.length===1&&n.packedInputs){let S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${S[0]>1}_${S[1]>1}`}else if(c.length===2&&!n.packedInputs)d=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){let S=b.computeStrides(c);h=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}let g=i.shape.length,m=c.length===2&&b.arraysEqual(i.shape,l),y=b.sizeFromShape(i.shape)===1,x=N.getBroadcastDims(i.shape,e.shape),v=!n.packedInputs&&g===e.shape.length&&b.arraysEqual(l,e.texData.texShape),w=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${v}_${u?p:""}_${c.length}_${y}_${x}_${m}_${f}_${d}_${h}_${w}_${a}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});let o=n.userCode,s=n.constructor.name;return s+="_"+r+"_"+o+`${L().getNumber("WEBGL_VERSION")}`,s}function ct(n){return L().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}var mw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ac.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Gt();this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oc(["r","c","d"],t):is(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var gw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ac.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Gt();this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oc(["r","c","d"],t):is(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var yw=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Jn.DOWNLOAD;let e=Gt();this.outputShape=t,this.userCode=`
      ${dw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var xw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Jn.DOWNLOAD;let e=Gt();this.outputShape=t,this.userCode=`
      ${dw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var wce={R:0,G:1,B:2,A:3},fg=class{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=Gt();this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${wce[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Zd():Yd(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var bw=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Gt();this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let l=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Zd():Yd(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};function XU(n){let t=Gt(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return wU(n,e)}function YU(n){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return TU(n,t)}function ZU(n){let t=new Uint16Array([0,1,2,2,1,3]);return NU(n,t)}function dg(n,t,e,r,o,s){DU(t,e);let i=EU(n),a=n.TEXTURE_2D;return fe(n,()=>n.bindTexture(a,i)),fe(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),fe(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),fe(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),fe(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),L().getNumber("WEBGL_VERSION")===1?fe(n,()=>n.texImage2D(a,0,r,t,e,0,o,s,null)):fe(n,()=>n.texStorage2D(a,1,r,t,e)),fe(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function x1(n){return n.internalFormatFloat}function QU(n,t,e,r){let[o,s]=Rc(t,e);return dg(n,o,s,x1(r),r.textureFormatFloat,n.FLOAT)}function b1(n){return n.internalFormatHalfFloat}function JU(n,t,e,r){let[o,s]=Rc(t,e);return dg(n,o,s,b1(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function v1(n){return n.downloadTextureFormat}function e4(n,t,e,r){let[o,s]=Rc(t,e);return dg(n,o,s,v1(r),n.RGBA,n.UNSIGNED_BYTE)}function w1(n){return n.internalFormatPackedFloat}function t4(n,t,e,r){let[o,s]=Bs(t,e);return dg(n,o,s,w1(r),n.RGBA,n.FLOAT)}function C1(n){return n.internalFormatPackedHalfFloat}function n4(n,t,e,r){let[o,s]=Bs(t,e);return dg(n,o,s,C1(r),n.RGBA,r.textureTypeHalfFloat)}function r4(n,t,e){return fe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),h1(n,t,"clipSpacePos",e,3,20,0)&&h1(n,t,"uv",e,2,20,12)}function o4(n,t,e,r,o,s){fe(n,()=>n.bindTexture(n.TEXTURE_2D,t));let i,a,l;o instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(e*r*4),a=n.FLOAT,l=s.internalFormatPackedFloat),i.set(o),L().getNumber("WEBGL_VERSION")===2?fe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,i)):fe(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,i)),fe(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function s4(n,t,e){fe(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?L().getNumber("WEBGL_VERSION")===2?fe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):fe(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):L().getNumber("WEBGL_VERSION")===2?fe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):fe(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),fe(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function i4(n,t,e,r){let o=n.createBuffer();fe(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return fe(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),fe(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),fe(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),o}function a4(n,t,e){let r=n,o=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function l4(n,t,e,r){let[o,s]=Rc(t,e),i=4,a=new Uint8Array(xU(t*e,i));return fe(n,()=>n.readPixels(0,0,o,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function u4(n,t,e,r,o,s,i,a){let l=n,u=new Float32Array(bU(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function c4(n,t,e){let r=new Float32Array(t*e*4);return fe(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}var rh=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=L().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,yU(e,t)):this.gl=Vr(e),t=this.gl,L().getNumber("WEBGL_VERSION")===2){let s=t;this.createVertexArray=()=>fe(s,()=>s.createVertexArray()),this.bindVertexArray=i=>fe(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>fe(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>fe(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){let s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>fe(t,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>fe(t,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>fe(t,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>fe(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),L().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ug(this.gl,s),oo(this.gl,i))this.textureHalfFloatExtension=ug(this.gl,i);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),oo(this.gl,o))this.colorBufferHalfFloatExtension=ug(this.gl,o);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",oo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(oo(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=YU(this.gl),this.indexBuffer=ZU(this.gl),this.framebuffer=kU(this.gl),this.textureConfig=lg(this.gl,this.textureHalfFloatExtension)}get debug(){return L().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;fe(t,()=>t.finish()),fe(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),fe(t,()=>t.deleteFramebuffer(this.framebuffer)),fe(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),fe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),fe(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),QU(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),JU(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),e4(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),s4(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,o){this.throwIfDisposed(),o4(this.gl,t,e,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),n4(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),t4(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(m1(this.gl,this.framebuffer),this.outputTexture=null),fe(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>l4(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,o,s,i){return u4(this.gl,t,e,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return a4(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);let o=i4(this.gl,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(L().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>c4(this.gl,e,r))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=XU(e));let r=IU(e);fe(e,()=>e.attachShader(r,this.vertexShader)),fe(e,()=>e.attachShader(r,t)),SU(e,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&cw(e,o),o}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);let e=this.gl;fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),r4(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(fe(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&cw(this.gl,this.program),fe(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?AU(this.gl,t,e):RU(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),fe(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),_U(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();let[o,s]=Bs(e,r);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,r,o){this.setOutputMatrixWriteRegionDriver(r,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&cw(this.gl,this.program),cg(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}fe(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),fe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ug(this.gl,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){return z(this,null,function*(){return yield b.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(t,e){if(e===0)return null;if(e===2){let r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=Ice(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in L().platform&&(r=L().platform.setTimeoutCustom.bind(L().platform)),b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),pw(this.gl,t,this.framebuffer),this.debug&&cg(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(pw(this.gl,this.outputTexture,this.framebuffer),this.debug&&cg(this.gl)):m1(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();let o=this.gl;pw(o,t,this.framebuffer),this.debug&&cg(o),this.outputTexture=t,fe(o,()=>o.viewport(0,0,e,r)),fe(o,()=>o.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,o){this.throwIfDisposed(),fe(this.gl,()=>this.gl.scissor(t,e,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Ice(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}var{addImpl:p4,bincountImpl:vw,bincountReduceImpl:f4,bitwiseAndImpl:d4,castImpl:h4,ceilImpl:m4,concatImpl:g4,equalImpl:y4,expImpl:x4,expm1Impl:b4,floorImpl:v4,gatherNdImpl:w4,gatherV2Impl:C4,greaterImpl:I4,greaterEqualImpl:S4,lessImpl:T4,lessEqualImpl:N4,linSpaceImpl:E4,logImpl:D4,maxImpl:k4,maximumImpl:A4,minimumImpl:R4,multiplyImpl:_4,negImpl:O4,notEqualImpl:M4,prodImpl:F4,raggedGatherImpl:$4,raggedRangeImpl:P4,raggedTensorToTensorImpl:L4,rangeImpl:B4,rsqrtImpl:z4,scatterImpl:V4,sigmoidImpl:U4,simpleAbsImpl:ww,sliceImpl:G4,sparseFillEmptyRowsImpl:W4,sparseReshapeImpl:j4,sparseSegmentReductionImpl:Cw,sqrtImpl:H4,staticRegexReplaceImpl:q4,stridedSliceImpl:K4,stringNGramsImpl:X4,stringSplitImpl:Y4,stringToHashBucketFastImpl:Z4,subImpl:Q4,tileImpl:J4,topKImpl:eG,transposeImpl:Fc,uniqueImpl:tG}=YE;function I1(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Qt(n,t){return t===1?[n]:I1(n,t)}function nG(n,t){if(n===1)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}var Iw=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ct(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=Qt("rc",this.rank),r=ke(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var oh=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Sce(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Zd():Yd(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}};function Sce(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?zU(["r","c","d"],"inputShape"):is(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}var Sw=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){let o=oG(e,r),s=sG(t,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=rG(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let a;return o===Wn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Wn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Wn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Wn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Wn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,r,o){if(this.freeTextures==null)return;let s=oG(r,o),i=sG(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=rG(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=L().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let u=this.usedTextures[i],c=u&&u.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Tce(n,t){let e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function rG(n,t,e,r,o){let s=Nce(t,r),i;if(o){let[l,u]=Bs(n[0],n[1]);i=l*u}else{let[l,u]=Rc(n[0],n[1]);i=l*u}let a=Tce(e,s);return i*a}function Nce(n,t){switch(n){case Wn.PACKED_2X2_FLOAT32:return w1(t);case Wn.PACKED_2X2_FLOAT16:return C1(t);case Wn.UNPACKED_FLOAT32:return x1(t);case Wn.UNPACKED_FLOAT16:return b1(t);case Wn.PACKED_4X1_UNSIGNED_BYTE:return v1(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function Ece(n){return L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Wn.PACKED_2X2_FLOAT32:Wn.UNPACKED_FLOAT32:n?Wn.PACKED_2X2_FLOAT16:Wn.UNPACKED_FLOAT16}function oG(n,t){if(n===Jn.UPLOAD)return Wn.PACKED_2X2_FLOAT32;if(n===Jn.RENDER||n==null)return Ece(t);if(n===Jn.DOWNLOAD||n===Jn.PIXELS)return Wn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function sG(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}var Mn=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},fn="if (isnan(x)) return x;",iG="return x;",S1="return abs(x);";var aG="return (x >= 0.0) ? x : (exp(x) - 1.0);",lG=fn+`
  return (x < 0.0) ? 0.0 : x;
`,uG=fn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Vs="return x;",cG="return 1.0 / (1.0 + exp(-1.0 * x));";var fG="return x;",dG=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hG=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mG=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gG="return 1.0 / (1.0 + exp(-1.0 * x));",Tr=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Tw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length);let e=t.length,r=Qt("rc",e),o=ke(e),s=nG(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var kce=Un.whereImpl,Ace=1e-7,Rce=1e-4,Nw={};function _ce(n){return n in Nw||(Nw[n]={}),Nw[n]}var Oce=L().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Mce=600;function Fce(){return L().global.screen==null?1024:L().global.screen.height*L().global.screen.width*window.devicePixelRatio*Mce/1024/1024}var yG=(()=>{class n extends Js{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!L().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(e!=null){if(e instanceof rh)r=e;else{let o=Vr(L().getNumber("WEBGL_VERSION"),e);r=new rh(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=Vr(L().getNumber("WEBGL_VERSION"));r=new rh(o),this.binaryCache=_ce(L().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Sw(this.gpgpu),this.numMBBeforeWarning=Fce(),this.texData=new Au(this,yo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,o,s,i,a){let l=this.makeTensorInfo(r,o),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[s,i]},u.texShape=[s,i];let c=pg(r),p=new fg(c,!1,a),f=this.runWebGLProgram(p,[l],o,[[s,i]]);return f.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),f.dataId}write(e,r,o){if((L().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||L().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:e,usage:Jn.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let r=this.texData.get(e);r.refCount++}decRef(e){if(this.texData.has(e)){let r=this.texData.get(e);r.refCount--}}move(e,r,o,s,i){if(L().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:s,values:r,usage:Jn.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let r=this.texData.get(e),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(a!=null){let d;u?d=new Tr(l,Vs):d=new Mn(l,Vs);let h=this.runWebGLProgram(d,[{dataId:e,shape:l,dtype:s}],s),g=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(o!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return o;let c=this.activeTimers!=null,p;c&&(p=b.now());let f;if(s==="complex64"){let d=this.readSync(i.real.dataId),h=this.readSync(i.imag.dataId);f=N.mergeRealAndImagArrays(d,h)}else f=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,f)}read(e){return z(this,null,function*(){if(this.pendingRead.has(e)){let g=this.pendingRead.get(e);return new Promise(m=>g.push(m))}let r=this.texData.get(e),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:l,isPacked:u}=r;if(i!=null){let g;u?g=new Tr(s,Vs):g=new Mn(s,Vs);let m=this.runWebGLProgram(g,[{dataId:e,shape:s,dtype:a}],a),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(o!=null)return this.convertAndCacheOnCPU(e);if(L().getBool("DEBUG")&&!L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&L().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,p;if(a!=="complex64"&&L().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let g=this.texData.get(p.dataId);c=this.gpgpu.createBufferFromTexture(g.texture.texture,...ag(s))}this.pendingRead.set(e,[]),a!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let f;if(a==="complex64"){let g=yield Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),m=g[0],y=g[1];f=N.mergeRealAndImagArrays(m,y)}else if(c==null)f=this.getValuesFromTexture(e);else{let g=b.sizeFromShape(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(c,g)}if(p!=null&&this.disposeIntermediateTensorInfo(p),c!=null){let g=this.gpgpu.gl;fe(g,()=>g.deleteBuffer(c))}let d=this.convertAndCacheOnCPU(e,f),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(g=>g(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&yo().removeDataId(e,this),this.pendingDeletes--),d})}readToGPU(e,r={}){let o=this.texData.get(e),{values:s,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=o;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;u?h=new Tr(i,Vs):h=new Mn(i,Vs);let g=this.runWebGLProgram(h,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,r.customTexShape),f=yo().makeTensorFromTensorInfo(p),d=this.texData.get(p.dataId);return Object.assign({tensorRef:f},d.texture)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return de(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return de(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let r=0;r<e.length;r++){let o=e[r];if(!vU(o))throw L().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:r,dtype:o,isPacked:s}=this.texData.get(e),i=b.sizeFromShape(r);if(L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),h=this.texData.get(d.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...ag(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),g}let a=L().getBool("WEBGL_PACK")&&s===!0,l=a?pg(r):r,u=a?new xw(l):new yw(l),c=this.runWebGLProgram(u,[{shape:l,dtype:o,dataId:e}],"float32"),p=this.texData.get(c.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),f}timerAvailable(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let i=b.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=b.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return z(this,null,function*(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=yield Promise.all(i);l.kernelMs=b.sum(u),l.getExtraProfileInfo=()=>u.map((c,p)=>({name:a[p],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}getQueryTime(e){return z(this,null,function*(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let r=e;return r.endMs-r.startMs})}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=Oce){return L().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&b.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){N.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=e.dataSync();return kce(e.shape,r)}packedUnaryOp(e,r,o){let s=new Tr(e.shape,r),i=this.compileAndRun(s,[e],o);return yo().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let s=ww(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(L().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,S1,e.dtype);let r=new Mn(e.shape,S1),o=this.compileAndRun(r,[e]);return yo().makeTensorFromTensorInfo(o)}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,o){return yo().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,o),this)}unpackTensor(e){let r=new Tw(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){let r=new Iw(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){let o=[Ql(e.shape),...Jl(e.shape)],s={dtype:e.dtype,shape:o,dataId:e.dataId},i=[Ql(r),...Jl(r)],a=new oh(i,o),l=!0,u=[o],c=this.runWebGLProgram(a,[s],e.dtype,u,l);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(e,r){let o=this.texData.get(e),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let d=b.sizeFromShape(i),h=r[0]*r[1]*4;b.assert(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let l=pg(i),u;s?u=new gw(l):u=new mw(l);let c=!0,p=[r??ag(l)],f=this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:e}],a,p,c,r);return{dtype:a,shape:i,dataId:f.dataId}}runWebGLProgram(e,r,o,s,i=!1,a){let l=this.makeTensorInfo(e.outputShape,o),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Ac.DENSE){let x=a??ag(e.outputShape);u.texShape=x.map(v=>v*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),b.sizeFromShape(l.shape)===0)return u.values=b.getTypedArrayFromDType(l.dtype,0),l;let c=[],p=r.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let v=this.texData.get(x.dataId);if(v.texture==null){if(!e.packedInputs&&b.sizeFromShape(x.shape)<=L().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:v.values};e.packedInputs&&(v.isPacked=!0,v.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!v.isPacked!=!!e.packedInputs)x=v.isPacked?this.unpackTensor(x):this.packTensor(x),c.push(x),v=this.texData.get(x.dataId);else if(v.isPacked&&!_c(v.shape,x.shape)){let w=x,S=x.shape;x.shape=v.shape,x=this.packedReshape(x,S),c.push(x),v=this.texData.get(x.dataId),w.shape=S}return{shape:x.shape,texData:v,isUniform:!1}});this.uploadToGPU(l.dataId);let f={shape:l.shape,texData:u,isUniform:!1},d=KU(e,p,f),h=this.getAndSaveBinary(d,()=>HU(this.gpgpu,e,p,f)),g=this.activeTimers!=null,m;g&&(m=this.startTimer()),L().get("ENGINE_COMPILE_ONLY")||qU(this.gpgpu,h,p,f,s),c.forEach(x=>this.disposeIntermediateTensorInfo(x)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));let y=L().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let x=b.now();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!L().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){let x=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),x}return l}compileAndRun(e,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(e,r,o,s,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(L().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!L().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=L().getBool("DEBUG");L().set("DEBUG",!1);let r=this.abs(se(1e-8)).dataSync()[0];if(L().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Ace:Rce}uploadToGPU(e){let r=this.texData.get(e),{shape:o,dtype:s,values:i,texture:a,usage:l,isPacked:u}=r;if(a!=null)return;let c=this.activeTimers!=null,p;c&&(p=b.now());let f=r.texShape;if(f==null&&(f=OU(o,u),r.texShape=f),i!=null){let d=pg(o),h,g=f[1],m=f[0],y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Bs(f[0],f[1])),u?h=new bw(d,y):h=new fg(d,y);let x=y?[m,g]:f,v=this.makeTensorInfo(x,s),w=this.texData.get(v.dataId);y?w.usage=Jn.PIXELS:w.usage=Jn.UPLOAD,w.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId),g,m,i);let S=[[m,g]],A=this.runWebGLProgram(h,[v],s,S,!0),_=this.texData.get(A.dataId);r.texShape=_.texShape,r.isPacked=_.isPacked,r.usage=_.usage,L().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(r.texture=_.texture,r.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo(v),c&&(this.uploadWaitMs+=b.now()-p)}else{let d=this.acquireTexture(f,l,s,u);r.texture=d}}convertAndCacheOnCPU(e,r){let o=this.texData.get(e),{dtype:s}=o;return r!=null&&(o.values=$ce(r,s)),o.values}acquireTexture(e,r,o,s){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*b.bytesPerElement(r)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){return z(this,null,function*(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(r));return Promise.all(e)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});e.push(o)}return Promise.all(e)}})}checkCompletionAsync_(e){return z(this,null,function*(){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(yield Rm(),this.checkCompletionAsync_(e))})}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(d1(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=y1(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=o,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,r,o){e.channels=e.channels||"RGBA";let{texture:s,height:i,width:a,channels:l}=e,u=yo().backend;if(!u.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=u.writeTexture(s,r,o,i,a,l);return yo().makeTensorFromDataId(c,r,o,u)}}return n.nextDataId=0,n})();function $ce(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}else throw new Error(`Unknown dtype ${t}`)}Sl.isBrowser()&&lx("webgl",()=>new yG,2);var sh=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Nr=class{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=N.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=ct(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Gr=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var Ur=class{constructor(t,e,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=N.assertAndGetBroadcastShape(e,r);let s=this.outputShape.length;this.enableShapeUniforms=ct(s);let i="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ke(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=Qt("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Jt(n){let{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var xG={kernelName:vs,backendName:"webgl",kernelFunc:Jt};function Er(n){let{inputs:t,backend:e}=n,{real:r,imag:o}=t,s=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(s.dataId),a=Jt({inputs:{x:r},backend:e}),l=Jt({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:l},s}var bG={kernelName:Up,backendName:"webgl",kernelFunc:Er};var T1="return (a < 0.) ? b * a : a;",N1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Pce(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{alpha:s}=r,i=e.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),a=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ur(N1,o.shape,i.shape):new Nr(T1,o.shape,i.shape),l=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),l}var vG={kernelName:Ka,backendName:"webgl",kernelFunc:Pce};var E1="return (a < 0.) ? b * a : a;",D1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Lce(n){let{inputs:t,backend:e}=n,{x:r,alpha:o}=t,s=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ur(D1,r.shape,o.shape):new Nr(E1,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],"float32")}var wG={kernelName:al,backendName:"webgl",kernelFunc:Lce};var Oo="if (isnan(x)) return x;";function me({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),f=e(p.values,l);return a.makeTensorInfo(i.shape,l,f)}let u=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new Tr(i.shape,t):c=new Mn(i.shape,n),a.runWebGLProgram(c,[i],l)}}function ot({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:l,b:u}=i,c=a;if(r&&l.dtype==="complex64"){let h=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[h.complexTensorInfos.real,g.complexTensorInfos.real],[h.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(v=>{let[w,S]=v,k={dataId:w.dataId,dtype:w.dtype,shape:l.shape},A={dataId:S.dataId,dtype:S.dtype,shape:u.shape},_=new Nr(n,l.shape,u.shape);return c.runWebGLProgram(_,[k,A],nn(w.dtype,S.dtype))}),x=Er({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),x}let p=s||nn(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&o!=null){let h=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m=l.dtype==="string"?N.fromUint8ToStringArray(h):h,y=l.dtype==="string"?N.fromUint8ToStringArray(g):g,[x,v]=o(l.shape,u.shape,m,y,p),w=c.makeTensorInfo(v,p),S=c.texData.get(w.dataId);return S.values=x,w}let f=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,d;return f?d=new Ur(t,l.shape,u.shape,e):d=new Nr(n,l.shape,u.shape),c.runWebGLProgram(d,[l,u],p)}}function da(n,t=!1){if(n==="linear")return t?fG:iG;if(n==="relu")return t?hG:lG;if(n==="elu")return t?dG:aG;if(n==="relu6")return t?mG:uG;if(n==="prelu")return t?D1:E1;if(n==="leakyrelu")return t?N1:T1;if(n==="sigmoid")return t?gG:cG;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}var ih=class{constructor(t,e,r,o=!1,s=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ct(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),f=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",h=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",y="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let v="rc.x",w="rc.x";t[0]<e[0]?v=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(w=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${w};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${g[0]});
          result += (${h[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}};var k1={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},hg=class{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=N.assertAndGetBroadcastShape(e,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var CG="return a * b;";function mg(n){let{inputs:t,backend:e}=n,{a:r,b:o}=t,s=N.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),u=new hg(k1.REAL,r.shape,o.shape),c=new hg(k1.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],f=e.runWebGLProgram(u,p,"float32"),d=e.runWebGLProgram(c,p,"float32"),h=Er({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}if(e.shouldExecuteOnCPU([r,o])){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),[u,c]=_4(r.shape,o.shape,a.values,l.values,s),p=e.makeTensorInfo(c,s),f=e.texData.get(p.dataId);return f.values=u,p}let i;return L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Ur(CG,r.shape,o.shape):i=new Nr(CG,r.shape,o.shape),e.runWebGLProgram(i,[r,o],s)}var IG={kernelName:Di,backendName:"webgl",kernelFunc:mg};function SG(n,t,e){let r=[Ql(n.shape),...Jl(n.shape)],o={dtype:n.dtype,shape:r,dataId:n.dataId},s=[Ql(t),...Jl(t)],i=new oh(s,r),a=!0,l=[r],u=e.runWebGLProgram(i,[o],n.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function ee(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{shape:s}=r,i=e,a=b.sizeFromShape(o.shape),l=b.inferFromImplicitShape(s,a),u=b.sizeFromShape(l);b.assert(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!_c(o.shape,l)&&!(c.texture!==null&&_c(c.shape,l))?SG(o,l,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}var TG={kernelName:ul,backendName:"webgl",kernelFunc:ee};var gg=class{constructor(t,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(r/4)*4,l=r%4,u="sumValue += dot(values, ones);";if(e!=null){let p=1/e;u=`sumValue += dot(values * ${b.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var Ew=class{constructor(t,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?u="sumValue":e==="prod"?u="prodValue":e==="all"?u="allValue":e==="any"&&(u="anyValue");let c=Math.floor(r/4)*4,p=r%4,f=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";e==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):e==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function zce(n){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:n[1],r=N.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}function Wr(n,t,e,r){let o=zce(n.shape),s=n;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:l,outSize:u}=o[i],c,p;e==="mean"?c=i===0?new gg({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new gg({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new Ew({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},e),p=s,s=r.runWebGLProgram(c,[s],t),p.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(p)}return s}var Dw=class{constructor(t,e){this.variableNames=["A"];let r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[e[i]];this.outputShape=r,this.rank=r.length;let o=ke(this.rank),s=Vce(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Vce(n){let t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let o=0;o<n.length;o++)r[n[o]]=e[o];return r.join()}var kw=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[e[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=ke(this.rank),s=I1("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function eu(n,t,e){let r=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kw(n.shape,t):new Dw(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function NG(n,t,e,r){let o=t,s=n.shape.length,i=b.parseAxisParam(o,n.shape),a=i,l=N.getAxesPermutation(a,s),u=l!=null,c=n;u&&(c=eu(n,l,r),a=N.getInnerMostAxes(a.length,s)),N.assertAxesAreInnerMostDims("sum",a,s);let[p,f]=N.computeOutAndReduceShapes(c.shape,a),d=p;e&&(d=N.expandShapeToKeepDim(p,i));let h=b.sizeFromShape(f),m=b.sizeFromShape(n.shape)/h,y=ee({inputs:{x:c},attrs:{shape:[m,h]},backend:r}),x=Qu(n.dtype),v=Wr(y,x,"sum",r),w=ee({inputs:{x:v},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),u&&r.disposeIntermediateTensorInfo(c),w}function $c(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r;return NG(o,s,i,e)}var EG={kernelName:ml,backendName:"webgl",kernelFunc:$c};function At(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{perm:s}=r,i=e,a=o.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=o.shape[s[c]];let u;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,f=Fc(p,o.shape,o.dtype,s,l);u=i.makeTensorInfo(l,o.dtype);let d=i.texData.get(u.dataId);d.values=f}else u=eu(o,s,i);return u}var DG={kernelName:Cs,backendName:"webgl",kernelFunc:At};var A1=1e3;function Pc({a:n,b:t,transposeA:e,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){let u=n.shape.length,c=t.shape.length,p=e?n.shape[u-2]:n.shape[u-1],f=r?t.shape[c-1]:t.shape[c-2],d=e?n.shape[u-1]:n.shape[u-2],h=r?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),m=t.shape.slice(0,-2),y=b.sizeFromShape(g),x=b.sizeFromShape(m),w=Or.assertAndGetBroadcastShape(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([d,h]);b.assert(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);let S=e?[y,p,d]:[y,d,p],k=r?[x,h,f]:[x,f,h],A=ee({inputs:{x:n},backend:o,attrs:{shape:S}}),_=ee({inputs:{x:t},backend:o,attrs:{shape:k}}),F=[A,_],$=Math.max(y,x),V=e?A.shape[1]:A.shape[2],U=s!=null,W=i!=null,G=l==="leakyrelu",H=l!=null?da(l,!0):null,K=U||W||G||H!=null,Q;if((d===1||h===1)&&V>A1&&K===!1){let J=A,re=_;e&&(J=At({inputs:{x:A},backend:o,attrs:{perm:[0,2,1]}}),F.push(J)),r&&(re=At({inputs:{x:_},backend:o,attrs:{perm:[0,2,1]}}),F.push(re));let oe=h!==1,le=h===1,ae=J;oe&&(ae=ee({inputs:{x:J},backend:o,attrs:{shape:[$,V,1]}}),F.push(ae));let pe=h===1?2:1,ue=re;le&&(ue=ee({inputs:{x:re},backend:o,attrs:{shape:[$,1,V]}}),F.push(ue));let he=mg({inputs:{a:ae,b:ue},backend:o});Q=$c({inputs:{x:he},backend:o,attrs:{axis:pe,keepDims:!0}}),F.push(he)}else{let J=nn(n.dtype,t.dtype),re=new ih(S,k,[$,d,h],e,r,U,H,W,G),oe=[A,_];if(s!=null&&oe.push(s),W&&oe.push(i),G){let le=o.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));oe.push(le),F.push(le)}Q=o.runWebGLProgram(re,oe,J)}let X=ee({inputs:{x:Q},backend:o,attrs:{shape:w}});F.push(Q);for(let J of F)o.disposeIntermediateTensorInfo(J);return X}function Uce(n){let{inputs:t,backend:e,attrs:r}=n,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r;return Pc({a:o,b:s,transposeA:l,transposeB:u,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var kG={kernelName:Wu,backendName:"webgl",kernelFunc:Uce};var AG="return abs(x);";function Gce(n){let{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=e.texData.get(r.dataId),i=ww(s.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let o;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Tr(r.shape,AG):o=new Mn(r.shape,AG),e.runWebGLProgram(o,[r],r.dtype)}var RG={kernelName:ka,backendName:"webgl",kernelFunc:Gce};var Wce=fn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,jce=me({opSnippet:Wce}),_G={kernelName:ti,backendName:"webgl",kernelFunc:jce};var Hce=fn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,qce=me({opSnippet:Hce}),OG={kernelName:ni,backendName:"webgl",kernelFunc:qce};var MG="return a + b;",Kce=ot({opSnippet:MG,packedOpSnippet:MG,supportsComplex:!0,cpuKernelImpl:p4}),FG={kernelName:Go,backendName:"webgl",kernelFunc:Kce};var Aw=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Rw=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function _w(n){let{inputs:t,backend:e}=n,r=t;if(r.length===1)return Jt({inputs:{x:r[0]},backend:e});if(r.length>L().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(r.length/2),u=_w({inputs:r.slice(0,l),backend:e}),c=_w({inputs:r.slice(l),backend:e});return _w({inputs:[u,c],backend:e})}let o=r.map(l=>l.dtype).reduce((l,u)=>nn(l,u)),s=r.map(l=>l.shape),a=L().getBool("WEBGL_PACK")?new Rw(r[0].shape,s):new Aw(r[0].shape,s);return e.runWebGLProgram(a,r,o)}var $G={kernelName:Aa,backendName:"webgl",kernelFunc:_w};function Xce(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,a)),N.assertAxesAreInnerMostDims("all",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Wr(g,g.dtype,"all",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var PG={kernelName:$p,backendName:"webgl",kernelFunc:Xce};function Yce(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,a)),N.assertAxesAreInnerMostDims("any",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Wr(g,g.dtype,"any",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var LG={kernelName:Pp,backendName:"webgl",kernelFunc:Yce};var Ow=class{constructor(t,e,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Mw=class{constructor(t,e,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,b.assert(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,l=a.length,u=ke(l),c=Qt("coords",l),p,f;if(i===1){f=l+1;let _=ke(f);p=`
        ${_} sourceLocR = ${_}(${c.join()}, 0);
        ++${c[l-1]};
        ${_} sourceLocG = ${_}(${c.join()}, 0);
        ++${c[l-2]};
        ${_} sourceLocA = ${_}(${c.join()}, 0);
        --${c[l-1]};
        ${_} sourceLocB = ${_}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,p=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;let d=["x","y","z","w","u","v"].slice(0,f),h="."+d[f-1],g=d.map(_=>"int "+_),m=Qt("sourceLocR",f-1).concat("inIdx.r"),y=Qt("sourceLocG",f-1).concat("inIdx.g"),x=Qt("sourceLocB",f-1).concat("inIdx.b"),v=Qt("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",S=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()})));`,k=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,A=o?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function BG(n,t,e,r=null){let o=t.shape[0],s=t.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=N.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},l=new Ow(a,e,r==null),u=[t];r!=null&&u.push(r);let c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let p=BG(n,t,e,c);return n.disposeIntermediateTensorInfo(c),p}function zG(n,t,e,r=null){let o=r!=null?r.shape:t.shape,s=o[o.length-1],i=N.computeOptimalWindowSize(s),a=new Mw(o,i,e,r==null),l=r==null?[t]:[t,r],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===t.shape.length){let c=zG(n,t,e,u);return n.disposeIntermediateTensorInfo(u),c}return u}function Fw(n,t,e,r){let o=[e];if(N.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,t.shape.length),!L().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=n.texData.get(t.dataId),a=i!==null&&i.isPacked,l=t;a&&(l=n.unpackTensor(t),s.push(l));let[u,c]=N.computeOutAndReduceShapes(l.shape,o),p=b.sizeFromShape(c),f=ee({inputs:{x:l},backend:n,attrs:{shape:[-1,p]}});s.push(f);let d=BG(n,f,r);s.push(d);let h=ee({inputs:{x:d},backend:n,attrs:{shape:u}});return s.forEach(g=>n.disposeIntermediateTensorInfo(g)),h}return zG(n,t,r)}function Zce(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=At({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Fw(e,l,i[0],"max");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var VG={kernelName:Ra,backendName:"webgl",kernelFunc:Zce};function Qce(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=N.getAxesPermutation(i,o.shape.length),l=o,u=[];a!=null&&(l=At({inputs:{x:o},backend:e,attrs:{perm:a}}),u.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Fw(e,l,i[0],"min");return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var UG={kernelName:_a,backendName:"webgl",kernelFunc:Qce};var Jce=fn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,epe=me({opSnippet:Jce}),GG={kernelName:ri,backendName:"webgl",kernelFunc:epe};var tpe=fn+"return log(x + sqrt(x * x + 1.0));",npe=me({opSnippet:tpe}),WG={kernelName:oi,backendName:"webgl",kernelFunc:npe};var rpe=fn+`
  return atan(x);
`,ope=me({opSnippet:rpe}),jG={kernelName:si,backendName:"webgl",kernelFunc:ope};var spe=sh+`
  return atan(a, b);
`,ipe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gr+`
  return result;
`,ape=ot({opSnippet:spe,packedOpSnippet:ipe}),HG={kernelName:ai,backendName:"webgl",kernelFunc:ape};var lpe=fn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,upe=me({opSnippet:lpe}),qG={kernelName:ii,backendName:"webgl",kernelFunc:upe};var as=class{constructor(t,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;let g=e==="avg",m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,x="0.0";if(g||(x="-1.0 / 1e-20"),r){let _=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${_} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?m:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / max(count, 1.0)");let S=Math.floor(i/4)*4,k=i%4,A=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${h});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${S};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${w});
      }
    `}},tu=class{constructor(t,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,f=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,g=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;let v=e==="avg",w="0.0";if(v||(w="-1.0 / 1e-20"),r){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${m}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${h} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let S="max",k=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(k="avgValue / max(count, 1.0)");let A=Math.floor(i/4)*4,_=i%4,F=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${m}, ${y}, ${x});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${A};
            if (${_===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${_===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${_===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${F}
            }
          }
        }
        setOutput(${k});
      }
    `}};function cpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t;zs(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return Jt({inputs:{x:o},backend:e});let p=new as(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var KG={kernelName:Oa,backendName:"webgl",kernelFunc:cpe};function ppe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],p=N.computePool3DInfo(o.shape,s,i,c,a,l,u),f=new tu(p,"avg",!1);return e.runWebGLProgram(f,[o],"float32")}var XG={kernelName:Ma,backendName:"webgl",kernelFunc:ppe};var $w=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,p=u-1-t.padInfo.left,f=1/(e*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Pw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,r=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=p-1-t.padInfo.front,g=f-1-t.padInfo.top,m=d-1-t.padInfo.left,y=1/(e*r*o);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${g}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function fpe(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],f=N.computePool3DInfo(i.shape,a,l,p,u,c),d=new Pw(f);return e.runWebGLProgram(d,[o],i.dtype)}var YG={kernelName:Bp,backendName:"webgl",kernelFunc:fpe};function dpe(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,i=s;zs([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:u}=r,c=N.computePool2DInfo(i.shape,a,l,1,u),p=new $w(c);return e.runWebGLProgram(p,[o],i.dtype)}var ZG={kernelName:Lp,backendName:"webgl",kernelFunc:dpe};function hpe(n){let{inputs:t,backend:e,attrs:r}=n,{a:o,b:s}=t,{transposeA:i,transposeB:a}=r;return Pc({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var QG={kernelName:Fa,backendName:"webgl",kernelFunc:hpe};var Lw=class{constructor(t,e,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(t,e),N.assertAndGetBroadcastShape(t,r);let a="0.0";o!=null&&(N.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(N.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Bw=class{constructor(t,e,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(t,e),N.assertAndGetBroadcastShape(t,r);let a="vec4(0.0)";o!=null&&(N.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(N.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var mpe=({inputs:n,backend:t,attrs:e})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=n;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);let u=[r,o,s],c=null;i!=null&&(c=i.shape,u.push(i));let p=null;a!=null&&(p=a.shape,u.push(a));let f=L().getBool("WEBGL_PACK_NORMALIZATION")?new Bw(r.shape,o.shape,s.shape,c,p,l):new Lw(r.shape,o.shape,s.shape,c,p,l);return t.runWebGLProgram(f,u,u[0].dtype)},JG={kernelName:Ha,backendName:"webgl",kernelFunc:mpe};var zw=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=ke(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=gpe(this.rank),o,s=t.map((i,a)=>`sourceLoc.${R1[a]} = start[${a}] + coords.${R1[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},R1=["x","y","z","w","u","v"];function gpe(n){if(n===1)return"sourceLoc";if(n<=6)return R1.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}var Vw=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=ke(this.rank),r=Qt("coords",this.rank),o=Qt("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}};function ype(n,t,e,r){let o=r.texData.get(n.dataId),s=r.makeTensorInfo(e,n.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=n.dtype;let a=Cn.computeFlatOffset(t,b.computeStrides(n.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||n.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function ls(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{begin:s,size:i}=r,[a,l]=Cn.parseSliceParams(o,s,i);if(Cn.assertParamsValid(o,a,l),b.sizeFromShape(l)===0)return e.makeTensorInfo(l,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),f=G4(p.values,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,f)}let{isPacked:u}=e.texData.get(o.dataId),c=Cn.isSliceContinous(o.shape,a,l);if(u||!c){let p=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vw(l):new zw(l),f=[a];return e.runWebGLProgram(p,[o],o.dtype,f)}return e.uploadToGPU(o.dataId),ype(o,a,l,e)}var eW={kernelName:hl,backendName:"webgl",kernelFunc:ls};var xpe=n=>{let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockShape:s,crops:i}=r;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,v)=>x*v),l=N.getReshaped(o.shape,s,a),u=N.getPermuted(l.length,s.length),c=N.getReshapedPermuted(o.shape,s,a),p=N.getSliceBeginCoords(i,s.length),f=N.getSliceSize(c,i,s.length),d=[],h=ee({inputs:{x:o},backend:e,attrs:{shape:l}}),g=At({inputs:{x:h},backend:e,attrs:{perm:u}}),m=ee({inputs:{x:g},backend:e,attrs:{shape:c}}),y=ls({inputs:{x:m},backend:e,attrs:{begin:p,size:f}});return d.push(h),d.push(g),d.push(m),d.forEach(x=>e.disposeIntermediateTensorInfo(x)),y},tW={kernelName:$a,backendName:"webgl",kernelFunc:xpe};function bpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,weights:s}=t,{size:i}=r,a=e.readSync(o.dataId),l=e.readSync(s.dataId),u=vw(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}var nW={kernelName:zp,backendName:"webgl",kernelFunc:bpe};var vpe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,wpe=`
  return float(int(a.r) & int(b.r));
`;function Cpe(n){let{inputs:t,backend:e}=n,{a:r,b:o}=t,s=L().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=L().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,o])||i===1){let l=e.texData.get(r.dataId).values,u=e.texData.get(o.dataId).values,[c,p]=d4(r.shape,o.shape,l,u,r.dtype),f=e.makeTensorInfo(p,r.dtype),d=e.texData.get(f.dataId);return d.values=c,f}let a;return s?a=new Ur(vpe,r.shape,o.shape,!1):a=new Nr(wpe,r.shape,o.shape),e.runWebGLProgram(a,[r,o],r.dtype)}var rW={kernelName:Mu,backendName:"webgl",kernelFunc:Cpe};function Ipe(n){let{inputs:t,backend:e}=n,{s0:r,s1:o}=t,s=e.readSync(r.dataId),i=e.readSync(o.dataId),a=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var oW={kernelName:Vp,backendName:"webgl",kernelFunc:Ipe};var Spe="return float(a != b);",_1=ot({opSnippet:Spe,cpuKernelImpl:M4,dtype:"bool"}),sW={kernelName:Uu,backendName:"webgl",kernelFunc:_1};function ha(n){let{inputs:t,backend:e}=n,{input:r}=t,o=e.texData.get(r.dataId);return Jt({inputs:{x:o.complexTensorInfos.real},backend:e})}var iW={kernelName:wf,backendName:"webgl",kernelFunc:ha};var Tpe="return float(int(x));";function aW(n,t){let e=new Mn(n.shape,Tpe),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function O1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Jt({inputs:{x:o},backend:e});let i=nt(o.shape),a=O1({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),l=Er({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if(o.dtype==="complex64"){let i=ha({inputs:{input:o},backend:e}),a=O1({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=Jt({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.texData.get(o.dataId).values,[a,l,u]=h4(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,u)}if(s==="int32")return aW(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),l=_1({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var lW={kernelName:bs,backendName:"webgl",kernelFunc:O1};var uW="return ceil(x);",Npe=me({opSnippet:uW,packedOpSnippet:uW,cpuKernelImpl:m4}),cW={kernelName:li,backendName:"webgl",kernelFunc:Npe};var Uw=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Gw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Epe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{clipValueMin:s,clipValueMax:i}=r,a;L().getBool("WEBGL_PACK_CLIP")?a=new Gw(o.shape):a=new Uw(o.shape);let l=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,l)}var pW={kernelName:ui,backendName:"webgl",kernelFunc:Epe};var Ww=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function fW(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function Dpe(n){let{inputs:t,backend:e}=n,{x:r}=t,o=e.texData.get(r.dataId),s=new Ww(r.shape),i=[fW(r,o.complexTensorInfos.real),fW(r,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var dW={kernelName:Pa,backendName:"webgl",kernelFunc:Dpe};var jw=class{constructor(t){this.outputShape=[],this.outputShape=N.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};var qw=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=N.computeOutShape(t,e);let r=this.outputShape,o=r.length,s=ke(o),i=Qt("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((g,m)=>`T${m}`);let l=new Array(t.length-1);l[0]=t[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][e];let u=a[e],c=a.slice(-2),p=a.join(),f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let g=1;g<l.length;g++){let m=l[g-1];f+=`
        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${Hw(a,u,m)}),
            vec2(${Hw(c,u,m)}));
        }`}let d=l.length,h=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${Hw(a,u,h)}),
          vec2(${Hw(c,u,h)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Hw(n,t,e){let r=n.indexOf(t);return n.map((s,i)=>i===r?`${s} - ${e}`:s).join()}function Lc(n){let{inputs:t,backend:e}=n,{input:r}=t,o=e.texData.get(r.dataId);return Jt({inputs:{x:o.complexTensorInfos.imag},backend:e})}var hW={kernelName:af,backendName:"webgl",kernelFunc:Lc};function ah(n,t,e){let r=n[0].dtype;if(r==="complex64"){let d=n.map(x=>ha({inputs:{input:x},backend:e})),h=n.map(x=>Lc({inputs:{input:x},backend:e})),g=ah(d,t,e),m=ah(h,t,e),y=Er({inputs:{real:g,imag:m},backend:e});return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),h.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let o=e.shouldExecuteOnCPU(n);if(r==="string"&&(o=!0),o){let d=n.map(w=>{let k=[-1,b.sizeFromShape(w.shape.slice(t))];return ee({inputs:{x:w},backend:e,attrs:{shape:k}})}),h=d.map(w=>({vals:e.readSync(w.dataId),shape:w.shape})),g=N.computeOutShape(d.map(w=>w.shape),1),m=d[0].shape[0]===1,y=g4(h,g,r,m),x=N.computeOutShape(n.map(w=>w.shape),t),v=e.makeTensorInfo(x,r,y);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),v}let s=n.filter(d=>b.sizeFromShape(d.shape)>0),i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let d=i?new Mn(n[0].shape,Vs):new Tr(n[0].shape,Vs);return e.runWebGLProgram(d,n,r)}let a=L().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let d=[];for(let g=0;g<s.length;g+=a){let m=s.slice(g,g+a);d.push(ah(m,t,e))}let h=ah(d,t,e);for(let g of d)e.disposeIntermediateTensorInfo(g);return h}if(i){let d=new qw(s.map(h=>h.shape),t);return e.runWebGLProgram(d,s,r)}let{tensors2D:l,outShape:u}=kpe(s,t,e),c=new jw(l.map(d=>d.shape)),p=e.runWebGLProgram(c,l,r);l.forEach(d=>e.disposeIntermediateTensorInfo(d));let f=ee({inputs:{x:p},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(p),f}function kpe(n,t,e){let r=N.computeOutShape(n.map(s=>s.shape),t);return{tensors2D:n.map(s=>ee({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:r}}function M1(n){let{inputs:t,backend:e,attrs:r}=n,{axis:o}=r,s=b.parseAxisParam(o,t[0].shape)[0],i=t.map(u=>u.shape);N.assertParamsConsistent(i,s);let a=N.computeOutShape(t.map(u=>u.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(u=>b.sizeFromShape(u.shape)>0);return l.length===1?Jt({inputs:{x:l[0]},backend:e}):ah(l,s,e)}var mW={kernelName:La,backendName:"webgl",kernelFunc:M1};var lh=class{constructor(t,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,f=t.filterHeight,d=t.filterWidth,h=Math.floor(t.inChannels/4)*4,g=t.inChannels%4,m=t.dataFormat==="channelsLast",y=m?1:2,x=m?2:3,v=m?3:1,w="",S="";r&&(o?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,S="result = activation(result);");let k=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${S}
        setOutput(result);
      }
    `}},Kw=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,r=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,f=t.filterHeight,d=t.filterWidth,h=Math.floor(t.inChannels/4)*4,g=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var uh=class{constructor(t,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ct(this.outputShape.length);let i=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,p=c,f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)f+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)f+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(p+1)/2;m++){let y=m*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let x=i%2===0?b.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",h="";r&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${h}
         setOutput(result);
       }
     `}};var Xw=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ct(this.outputShape.length);let{dataFormat:r}=e,o=Gt(),s=r==="channelsLast",i=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,u="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)u+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${o.output} = result;
      }
    `}};function Yw(n,t){let e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function Zw({x:n,filter:t,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let l=n.shape,u=r.texData.get(n.dataId),c=e.inChannels,p=l[0]*l[1]*l[2],f=e.outChannels,d=e.dataFormat==="channelsLast",h=!1,g=!1,m,y=[];if(s!=null){let w=Yw(s.shape,d);w!=null&&(s=ee({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(o!=null){let w=Yw(o.shape,d);w!=null&&(o=ee({inputs:{x:o},backend:r,attrs:{shape:w}}),y.push(o))}if(!((p===1||f===1)&&c>A1)&&u.isPacked&&d&&u.texture!=null&&l[2]%2!==0&&b.arraysEqual(u.shape.slice(-3),l.slice(-3))){let w=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,w,e.inChannels],dtype:n.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,b.assert(_c(u.shape,S.shape),()=>`packed reshape ${u.shape} to ${S.shape} isn't free`);let A=ee({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(A);let _=Pc({a:S,b:A,backend:r,transposeA:h,transposeB:g,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),F=r.texData.get(_.dataId);b.assert(F.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,F.shape=e.outShape,m=Jt({inputs:{x:_},backend:r}),m.shape=e.outShape,y.push(_)}else{let w=e.outHeight*e.outWidth,S=ee({inputs:{x:n},backend:r,attrs:{shape:d?[e.batchSize,w,e.inChannels]:[e.batchSize,e.inChannels,w]}}),k=ee({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),A=Pc({a:d?S:k,b:d?k:S,transposeA:!d,transposeB:g,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});m=ee({inputs:{x:A},backend:r,attrs:{shape:e.outShape}}),y.push(S),y.push(k),y.push(A)}for(let w of y)r.disposeIntermediateTensorInfo(w);return m}function Qw({x:n,filter:t,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:f,dataFormat:d}=e,h=d==="channelsLast",g=l*u*c,m=f*p,y=[e.batchSize,g,m],x=!0,v=!1,w=[];if(s!=null){let X=Yw(s.shape,h);X!=null&&(s=ee({inputs:{x:s},backend:r,attrs:{shape:X}}),w.push(s))}if(o!=null){let X=Yw(o.shape,h);X!=null&&(o=ee({inputs:{x:o},backend:r,attrs:{shape:X}}),w.push(o))}let S=ee({inputs:{x:t},backend:r,attrs:{shape:[1,g,b.sizeFromShape(t.shape)/g]}});w.push(S);let k=new Xw(y,e),A=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],_=r.runWebGLProgram(k,[n],"float32",A),F=ee({inputs:{x:_},backend:r,attrs:{shape:y}});w.push(_),w.push(F);let $=o!=null,V=s!=null,U=a==="leakyrelu",W=a?da(a,!0):null,G=new ih(h?F.shape:S.shape,h?S.shape:F.shape,h?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],x,v,$,W,V,U),H=h?[F,S]:[S,F];if(o&&H.push(o),V&&H.push(s),U){let X=r.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));H.push(X),w.push(X)}let K=r.runWebGLProgram(G,H,"float32"),Q=ee({inputs:{x:K},backend:r,attrs:{shape:e.outShape}});w.push(K);for(let X of w)r.disposeIntermediateTensorInfo(X);return Q}function Ape(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!1,p),d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=Zw({x:o,filter:s,convInfo:f,backend:e});else if(f.strideWidth<=2&&p==="channelsLast"&&L().getBool("WEBGL_EXP_CONV")){let g=new uh(f),m=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=e.runWebGLProgram(g,[o,s],"float32",m)}else if(L().getBool("WEBGL_CONV_IM2COL"))d=Qw({x:o,filter:s,convInfo:f,backend:e});else{let g=new lh(f);d=e.runWebGLProgram(g,[o,s],"float32")}let h=ee({inputs:{x:d},backend:e,attrs:{shape:f.outShape}});return e.disposeIntermediateTensorInfo(d),h}var gW={kernelName:Ba,backendName:"webgl",kernelFunc:Ape};var Jw=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,r=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},eC=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,l=r-1-t.padInfo.left,u=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},tC=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},nC=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,r=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,l=e-1-t.padInfo.front,u=r-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,p=N.convertConv2DDataFormat(l),f=N.computeConv2DInfo(o.shape,c,i,1,a,u,!1,p),d=new Jw(f);return e.runWebGLProgram(d,[o,s],"float32")}var yW={kernelName:Gp,backendName:"webgl",kernelFunc:Rpe};var rC=class{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=ct(this.outputShape.length);let e=t.filterHeight,r=t.filterWidth,o=e-1-t.padInfo.top,s=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function _pe(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,p=N.convertConv2DDataFormat(u),f=N.computeConv2DInfo(i,s.shape,a,1,l,c,!1,p);if(L().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let d=[[f.strideHeight,f.strideWidth]],h=new rC(f);return e.runWebGLProgram(h,[o,s],"float32",d)}else{let d=new eC(f);return e.runWebGLProgram(d,[o,s],"float32")}}var xW={kernelName:za,backendName:"webgl",kernelFunc:_pe};function Ope(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=r,u=N.computeConv3DInfo(o.shape,s.shape,i,l,a),c=new Kw(u);return e.runWebGLProgram(c,[o,s],"float32")}var bW={kernelName:Va,backendName:"webgl",kernelFunc:Ope};function Mpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:l}=r,u=N.computeConv3DInfo(o.shape,l,i,1,a),c=new tC(u);return e.runWebGLProgram(c,[o,s],"float32")}var vW={kernelName:Wp,backendName:"webgl",kernelFunc:Mpe};function Fpe(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:l}=r,u=N.computeConv3DInfo(l,s.shape,a,1,i),c=new nC(u);return e.runWebGLProgram(c,[o,s],"float32")}var wW={kernelName:jp,backendName:"webgl",kernelFunc:Fpe};var $pe=Oo+`
  return cos(x);
`,Ppe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Gr}
  return result;
`,Lpe=me({opSnippet:$pe,packedOpSnippet:Ppe}),CW={kernelName:ci,backendName:"webgl",kernelFunc:Lpe};var Bpe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,zpe=me({opSnippet:Bpe}),IW={kernelName:pi,backendName:"webgl",kernelFunc:zpe};var oC=class{constructor(t,e,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,l,u]=t,[c]=e,[p,f]=r;this.outputShape=[c,p,f,u];let d=o==="bilinear"?1:0,[h,g]=[`${a-1}.0`,`${l-1}.0`],[m,y,x]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[v,w,S]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Vpe=n=>{let{inputs:t,backend:e,attrs:r}=n,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:l,extrapolationValue:u}=r,c=new oC(o.shape,s.shape,a,l,u);return e.runWebGLProgram(c,[o,s,i],"float32")},SW={kernelName:qp,backendName:"webgl",kernelFunc:Vpe};var ch=function(n){return n.Prod="*",n.Sum="+",n}(ch||{}),yg=class{constructor(t,e,r,o){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===ch.Prod?"1.0":"0.0",a=r?i:`getX(${TW(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1],u="",c="";r?(u=o?`end != ${l-1}`:"end != 0",c=o?"end + 1":"end - 1"):(u=o?`end + pow2 < ${l}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ke(s)} coords = getOutputCoords();
        int end = ${NW(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${NW(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${TW(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function TW(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function NW(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function sC(n,t,e,r,o,s){let i=t.shape.length,a=N.getAxesPermutation([r],i),l=t;a!=null&&(l=At({inputs:{x:t},backend:e,attrs:{perm:a}}));let u=N.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],p=Jt({inputs:{x:l},backend:e});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){let d=new yg(n,l.shape,!1,s),h=[[f]],g=p;p=e.runWebGLProgram(d,[p],p.dtype,h),e.disposeIntermediateTensorInfo(g)}if(o){let f=new yg(n,l.shape,o,s),d=p;p=e.runWebGLProgram(f,[p],p.dtype),e.disposeIntermediateTensorInfo(d)}if(a!=null){let f=N.getUndoAxesPermutation(a),d=At({inputs:{x:p},backend:e,attrs:{perm:f}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),d}return p}function Upe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,exclusive:i,reverse:a}=r;return sC(ch.Prod,o,e,s,i,a)}var EW={kernelName:Hp,backendName:"webgl",kernelFunc:Upe};function Gpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,exclusive:i,reverse:a}=r;return sC(ch.Sum,o,e,s,i,a)}var DW={kernelName:Ua,backendName:"webgl",kernelFunc:Gpe};function Wpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,weights:s}=t,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.readSync(o.dataId),u=e.readSync(s.dataId),c=vw(l,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let l=e.bufferSync(o),u=e.bufferSync(s),c=f4(l,u,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var kW={kernelName:Kp,backendName:"webgl",kernelFunc:Wpe};var iC=class{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function jpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockSize:s,dataFormat:i}=r,a=o.shape[0],l=i==="NHWC"?o.shape[1]:o.shape[2],u=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=l*s,f=u*s,d=c/(s*s),h=i==="NHWC"?[a,p,f,d]:[a,d,p,f],g=new iC(h,s,i);return e.runWebGLProgram(g,[o],o.dtype)}var AW={kernelName:Xp,backendName:"webgl",kernelFunc:jpe};var ph=class{constructor(t,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ct(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels,u="",c="";r&&(o?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var fh=class{constructor(t,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ct(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,f=p,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){let x=y*2;if(d+=`
          xC = xCCorner + ${x*u};
          `,l===1){if(x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,u===1&&x>0?d+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<p)){let v=a%2===0?b.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${v};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,u>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:d+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):v===1?d+=`
                    xC${x+1} = xTexelC${x};
                    `:d+=`
                    xCOffset = xC + ${v};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<p&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<p&&(d+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<p&&(d+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<p&&(d+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let h="",g="";r&&(o?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:h=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");let m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}};function Hpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=N.computeConv2DInfo(o.shape,s.shape,i,c,a,u,!0),f;L().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?f=new fh(p):f=new ph(p);let d=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(f,[o,s],"float32",d)}var RW={kernelName:Ga,backendName:"webgl",kernelFunc:Hpe};var aC=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,r=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},lC=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=r-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function qpe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,dy:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,p=N.computeConv2DInfo(o.shape,c,i,a,l,u,!0),f=new aC(p);return e.runWebGLProgram(f,[o,s],"float32")}var _W={kernelName:Yp,backendName:"webgl",kernelFunc:qpe};function Kpe(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,p=N.computeConv2DInfo(c,s.shape,i,a,l,u,!0),f=new lC(p);return e.runWebGLProgram(f,[o,s],"float32")}var OW={kernelName:Zp,backendName:"webgl",kernelFunc:Kpe};var uC=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Xpe(n){let{inputs:t,backend:e}=n,{x:r}=t,o=[...r.shape,...r.shape],s=b.sizeFromShape(r.shape),i=ee({inputs:{x:r},backend:e,attrs:{shape:[s]}}),a=new uC(s),l=e.runWebGLProgram(a,[i],i.dtype),u=ee({inputs:{x:l},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}var MW={kernelName:Qp,backendName:"webgl",kernelFunc:Xpe};var cC=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:p,left:f}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Ype(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s}=t,{strides:i,pad:a,dilations:l}=r,u=N.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",l),c,p=new cC(u);c=e.runWebGLProgram(p,[o,s],"float32");let f=ee({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),f}var FW={kernelName:Wa,backendName:"webgl",kernelFunc:Ype};function Zpe(n){let{inputs:t,backend:e,attrs:r}=n,{equation:o}=r,s=t,{allDims:i,summedDims:a,idDims:l}=N.decodeEinsumEquation(o,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=N.getEinsumComputePath(a,l),p=c.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of c[g]){let{permutationIndices:y,expandDims:x}=N.getEinsumPermutation(d,l[m]),v;N.isIdentityPermutation(y)?v=s[m]:(v=At({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(v));let w=v.shape.slice();for(let S=0;S<x.length;++S)w.splice(x[S],0,1);b.arraysEqual(v.shape,w)||(v=ee({inputs:{x:v},backend:e,attrs:{shape:w}}),h.push(v)),f===null?f=v:(f=mg({inputs:{a:v,b:f},backend:e}),h.push(f))}g<p-1&&(u[g]>=0&&(f=$c({inputs:{x:f},backend:e,attrs:{axis:u[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var $W={kernelName:Jp,backendName:"webgl",kernelFunc:Zpe};var Qpe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Jpe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,efe=me({opSnippet:Qpe,packedOpSnippet:Jpe}),PW={kernelName:di,backendName:"webgl",kernelFunc:efe};var tfe="return (b >= 0.0) ? a : a * (b + 1.0);",nfe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,rfe=n=>{let{inputs:t,backend:e}=n,{dy:r,y:o}=t,s=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ur(nfe,r.shape,o.shape):new Nr(tfe,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],r.dtype)},LW={kernelName:ef,backendName:"webgl",kernelFunc:rfe};var ofe=`
  return vec4(equal(a, b));
`,sfe="return float(a == b);",ife=ot({opSnippet:sfe,packedOpSnippet:ofe,dtype:"bool",cpuKernelImpl:y4}),BW={kernelName:Fu,backendName:"webgl",kernelFunc:ife};var afe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${N.ERF_P};
  float a1 = ${N.ERF_A1};
  float a2 = ${N.ERF_A2};
  float a3 = ${N.ERF_A3};
  float a4 = ${N.ERF_A4};
  float a5 = ${N.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,lfe=me({opSnippet:afe}),zW={kernelName:hi,backendName:"webgl",kernelFunc:lfe};var ufe=Oo+`
  return exp(x);
`,cfe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,F1=me({opSnippet:ufe,packedOpSnippet:cfe,cpuKernelImpl:x4,dtype:"float32"}),VW={kernelName:mi,backendName:"webgl",kernelFunc:F1};function pC(n){let{inputs:t,attrs:e,backend:r}=n,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),l=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),ee({inputs:{x:s},backend:r,attrs:{shape:a}})}var UW={kernelName:ja,backendName:"webgl",kernelFunc:pC};var GW="return exp(x) - 1.0;",pfe=me({opSnippet:GW,packedOpSnippet:GW,cpuKernelImpl:b4}),WW={kernelName:gi,backendName:"webgl",kernelFunc:pfe};var xg=class{constructor(t,e,r){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function fC(n,t,e){let r=e.texData.get(n.dataId),o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ee({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),l=a.shape,u=new xg("real",l,t),c=new xg("imag",l,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=e.runWebGLProgram(u,p,"float32"),d=e.runWebGLProgram(c,p,"float32"),h=Er({inputs:{real:f,imag:d},backend:e});e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d);let g=ee({inputs:{x:h},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(h),g}function ffe(n){let{inputs:t,backend:e}=n,{input:r}=t;return fC(r,!1,e)}var jW={kernelName:tf,backendName:"webgl",kernelFunc:ffe};var dC=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function ma(n){let{backend:t,attrs:e}=n,{shape:r,value:o}=e,{dtype:s}=e;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(r));return i.fill(o),t.makeTensorInfo(r,s,i)}else{let i=new dC(r,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var HW={kernelName:nf,backendName:"webgl",kernelFunc:ma};var hC=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var qW={kernelName:rf,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{let{image:e}=n,r=t,o=new hC(e.shape);return r.runWebGLProgram(o,[e],e.dtype)}};var KW="return floor(x);",dfe=me({opSnippet:KW,packedOpSnippet:KW,cpuKernelImpl:v4}),XW={kernelName:yi,backendName:"webgl",kernelFunc:dfe};var hfe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,mfe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,gfe=ot({opSnippet:hfe,packedOpSnippet:mfe,dtype:"int32"}),YW={kernelName:xi,backendName:"webgl",kernelFunc:gfe};var mC=class{constructor(t){this.variableNames=["A"];let e=Gt(),[r,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var gC=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=Gt(),[r,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var ZW={kernelName:L_,backendName:"webgl",kernelFunc:yfe},dh,$1=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function yfe(n){let{inputs:t,backend:e,attrs:r}=n,{pixels:o}=t,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[l,u]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[u,l],p=[u,l,s];if(a||i){let g=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(dh==null||g!==$1)&&($1=g,dh=document.createElement("canvas").getContext("2d",{willReadFrequently:$1})),dh.canvas.width=l,dh.canvas.height=u,dh.drawImage(o,0,0,l,u),o=dh.canvas}let f=e.makeTensorInfo(c,"int32");e.texData.get(f.dataId).usage=Jn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId),o);let d=L().getBool("WEBGL_PACK")?new gC(p):new mC(p),h=e.runWebGLProgram(d,[f],"int32");return e.disposeData(f.dataId),h}function xfe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=N.convertConv2DDataFormat(c),m=N.computeConv2DInfo(o.shape,s.shape,l,p,u,f,!1,g),y,x=[],v=i!=null,w=a!=null,S=d==="leakyrelu",k=()=>{let _=[o,s],F=($,V)=>{if(V==="NCHW"&&$.shape.length===1&&$.shape[0]!==1){let U=ee({inputs:{x:$},backend:e,attrs:{shape:[$.shape[0],1,1]}});return x.push(U),U}return $};if(v&&_.push(F(i,c)),w&&_.push(F(a,c)),S){let $=e.makeTensorInfo([],"float32",b.createScalarValue(h,"float32"));_.push($),x.push($)}return _};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=Zw({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else if(m.strideWidth<=2&&g==="channelsLast"&&L().getBool("WEBGL_EXP_CONV")){let _=d?da(d,!0):null,F=new uh(m,v,_,w,S),$=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],V=k();y=e.runWebGLProgram(F,V,"float32",$)}else if(L().getBool("WEBGL_CONV_IM2COL"))y=Qw({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else{let _=d?da(d,!1):null,F=new lh(m,v,_,w,S),$=k();y=e.runWebGLProgram(F,$,"float32")}let A=ee({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return x.push(y),x.forEach(_=>e.disposeIntermediateTensorInfo(_)),A}var QW={kernelName:ju,backendName:"webgl",kernelFunc:xfe};function bfe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:d}=r,h=[],g=c;g==null&&(g=[1,1]),b.assert(N.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let m=N.computeConv2DInfo(o.shape,s.shape,l,g,u,p,!0),y=L().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=f?da(f,y):null,v=[o,s],w=i!=null,S=a!=null,k=f==="leakyrelu";if(w&&v.push(i),S&&v.push(a),k){let $=e.makeTensorInfo([],"float32",b.createScalarValue(d,"float32"));v.push($),h.push($)}let A;y?A=new fh(m,w,x,S,k):A=new ph(m,w,x,S,k);let _=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],F=e.runWebGLProgram(A,v,"float32",_);return h.forEach($=>e.disposeIntermediateTensorInfo($)),F}var JW={kernelName:Hu,backendName:"webgl",kernelFunc:bfe};var yC=class{constructor(t,e,r,o){this.sliceDim=t,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=ke(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function vfe(n){let{inputs:t,backend:e}=n,{params:r,indices:o}=t,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(r.shape),[l,u,c,p]=N.prepareAndValidate(r,o),f=ee({inputs:{x:o},backend:e,attrs:{shape:[u,i]}}),d=ee({inputs:{x:r},backend:e,attrs:{shape:[b.sizeFromShape(r.shape)/c,c]}});if(e.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let y=e.readSync(o.dataId),x=e.bufferSync(r),v=w4(y,x,r.dtype,u,i,c,p,r.shape,a);return e.makeTensorInfo(l,r.dtype,v.values)}let h=new yC(i,p,[u,c],r.shape),g=e.runWebGLProgram(h,[d,f],d.dtype),m=ee({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),m}var ej={kernelName:of,backendName:"webgl",kernelFunc:vfe};var xC=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let r=ke(this.rank),o=wfe(t,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function wfe(n,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<n.length;o++)o===2?r.push("index"):r.push(`${e[o]}`);return r.join()}function P1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,indices:s}=t,{axis:i,batchDims:a}=r,l=b.parseAxisParam(i,o.shape)[0];if(L().get("DEBUG")){let x=e.readSync(s.dataId),v=o.shape[l];for(let w=0;w<x.length;++w){let S=x[w];b.assert(S<=v-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${v-1}]`)}}let u=N.segment_util.collectGatherOpShapeInfo(o,s,l,a),c=b.sizeFromShape(s.shape),p=[],f=ee({inputs:{x:o},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=ee({inputs:{x:s},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(f),p.push(d);let h=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let x=e.bufferSync(d),v=e.bufferSync(f),w=C4(v,x,h);return p.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(u.outputShape,w.dtype,w.values)}let g=new xC(f.shape,h),m=e.runWebGLProgram(g,[f,d],f.dtype);p.push(m);let y=ee({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}var tj={kernelName:qa,backendName:"webgl",kernelFunc:P1};var Cfe="return float(a > b);",Ife=`
  return vec4(greaterThan(a, b));
`,Sfe=ot({opSnippet:Cfe,packedOpSnippet:Ife,cpuKernelImpl:I4,dtype:"bool"}),nj={kernelName:$u,backendName:"webgl",kernelFunc:Sfe};var Tfe="return float(a >= b);",Nfe=`
  return vec4(greaterThanEqual(a, b));
`,Efe=ot({opSnippet:Tfe,packedOpSnippet:Nfe,dtype:"bool",cpuKernelImpl:S4}),rj={kernelName:bi,backendName:"webgl",kernelFunc:Efe};function Dfe(n){let{inputs:t,backend:e}=n,{input:r}=t;return fC(r,!0,e)}var oj={kernelName:sf,backendName:"webgl",kernelFunc:Dfe};var kfe="return float(!isnan(x) && !isinf(x));",Afe=me({opSnippet:kfe,dtype:"bool"}),sj={kernelName:vi,backendName:"webgl",kernelFunc:Afe};var Rfe="return float(isinf(x));",_fe=me({opSnippet:Rfe,dtype:"bool"}),ij={kernelName:wi,backendName:"webgl",kernelFunc:_fe};var Ofe="return float(isnan(x));",Mfe=me({opSnippet:Ofe,dtype:"bool"}),aj={kernelName:Ci,backendName:"webgl",kernelFunc:Mfe};var Ffe="return float(a < b);",$fe=`
  return vec4(lessThan(a, b));
`,Pfe=ot({opSnippet:Ffe,packedOpSnippet:$fe,cpuKernelImpl:T4,dtype:"bool"}),lj={kernelName:Pu,backendName:"webgl",kernelFunc:Pfe};var Lfe="return float(a <= b);",Bfe=`
  return vec4(lessThanEqual(a, b));
`,zfe=ot({opSnippet:Lfe,packedOpSnippet:Bfe,cpuKernelImpl:N4,dtype:"bool"}),uj={kernelName:Lu,backendName:"webgl",kernelFunc:zfe};function Vfe(n){let{backend:t,attrs:e}=n,{start:r,stop:o,num:s}=e,i=E4(r,o,s);return t.makeTensorInfo([i.length],"float32",i)}var cj={kernelName:lf,backendName:"webgl",kernelFunc:Vfe};var Ufe=Oo+`
  return x < 0.0 ? 0./0. : log(x);
`,Gfe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Wfe=me({opSnippet:Ufe,packedOpSnippet:Gfe,cpuKernelImpl:D4}),pj={kernelName:Ii,backendName:"webgl",kernelFunc:Wfe};var jfe=Oo+`
  return log(1.0 + x);
`,Hfe=me({opSnippet:jfe}),fj={kernelName:Si,backendName:"webgl",kernelFunc:Hfe};var qfe="return float(a >= 1.0 && b >= 1.0);",Kfe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Xfe=ot({opSnippet:qfe,packedOpSnippet:Kfe,dtype:"bool"}),dj={kernelName:Bu,backendName:"webgl",kernelFunc:Xfe};var Yfe="return float(!(x >= 1.0));",Zfe=me({opSnippet:Yfe}),hj={kernelName:zu,backendName:"webgl",kernelFunc:Zfe};var Qfe="return float(a >= 1.0 || b >= 1.0);",Jfe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ede=ot({opSnippet:Qfe,packedOpSnippet:Jfe,dtype:"bool"}),mj={kernelName:Vu,backendName:"webgl",kernelFunc:ede};var bC=class{constructor(t,e,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let l,u=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var vC=class{constructor(t,e,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let l,u=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${u})`:s===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var tde=n=>{let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:l}=r,u=L().getBool("WEBGL_PACK_NORMALIZATION")?new vC(o.shape,s,i,a,l):new bC(o.shape,s,i,a,l);return e.runWebGLProgram(u,[o],o.dtype)},gj={kernelName:Xa,backendName:"webgl",kernelFunc:tde};var wC=class{constructor(t,e,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var nde=n=>{let{inputs:t,backend:e,attrs:r}=n,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:l,alpha:u,beta:c}=r,p=new wC(o.shape,a,l,u,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},yj={kernelName:uf,backendName:"webgl",kernelFunc:nde};function xj(n,t,e,r){let o=b.sizeFromShape(t),i=b.sizeFromShape(n.shape)/o,a=ee({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),l=Wr(a,n.dtype,"max",r),u=ee({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}function L1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=c!=null,f=e.shouldExecuteOnCPU([o]),d=o;if(p){if(f){let v=e.texData.get(d.dataId).values,w=new Array(a);for(let A=0;A<w.length;A++)w[A]=o.shape[c[A]];let S=Fc(v,o.shape,o.dtype,c,w);d=e.makeTensorInfo(w,o.dtype);let k=e.texData.get(d.dataId);k.values=S}else d=eu(o,c,e);u=N.getInnerMostAxes(u.length,a)}N.assertAxesAreInnerMostDims("max",u,a);let[h,g]=N.computeOutAndReduceShapes(d.shape,u),m=h;i&&(m=N.expandShapeToKeepDim(h,l));let y;if(f){let v=e.texData.get(d.dataId).values,w=k4(v,b.sizeFromShape(g),m,o.dtype);y=e.makeTensorInfo(m,o.dtype);let S=e.texData.get(y.dataId);S.values=w}else y=xj(d,g,m,e);return p&&e.disposeIntermediateTensorInfo(d),y}var bj={kernelName:Ya,backendName:"webgl",kernelFunc:L1};var rde=sh+`
  return max(a, b);
`,ode=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gr+`
  return result;
`,sde=ot({opSnippet:rde,packedOpSnippet:ode,cpuKernelImpl:A4}),vj={kernelName:Ti,backendName:"webgl",kernelFunc:sde};function ide(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t;zs(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,u=1;b.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=N.computePool2DInfo(o.shape,s,i,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&b.arraysEqual(c.inShape,c.outShape))return Jt({inputs:{x:o},backend:e});let p=new as(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var wj={kernelName:Za,backendName:"webgl",kernelFunc:ide};function ade(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],p=N.computePool3DInfo(o.shape,s,i,c,a,u,l),f=new tu(p,"max",!1);return e.runWebGLProgram(f,[o],o.dtype)}var Cj={kernelName:Qa,backendName:"webgl",kernelFunc:ade};var CC=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,r=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,l=i-1-t.padInfo.left,u=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},IC=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,r=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=l-1-t.padInfo.front,f=u-1-t.padInfo.top,d=c-1-t.padInfo.left,h=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function lde(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s}=t,i=s,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],f=N.computePool3DInfo(i.shape,a,l,p,u,c),d=new tu(f,"max",!0),h=e.runWebGLProgram(d,[i],i.dtype),g=new IC(f),m=e.runWebGLProgram(g,[o,h],i.dtype);return e.disposeIntermediateTensorInfo(h),m}var Ij={kernelName:pf,backendName:"webgl",kernelFunc:lde};function ude(n){let{inputs:t,backend:e,attrs:r}=n,{dy:o,input:s,output:i}=t,a=s;zs([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,f=N.computePool2DInfo(a.shape,l,u,1,c,p),d=!0,h=new as(f,"max",d),g=e.runWebGLProgram(h,[a],a.dtype),m=new CC(f),y=e.runWebGLProgram(m,[o,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}var Sj={kernelName:cf,backendName:"webgl",kernelFunc:ude};function Tj(n,t,e,r){let o=new as(e,"max",!1),s=r.runWebGLProgram(o,[n],"float32");o=new as(e,"max",!0,!0,t);let i=r.runWebGLProgram(o,[n],"float32");return[s,i]}var Nj={kernelName:ff,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,l=e;b.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];b.assert(N.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=N.computePool2DInfo(r.shape,o,s,u,i),[p,f]=Tj(r,a,c,l);return[p,f]}};function Ej(n,t,e,r){let o=b.sizeFromShape(t),i=b.sizeFromShape(n.shape)/o,a=ee({inputs:{x:n},attrs:{shape:[i,o]},backend:r}),l=Wr(a,"float32","mean",r),u=ee({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}var Dj={kernelName:Ja,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{keepDims:o,axis:s}=t,i=e,a=r.shape.length,l=b.parseAxisParam(s,r.shape),u=l,c=N.getAxesPermutation(u,a),p=c!=null,f=i.shouldExecuteOnCPU([r]),d=[],h=r;if(p){if(f){let w=i.texData.get(h.dataId).values,S=new Array(a);for(let _=0;_<S.length;_++)S[_]=r.shape[c[_]];let k=Fc(w,r.shape,r.dtype,c,S);h=i.makeTensorInfo(S,r.dtype);let A=i.texData.get(h.dataId);A.values=k}else h=eu(r,c,i);d.push(h),u=N.getInnerMostAxes(u.length,a)}N.assertAxesAreInnerMostDims("sum",u,a);let[g,m]=N.computeOutAndReduceShapes(h.shape,u),y=g;o&&(y=N.expandShapeToKeepDim(g,l));let x=Ej(h,m,y,i);for(let v of d)i.disposeIntermediateTensorInfo(v);return x}};function cde(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),u=l,c=N.getAxesPermutation(u,a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),u=N.getInnerMostAxes(u.length,o.shape.length)),N.assertAxesAreInnerMostDims("min",u,a);let[f,d]=N.computeOutAndReduceShapes(p.shape,u),h=b.sizeFromShape(d),g=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=Wr(g,g.dtype,"min",e),y;if(i){let x=N.expandShapeToKeepDim(f,l);y=ee({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=ee({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),c!=null&&e.disposeIntermediateTensorInfo(p),y}var kj={kernelName:el,backendName:"webgl",kernelFunc:cde};var pde=sh+`
  return min(a, b);
`,fde=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Gr+`
  return result;
`,dde=ot({opSnippet:pde,packedOpSnippet:fde,cpuKernelImpl:R4}),Aj={kernelName:Ni,backendName:"webgl",kernelFunc:dde};var SC=class{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=ke(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),u=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var TC=class{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=ke(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+t[g]).join(","),l=Qt("rc",o),u=Qt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=r==="reflect"?0:1,d="";if(o===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${u.join()}), ${p});
        ${l[o-1]} += 1;
        if(${c}) {
          ${h}
          result[1] = getChannel(getX(${u.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${h}
          result[2] = getChannel(getX(${u.join()}), ${p});
          ${l[o-1]} += 1;
          if(${c}) {
            ${h}
            result[3] = getChannel(getX(${u.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var hde=({inputs:n,backend:t,attrs:e})=>{let{x:r}=n,{paddings:o,mode:s}=e,i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TC(r.shape,o,s):new SC(r.shape,o,s);return t.runWebGLProgram(i,[r],r.dtype)},Rj={kernelName:tl,backendName:"webgl",kernelFunc:hde};var mde=`if (b == 0.0) return NAN;
  return mod(a, b);`,gde=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Gr+`
  return result;
`,yde=ot({opSnippet:mde,packedOpSnippet:gde}),_j={kernelName:Ei,backendName:"webgl",kernelFunc:yde};var NC=class{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var xde=`
if (a == b) {
  return 1.0;
};
return a / b;`,bde=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,B1=ot({opSnippet:xde,packedOpSnippet:bde,checkOutOfBounds:!0}),Oj={kernelName:fi,backendName:"webgl",kernelFunc:B1};var Mj="return a - b;",z1=ot({opSnippet:Mj,packedOpSnippet:Mj,supportsComplex:!0,cpuKernelImpl:Q4}),Fj={kernelName:Gi,backendName:"webgl",kernelFunc:z1};function V1(n){let{inputs:t,backend:e,attrs:r}=n,{logits:o}=t,{dim:s}=r,i=b.parseAxisParam([s],o.shape),a=L1({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=N.expandShapeToKeepDim(a.shape,i),u=ee({inputs:{x:a},backend:e,attrs:{shape:l}}),c=z1({inputs:{a:o,b:u},backend:e}),p=F1({inputs:{x:c},backend:e}),f=$c({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),d=ee({inputs:{x:f},backend:e,attrs:{shape:l}}),h=B1({inputs:{a:p,b:d},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}var $j={kernelName:xl,backendName:"webgl",kernelFunc:V1};function vde(n){let{inputs:t,backend:e,attrs:r}=n,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=r,l=a?o:V1({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new NC(u,c,s),f=[[i]],d=e.runWebGLProgram(p,[l],"int32",f);return a||e.disposeIntermediateTensorInfo(l),d}var Pj={kernelName:df,backendName:"webgl",kernelFunc:vde};var wde=fn+`
  return -x;
`,Cde=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Ide(n){let{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){let s=e.texData.get(r.dataId),[i,a]=O4(s.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let o;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Tr(r.shape,Cde):o=new Mn(r.shape,wde),e.runWebGLProgram(o,[r],r.dtype)}var Lj={kernelName:nl,backendName:"webgl",kernelFunc:Ide};var Sde=Un.nonMaxSuppressionV3Impl;function Tde(n){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=Sde(u,c,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Bj={kernelName:hf,backendName:"webgl",kernelFunc:Tde};var Nde=Un.nonMaxSuppressionV4Impl;function Ede(n){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:f,validOutputs:d}=Nde(c,p,i,a,l,u);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var zj={kernelName:mf,backendName:"webgl",kernelFunc:Ede};var Dde=Un.nonMaxSuppressionV5Impl;function kde(n){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:r}=n,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=e.readSync(o.dataId),p=e.readSync(s.dataId),f=i,d=a,h=l,g=u,{selectedIndices:m,selectedScores:y}=Dde(c,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Vj={kernelName:gf,backendName:"webgl",kernelFunc:kde};var EC=class{constructor(t,e,r,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var Ade=n=>{let{inputs:t,backend:e,attrs:r}=n,{indices:o}=t,{dtype:s,depth:i,onValue:a,offValue:l}=r,u=b.sizeFromShape(o.shape),c=new EC(u,i,a,l),p=ee({inputs:{x:o},backend:e,attrs:{shape:[u]}}),f=e.runWebGLProgram(c,[p],s);e.disposeIntermediateTensorInfo(p);let d=[...o.shape,i],h=ee({inputs:{x:f},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(f),h},Uj={kernelName:ol,backendName:"webgl",kernelFunc:Ade};function bg(n){let{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="complex64"){let o=ha({inputs:{input:r},backend:e}),s=bg({inputs:{x:o},backend:e}),i=Lc({inputs:{input:r},backend:e}),a=bg({inputs:{x:i},backend:e}),l=Er({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return ma({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:e})}var Gj={kernelName:wl,backendName:"webgl",kernelFunc:bg};function Wj(n){let{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=ha({inputs:{input:r},backend:e}),s=Wj({inputs:{x:o},backend:e}),i=Lc({inputs:{input:r},backend:e}),a=bg({inputs:{x:i},backend:e}),l=Er({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return ma({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}var jj={kernelName:rl,backendName:"webgl",kernelFunc:Wj};function Rde(n){let{inputs:t,backend:e,attrs:r}=n,{axis:o}=r;if(t.length===1)return pC({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{b.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=t.map(c=>{let p=pC({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),u=M1({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}var Hj={kernelName:sl,backendName:"webgl",kernelFunc:Rde};var DC=class{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);let o=t.length,s=ke(o),i=e.map(u=>u[0]).join(","),a=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var kC=class{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+t[m]+g[1]);let o=t.length,s=ke(o),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+t[m]).join(","),l=Qt("rc",o),u=Qt("source",o),c=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${c}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let g=0,m=o===1?2:4;g<m;g++)h+=`
        ${f[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${p});
        }
      `;h+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var U1=n=>{let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{paddings:s,constantValue:i}=r;if(b.sizeFromShape(o.shape)===0){let u=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return ma({backend:e,attrs:{shape:u,value:i,dtype:o.dtype}})}let a=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kC(o.shape,s,i):new DC(o.shape,s,i),l=[[i]];return e.runWebGLProgram(a,[o],o.dtype,l)},qj={kernelName:il,backendName:"webgl",kernelFunc:U1};var _de=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ode=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Gr+`
  return result;
`,Mde=ot({opSnippet:_de,packedOpSnippet:Ode}),Kj={kernelName:ki,backendName:"webgl",kernelFunc:Mde};function Fde(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{axis:s,keepDims:i}=r,a=o.shape.length,l=[],u=b.parseAxisParam(s,o.shape),c=u,p=N.getAxesPermutation(c,a),f=o;p!=null&&(f=At({inputs:{x:o},backend:e,attrs:{perm:p}}),c=N.getInnerMostAxes(c.length,a),l.push(f)),N.assertAxesAreInnerMostDims("prod",c,a);let d;if(e.shouldExecuteOnCPU([f])){let h=e.texData.get(f.dataId).values,{outVals:g,outShape:m,outDtype:y}=F4(f.shape,f.dtype,h,c);d=e.makeTensorInfo(m,y,g)}else{let[h,g]=N.computeOutAndReduceShapes(f.shape,c),m=b.sizeFromShape(g),y=ee({inputs:{x:f},backend:e,attrs:{shape:[-1,m]}}),x=Qu(o.dtype),v=Wr(y,x,"prod",e);d=ee({inputs:{x:v},backend:e,attrs:{shape:h}}),l.push(y),l.push(v)}if(i){l.push(d);let h=N.expandShapeToKeepDim(d.shape,u);d=ee({inputs:{x:d},backend:e,attrs:{shape:h}})}return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var Xj={kernelName:ll,backendName:"webgl",kernelFunc:Fde};function $de(n){let{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:a}=r,l=o.map(y=>e.readSync(y.dataId)),u=o.map(y=>y.shape),c=e.readSync(s.dataId),p=e.readSync(i.dataId),[f,d,h]=$4(l,u,c,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var Yj={kernelName:yf,backendName:"webgl",kernelFunc:$de};function Pde(n){let{inputs:t,backend:e}=n,{starts:r,limits:o,deltas:s}=t,i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=P4(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([u.length],"int32",u),f=e.makeTensorInfo([c.length],r.dtype,c);return[p,f]}var Zj={kernelName:xf,backendName:"webgl",kernelFunc:Pde};function Lde(n){let{inputs:t,backend:e,attrs:r}=n,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,u=e.readSync(o.dataId),c=e.readSync(s.dataId),p=e.readSync(i.dataId),f=a.map(m=>e.readSync(m.dataId)),d=a.map(m=>m.shape),[h,g]=L4(u,o.shape,c,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var Qj={kernelName:bf,backendName:"webgl",kernelFunc:Lde};var G1=n=>{let{backend:t,attrs:e}=n,{start:r,stop:o,step:s,dtype:i}=e,a=B4(r,o,s,i);return t.makeTensorInfo([a.length],i,a)},Jj={kernelName:vf,backendName:"webgl",kernelFunc:G1};var Bde="return 1.0 / x;",zde=me({opSnippet:Bde}),eH={kernelName:Ai,backendName:"webgl",kernelFunc:zde};var Vde=fn+`
  return (x < 0.0) ? 0.0 : x;
`,Ude=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gde=me({opSnippet:Vde,packedOpSnippet:Ude}),tH={kernelName:Ri,backendName:"webgl",kernelFunc:Gde};var Wde=fn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jde=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hde=me({opSnippet:Wde,packedOpSnippet:jde}),nH={kernelName:_i,backendName:"webgl",kernelFunc:Hde};var AC=class{constructor(t,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var RC=class{constructor(t,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function qde(n){let{inputs:t,backend:e,attrs:r}=n,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,u]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new RC(o.shape,l,u,s,i):new AC(o.shape,l,u,s,i);return e.runWebGLProgram(c,[o],"float32")}var rH={kernelName:pl,backendName:"webgl",kernelFunc:qde};var _C=class{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Kde(n){let{inputs:t,backend:e,attrs:r}=n,{images:o,dy:s}=t,{alignCorners:i}=r,a=new _C(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var oH={kernelName:If,backendName:"webgl",kernelFunc:Kde};var OC=class{constructor(t,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var MC=class{constructor(t,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,u]=t;this.outputShape=[i,e,r,u];let c=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Xde(n){let{inputs:t,backend:e,attrs:r}=n,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,u]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new MC(o.shape,l,u,s,i):new OC(o.shape,l,u,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var sH={kernelName:cl,backendName:"webgl",kernelFunc:Xde};var FC=class{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],p=l[1]/u[1],f=1/c,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Yde(n){let{inputs:t,backend:e,attrs:r}=n,{images:o,dy:s}=t,{alignCorners:i}=r,a=new FC(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var iH={kernelName:Cf,backendName:"webgl",kernelFunc:Yde};var $C=class{constructor(t,e){this.variableNames=["x"];let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,l)=>o(l)).join(","),i=ke(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var PC=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;let o=Qt("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=ke(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${s}){
            result.g = ${u(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return f(h)}function u(h){return h[r-1]="("+h[r-1]+" + 1)",f(h)}function c(h){return h[r-2]="("+h[r-2]+" + 1)",f(h)}function p(h){return h[r-1]="("+h[r-1]+" + 1)",h[r-2]="("+h[r-2]+" + 1)",f(h)}function f(h){let g=t.map((x,v)=>d(v,h)),m=g.join(","),y=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function d(h,g){return e.indexOf(h)!==-1&&t[h]!==1?`${t[h]} - ${g[h]} - 1`:`${g[h]}`}}};function Zde(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{dims:s}=r,i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Jt({inputs:{x:o},backend:e});let l=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PC(o.shape,a):new $C(o.shape,a);return e.runWebGLProgram(l,[o],o.dtype)}var aH={kernelName:fl,backendName:"webgl",kernelFunc:Zde};var LC=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var lH={kernelName:zf,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,{radians:o,fillValue:s,center:i}=t,a=e,l=new LC(r.shape,s),[u,c]=N.getImageCenter(i,r.shape[1],r.shape[2]),p=[[u,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(l,[r],r.dtype,p)}};var Qde=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Jde=me({opSnippet:Qde}),uH={kernelName:Oi,backendName:"webgl",kernelFunc:Jde};var ehe="return inversesqrt(x);",the=me({opSnippet:ehe,cpuKernelImpl:z4}),cH={kernelName:Mi,backendName:"webgl",kernelFunc:the};var nu=class{constructor(t,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=ke(s.length),c=ke(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};var BC=class{constructor(t,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let u=ke(s.length),c=ke(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides",x=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function nhe(n){let{inputs:t,backend:e,attrs:r}=n,{indices:o,updates:s}=t,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(s,o,i),f=[p/u,u];if(p===0)return e.makeTensorInfo(i,o.dtype);let d=ee({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),h=ee({inputs:{x:s},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0])),m;L().getBool("WEBGL_PACK")?m=new BC(l,a,d.shape.length,h.shape.length,c,f):m=new nu(l,a,d.shape.length,h.shape.length,c,f);let y=e.runWebGLProgram(m,[h,d,g],h.dtype),x=ee({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),x}var pH={kernelName:Sf,backendName:"webgl",kernelFunc:nhe};var zC=class{constructor(t,e,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=L().getNumber("WEBGL_VERSION")===2?s:i,l=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function rhe(n){let{inputs:t,backend:e,attrs:r}=n,{sortedSequence:o,values:s}=t,{side:i}=r,a=new zC(o.shape[0],o.shape[1],s.shape[1],i),l=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",l)}var fH={kernelName:Nf,backendName:"webgl",kernelFunc:rhe};var VC=class{constructor(t,e,r){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${a[c]}`),c<t&&l.push(`${a[c]}`);o=l.join(),s=u.join()}let i=ke(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function ohe(n){let{inputs:t,backend:e}=n,{condition:r,t:o,e:s}=t,i=new VC(r.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[r,o,s],nn(o.dtype,s.dtype))}var dH={kernelName:dl,backendName:"webgl",kernelFunc:ohe};var she=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N.SELU_SCALEALPHA};
  float scale = ${N.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,ihe=me({opSnippet:she}),hH={kernelName:Fi,backendName:"webgl",kernelFunc:ihe};var ahe=Oo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,lhe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uhe=me({opSnippet:ahe,packedOpSnippet:lhe,cpuKernelImpl:U4}),mH={kernelName:Bi,backendName:"webgl",kernelFunc:uhe};var che=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,phe=me({opSnippet:che}),gH={kernelName:Li,backendName:"webgl",kernelFunc:phe};var fhe=Oo+`
  return sin(x);
`,dhe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Gr}
  return result;
`,hhe=me({opSnippet:fhe,packedOpSnippet:dhe}),yH={kernelName:$i,backendName:"webgl",kernelFunc:hhe};var mhe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,ghe=me({opSnippet:mhe}),xH={kernelName:Pi,backendName:"webgl",kernelFunc:ghe};var yhe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,xhe=me({opSnippet:yhe}),bH={kernelName:zi,backendName:"webgl",kernelFunc:xhe};var bhe=n=>{let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{blockShape:s,paddings:i}=r;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,x)=>y*x),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<o.shape.length;++y)l.push([0,0]);let u=[],c=U1({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),p=N.getReshaped(c.shape,s,a,!1),f=N.getPermuted(p.length,s.length,!1),d=N.getReshapedPermuted(c.shape,s,a,!1),h=ee({inputs:{x:c},backend:e,attrs:{shape:p}}),g=At({inputs:{x:h},backend:e,attrs:{perm:f}}),m=ee({inputs:{x:g},backend:e,attrs:{shape:d}});return u.push(c),u.push(h),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m},vH={kernelName:gl,backendName:"webgl",kernelFunc:bhe};function vhe(n){let{inputs:t,backend:e}=n,{indices:r,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(r.dataId),l=e.readSync(o.dataId),u=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,f,d,h,g]=W4(a,r.shape,r.dtype,l,o.dtype,u,c);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var wH={kernelName:Ef,backendName:"webgl",kernelFunc:vhe};function whe(n){let{inputs:t,backend:e}=n,{inputIndices:r,inputShape:o,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(s.dataId)),[u,c,p]=j4(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(c,r.dtype,u),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var CH={kernelName:Df,backendName:"webgl",kernelFunc:whe};function Che(n){let{inputs:t,backend:e}=n,{data:r,indices:o,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=Cw(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(c,r.dtype,u)}var IH={kernelName:kf,backendName:"webgl",kernelFunc:Che};function Ihe(n){let{inputs:t,backend:e}=n,{data:r,indices:o,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[u,c]=Cw(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(c,r.dtype,u)}var SH={kernelName:Af,backendName:"webgl",kernelFunc:Ihe};function She(n){let{inputs:t,backend:e,attrs:r}=n,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:f}=N.calculateShapes(s,o,a),d=!1;if(s.dtype==="string"){let y=e.bufferSync(o),x=e.bufferSync(s),v=b.decodeString(e.readSync(i.dataId)[0]),w=V4(y,x,a,f,c,u,l,p,v,d);return e.makeTensorInfo(a,w.dtype,w.values)}let h=new nu(u,l,o.shape.length,s.shape.length,p,[f,1],d),g=e.runWebGLProgram(h,[s,o,i],s.dtype),m=ee({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}var TH={kernelName:Rf,backendName:"webgl",kernelFunc:She};function The(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=N.prepareSplitSize(o,s,a),u=o.shape.length,c=new Array(u).fill(0),p=o.shape.slice();return l.map(f=>{let d=[...p];d[a]=f;let h=ls({inputs:{x:o},backend:e,attrs:{begin:c,size:d}});return c[a]+=f,h})}var NH={kernelName:yl,backendName:"webgl",kernelFunc:The};var EH="return sqrt(x);",Nhe=me({opSnippet:EH,packedOpSnippet:EH,cpuKernelImpl:H4}),DH={kernelName:Vi,backendName:"webgl",kernelFunc:Nhe};var Ehe="return x * x;",Dhe=me({opSnippet:Ehe}),kH={kernelName:_f,backendName:"webgl",kernelFunc:Dhe};var AH="return (a - b) * (a - b);",khe=ot({opSnippet:AH,packedOpSnippet:AH}),RH={kernelName:Ui,backendName:"webgl",kernelFunc:khe};function Ahe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=e.readSync(o.dataId),i=N.fromUint8ToStringArray(s),a=q4(i,"string",r);return e.makeTensorInfo(o.shape,"string",a)}var _H={kernelName:Gu,backendName:"webgl",kernelFunc:Ahe};function Rhe({inputs:n,attrs:t,backend:e}){let{x:r}=n,o=fn+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Mn(r.shape,o);return e.runWebGLProgram(s,[r],r.dtype)}var OH={kernelName:Hi,backendName:"webgl",kernelFunc:Rhe};var UC=class{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=ke(r.length),i=ke(r.length),a="";if(o===1)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function _he(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{begin:s,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:v,strides:w}=Cn.sliceInfo(o.shape,s,i,a,l,u,c,p,f),S;if(g)S=ee({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=Cn.computeOutShape(x,v,w),_=ls({inputs:{x:o},backend:e,attrs:{begin:x,size:A}});S=ee({inputs:{x:_},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(_)}else if(e.shouldExecuteOnCPU([o])){let _=e.readSync(o.dataId),F=de(o.shape,o.dtype,_),$=K4(d,F,w,x);S=e.makeTensorInfo(h,o.dtype,$.values)}else{let _=new UC(x,w,d);S=e.runWebGLProgram(_,[o],o.dtype)}let k=ee({inputs:{x:S},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(S),k}var MH={kernelName:Of,backendName:"webgl",kernelFunc:_he};function Ohe(n){let{inputs:t,backend:e,attrs:r}=n,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,f=e.readSync(c.dataId),d=e.readSync(p.dataId),[h,g]=X4(f,d,o,s,i,a,l,u);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var FH={kernelName:Mf,backendName:"webgl",kernelFunc:Ohe};function Mhe(n){let{inputs:t,backend:e,attrs:r}=n,{skipEmpty:o}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),l=e.readSync(i.dataId)[0],[u,c,p]=Y4(a,l,o),f=c.length;return[e.makeTensorInfo([f,2],"int32",u),e.makeTensorInfo([f],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var $H={kernelName:Ff,backendName:"webgl",kernelFunc:Mhe};function Fhe(n){let{inputs:t,backend:e,attrs:r}=n,{numBuckets:o}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=Z4(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var PH={kernelName:$f,backendName:"webgl",kernelFunc:Fhe};var $he="return tan(x);",Phe=me({opSnippet:$he}),LH={kernelName:Wi,backendName:"webgl",kernelFunc:Phe};var Lhe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Bhe=me({opSnippet:Lhe}),BH={kernelName:ji,backendName:"webgl",kernelFunc:Bhe};function zhe(n){let{inputs:t,backend:e,attrs:r}=n,{tensor:o,indices:s,updates:i}=t,{}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=N.calculateShapes(i,s,o.shape),f=[p/u,u];if(p===0)return e.makeTensorInfo(o.shape,s.dtype);let d=ee({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),h=ee({inputs:{x:i},backend:e,attrs:{shape:[l,u]}}),g=ee({inputs:{x:o},backend:e,attrs:{shape:f}}),m=new nu(l,a,d.shape.length,h.shape.length,c,f,!1,!0),y=e.runWebGLProgram(m,[h,d,g],g.dtype),x=ee({inputs:{x:y},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),x}var zH={kernelName:Tf,backendName:"webgl",kernelFunc:zhe};var GC=class{constructor(t,e){this.variableNames=["A"];let r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*e[i];this.outputShape=r,this.rank=r.length;let o=ke(this.rank),s=Vhe(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Vhe(n){let t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<n.length;o++)r.push(`imod(${e[o]}, ${n[o]})`);return r.join()}function W1(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let l=e.readSync(o.dataId),u=o.dtype==="string"?l.map(f=>b.decodeString(f)):l,c=de(o.shape,o.dtype,u),p=J4(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new GC(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var VH={kernelName:ws,backendName:"webgl",kernelFunc:W1};var WC=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},jC=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Bc(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function UH(n){let t=1;for(;t<n;)t*=2;return t}function Uhe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o}=t,{k:s,sorted:i}=r,a=L().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=L().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=o.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>l){let $=e.readSync(o.dataId),[V,U]=eG($,u,o.dtype,s,i);return[e.makeTensorInfo(V.shape,V.dtype,V.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return u[u.length-1]=0,[e.makeTensorInfo(u,o.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(c===1)return[o,ma({attrs:{shape:u,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),f=p!==null&&p.isPacked,d=f?e.unpackTensor(o):o,g=b.sizeFromShape(u)/c,m=ee({inputs:{x:d},attrs:{shape:[g,c]},backend:e});f&&Bc(e,d);let y=UH(s),x=UH(c),v=null,w=()=>v===null?[m,m]:[m,v],S=($,V,U)=>{let W=w(),G=new WC(U),K=[[c],[v===null?1:0],[Number.NEGATIVE_INFINITY],[$],[V]],Q=v;v=e.runWebGLProgram(G,W,"int32",K),Bc(e,Q)};for(let $=1;$<y;$*=2){let V=$*2;for(let U=$;U>=1;U/=2)S(V,U,[g,x])}for(let $=x;$>y;$/=2){let V=w(),U=new jC([g,$/2]),G=[[c],[v===null?1:0],[y]],H=v;v=e.runWebGLProgram(U,V,"int32",G),Bc(e,H);let K=y/2,Q=K*2;for(let X=K;X>=1;X/=2)S(Q,X,v.shape)}let k=v;v=ls({inputs:{x:v},backend:e,attrs:{begin:0,size:[g,s]}}),Bc(e,k);let A=P1({inputs:{x:m,indices:v},backend:e,attrs:{axis:1,batchDims:1}});Bc(e,m);let _=u.slice(0,-1);_.push(s),k=v,v=ee({inputs:{x:v},attrs:{shape:_},backend:e}),Bc(e,k);let F=A;return A=ee({inputs:{x:A},attrs:{shape:_},backend:e}),Bc(e,F),[A,v]}var GH={kernelName:Pf,backendName:"webgl",kernelFunc:Uhe};var HC=class{constructor(t,e,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Ghe(n){let{inputs:t,backend:e,attrs:r}=n,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,p,f,d]=o.shape,[h,g]=u??[p,f],m=[c,h,g,d],y=new HC(p,f,i,a,l,m);return e.runWebGLProgram(y,[o,s],"float32")}var WH={kernelName:Lf,backendName:"webgl",kernelFunc:Ghe};function Whe(n){let{inputs:t,attrs:e,backend:r}=n,{axis:o}=e,{x:s}=t;zs(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:l,indices:u}=tG(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}var jH={kernelName:Bf,backendName:"webgl",kernelFunc:Whe};function jhe(n){let{inputs:t,backend:e,attrs:r}=n,{value:o}=t,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,l=o.shape[s],u=new Array(a-1),c=0;for(let g=0;g<a;g++)g!==s&&(u[c++]=i.shape[g]);let p=[],f=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let h=new Array(l);for(let g=0;g<h.length;g++){f[s]=g;let m=ls({inputs:{x:i},backend:e,attrs:{begin:f,size:d}}),y=ee({inputs:{x:m},backend:e,attrs:{shape:u}});h[g]=y,p.push(m)}return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var HH={kernelName:bl,backendName:"webgl",kernelFunc:jhe};var qC=class{constructor(t,e){this.variableNames=["x","segmentIds"];let r=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let l="0.0",u="sumValue",c=Math.floor(r/4)*4,p=r%4,f=`
        sumValue += dot(values, segFilter);
    `,d="";s%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function Hhe(n){let{inputs:t,backend:e,attrs:r}=n,{x:o,segmentIds:s}=t,{numSegments:i}=r,a=o.shape.length,l=[],u=0,c=N.getAxesPermutation([u],a),p=o;c!=null&&(p=At({inputs:{x:o},backend:e,attrs:{perm:c}}),l.push(p),u=N.getInnerMostAxes(1,a)[0]);let f=N.segment_util.computeOutShape(p.shape,u,i),d=b.sizeFromShape([p.shape[u]]),h=ee({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}});l.push(h);let g=Qu(o.dtype),m=(w,S,k,A,_)=>{let F=w.shape[0],$=w.shape[1],V=N.segment_util.segOpComputeOptimalWindowSize($,_),U={windowSize:V,inSize:$,batchSize:F,numSegments:_},W=new qC(U,S),G=e.compileAndRun(W,[w,k],A);if(l.push(G),G.shape[1]===_)return G;let H=G1({backend:e,attrs:{start:0,stop:_,step:1,dtype:"float32"}}),K=W1({inputs:{x:H},backend:e,attrs:{reps:[$/V]}});return l.push(H),l.push(K),m(G,S,K,A,_)},y=m(h,"unsortedSegmentSum",s,g,i),x=ee({inputs:{x:y},backend:e,attrs:{shape:f}}),v=x;if(c!=null){l.push(x);let w=N.getUndoAxesPermutation(c);v=At({inputs:{x:v},backend:e,attrs:{perm:w}})}return l.forEach(w=>e.disposeIntermediateTensorInfo(w)),v}var qH={kernelName:vl,backendName:"webgl",kernelFunc:Hhe};var qhe=[kG,RG,_G,OG,FG,$G,PG,LG,VG,UG,GG,WG,jG,HG,qG,KG,XG,YG,ZG,QG,JG,tW,nW,rW,oW,lW,cW,pW,bG,dW,mW,gW,yW,xW,bW,vW,wW,CW,IW,SW,EW,DW,kW,AW,RW,_W,OW,MW,FW,$W,PW,LW,BW,zW,VW,UW,WW,jW,HW,qW,XW,YW,ZW,QW,JW,ej,tj,nj,rj,xG,oj,hW,sj,ij,aj,vG,lj,uj,cj,pj,fj,dj,hj,mj,gj,yj,bj,vj,wj,Cj,Ij,Sj,Nj,Dj,kj,Aj,Rj,_j,Pj,IG,Lj,Bj,zj,Vj,sW,Uj,jj,Hj,qj,Kj,wG,Xj,Yj,Zj,Qj,Jj,iW,Oj,eH,tH,nH,TG,rH,oH,sH,iH,aH,lH,uH,cH,pH,fH,dH,hH,mH,gH,yH,xH,eW,$j,bH,vH,wH,CH,IH,SH,TH,NH,DH,kH,RH,_H,OH,MH,FH,$H,PH,Fj,EG,LH,BH,zH,VH,GH,WH,DG,jH,HH,qH,Gj];for(let n of qhe)Qy(n);function hr(n,t,e,r){return new(e||(e=Promise))(function(o,s){function i(u){try{l(r.next(u))}catch(c){s(c)}}function a(u){try{l(r.throw(u))}catch(c){s(c)}}function l(u){var c;u.done?o(u.value):(c=u.value,c instanceof e?c:new e(function(p){p(c)})).then(i,a)}l((r=r.apply(n,t||[])).next())})}var zc=class{constructor(){this.listeners={}}on(t,e,r){if(this.listeners[t]||(this.listeners[t]=new Set),this.listeners[t].add(e),r?.once){let o=()=>{this.un(t,o),this.un(t,e)};return this.on(t,o),o}return()=>this.un(t,e)}un(t,e){var r;(r=this.listeners[t])===null||r===void 0||r.delete(e)}once(t,e){return this.on(t,e,{once:!0})}unAll(){this.listeners={}}emit(t,...e){this.listeners[t]&&this.listeners[t].forEach(r=>r(...e))}},KH={decode:function(n,t){return hr(this,void 0,void 0,function*(){let e=new AudioContext({sampleRate:t});return e.decodeAudioData(n).finally(()=>e.close())})},createBuffer:function(n,t){return typeof n[0]=="number"&&(n=[n]),function(e){let r=e[0];if(r.some(o=>o>1||o<-1)){let o=r.length,s=0;for(let i=0;i<o;i++){let a=Math.abs(r[i]);a>s&&(s=a)}for(let i of e)for(let a=0;a<o;a++)i[a]/=s}}(n),{duration:t,length:n[0].length,sampleRate:n[0].length/t,numberOfChannels:n.length,getChannelData:e=>n?.[e],copyFromChannel:AudioBuffer.prototype.copyFromChannel,copyToChannel:AudioBuffer.prototype.copyToChannel}}};function YH(n,t){let e=t.xmlns?document.createElementNS(t.xmlns,n):document.createElement(n);for(let[r,o]of Object.entries(t))if(r==="children")for(let[s,i]of Object.entries(t))typeof i=="string"?e.appendChild(document.createTextNode(i)):e.appendChild(YH(s,i));else r==="style"?Object.assign(e.style,o):r==="textContent"?e.textContent=o:e.setAttribute(r,o.toString());return e}function XH(n,t,e){let r=YH(n,t||{});return e?.appendChild(r),r}var Xhe=Object.freeze({__proto__:null,createElement:XH,default:XH}),Yhe={fetchBlob:function(n,t,e){return hr(this,void 0,void 0,function*(){let r=yield fetch(n,e);if(r.status>=400)throw new Error(`Failed to fetch ${n}: ${r.status} (${r.statusText})`);return function(o,s){hr(this,void 0,void 0,function*(){if(!o.body||!o.headers)return;let i=o.body.getReader(),a=Number(o.headers.get("Content-Length"))||0,l=0,u=p=>hr(this,void 0,void 0,function*(){l+=p?.length||0;let f=Math.round(l/a*100);s(f)}),c=()=>hr(this,void 0,void 0,function*(){let p;try{p=yield i.read()}catch{return}p.done||(u(p.value),yield c())});c()})}(r.clone(),t),r.blob()})}},j1=class extends zc{constructor(t){super(),this.isExternalMedia=!1,t.media?(this.media=t.media,this.isExternalMedia=!0):this.media=document.createElement("audio"),t.mediaControls&&(this.media.controls=!0),t.autoplay&&(this.media.autoplay=!0),t.playbackRate!=null&&this.onMediaEvent("canplay",()=>{t.playbackRate!=null&&(this.media.playbackRate=t.playbackRate)},{once:!0})}onMediaEvent(t,e,r){return this.media.addEventListener(t,e,r),()=>this.media.removeEventListener(t,e,r)}getSrc(){return this.media.currentSrc||this.media.src||""}revokeSrc(){let t=this.getSrc();t.startsWith("blob:")&&URL.revokeObjectURL(t)}canPlayType(t){return this.media.canPlayType(t)!==""}setSrc(t,e){let r=this.getSrc();if(t&&r===t)return;this.revokeSrc();let o=e instanceof Blob&&(this.canPlayType(e.type)||!t)?URL.createObjectURL(e):t;try{this.media.src=o}catch{this.media.src=t}}destroy(){this.media.pause(),this.isExternalMedia||(this.media.remove(),this.revokeSrc(),this.media.src="",this.media.load())}setMediaElement(t){this.media=t}play(){return hr(this,void 0,void 0,function*(){return this.media.play()})}pause(){this.media.pause()}isPlaying(){return!this.media.paused&&!this.media.ended}setTime(t){this.media.currentTime=t}getDuration(){return this.media.duration}getCurrentTime(){return this.media.currentTime}getVolume(){return this.media.volume}setVolume(t){this.media.volume=t}getMuted(){return this.media.muted}setMuted(t){this.media.muted=t}getPlaybackRate(){return this.media.playbackRate}isSeeking(){return this.media.seeking}setPlaybackRate(t,e){e!=null&&(this.media.preservesPitch=e),this.media.playbackRate=t}getMediaElement(){return this.media}setSinkId(t){return this.media.setSinkId(t)}},vg=class n extends zc{constructor(t,e){super(),this.timeouts=[],this.isScrollable=!1,this.audioData=null,this.resizeObserver=null,this.lastContainerWidth=0,this.isDragging=!1,this.subscriptions=[],this.subscriptions=[],this.options=t;let r=this.parentFromOptionsContainer(t.container);this.parent=r;let[o,s]=this.initHtml();r.appendChild(o),this.container=o,this.scrollContainer=s.querySelector(".scroll"),this.wrapper=s.querySelector(".wrapper"),this.canvasWrapper=s.querySelector(".canvases"),this.progressWrapper=s.querySelector(".progress"),this.cursor=s.querySelector(".cursor"),e&&s.appendChild(e),this.initEvents()}parentFromOptionsContainer(t){let e;if(typeof t=="string"?e=document.querySelector(t):t instanceof HTMLElement&&(e=t),!e)throw new Error("Container not found");return e}initEvents(){let t=e=>{let r=this.wrapper.getBoundingClientRect(),o=e.clientX-r.left,s=e.clientY-r.top;return[o/r.width,s/r.height]};if(this.wrapper.addEventListener("click",e=>{let[r,o]=t(e);this.emit("click",r,o)}),this.wrapper.addEventListener("dblclick",e=>{let[r,o]=t(e);this.emit("dblclick",r,o)}),this.options.dragToSeek!==!0&&typeof this.options.dragToSeek!="object"||this.initDrag(),this.scrollContainer.addEventListener("scroll",()=>{let{scrollLeft:e,scrollWidth:r,clientWidth:o}=this.scrollContainer,s=e/r,i=(e+o)/r;this.emit("scroll",s,i,e,e+o)}),typeof ResizeObserver=="function"){let e=this.createDelay(100);this.resizeObserver=new ResizeObserver(()=>{e().then(()=>this.onContainerResize()).catch(()=>{})}),this.resizeObserver.observe(this.scrollContainer)}}onContainerResize(){let t=this.parent.clientWidth;t===this.lastContainerWidth&&this.options.height!=="auto"||(this.lastContainerWidth=t,this.reRender())}initDrag(){this.subscriptions.push(function(t,e,r,o,s=3,i=0,a=100){if(!t)return()=>{};let l=matchMedia("(pointer: coarse)").matches,u=()=>{},c=p=>{if(p.button!==i)return;p.preventDefault(),p.stopPropagation();let f=p.clientX,d=p.clientY,h=!1,g=Date.now(),m=S=>{if(S.preventDefault(),S.stopPropagation(),l&&Date.now()-g<a)return;let k=S.clientX,A=S.clientY,_=k-f,F=A-d;if(h||Math.abs(_)>s||Math.abs(F)>s){let $=t.getBoundingClientRect(),{left:V,top:U}=$;h||(r?.(f-V,d-U),h=!0),e(_,F,k-V,A-U),f=k,d=A}},y=S=>{if(h){let k=S.clientX,A=S.clientY,_=t.getBoundingClientRect(),{left:F,top:$}=_;o?.(k-F,A-$)}u()},x=S=>{S.relatedTarget&&S.relatedTarget!==document.documentElement||y(S)},v=S=>{h&&(S.stopPropagation(),S.preventDefault())},w=S=>{h&&S.preventDefault()};document.addEventListener("pointermove",m),document.addEventListener("pointerup",y),document.addEventListener("pointerout",x),document.addEventListener("pointercancel",x),document.addEventListener("touchmove",w,{passive:!1}),document.addEventListener("click",v,{capture:!0}),u=()=>{document.removeEventListener("pointermove",m),document.removeEventListener("pointerup",y),document.removeEventListener("pointerout",x),document.removeEventListener("pointercancel",x),document.removeEventListener("touchmove",w),setTimeout(()=>{document.removeEventListener("click",v,{capture:!0})},10)}};return t.addEventListener("pointerdown",c),()=>{u(),t.removeEventListener("pointerdown",c)}}(this.wrapper,(t,e,r)=>{this.emit("drag",Math.max(0,Math.min(1,r/this.wrapper.getBoundingClientRect().width)))},t=>{this.isDragging=!0,this.emit("dragstart",Math.max(0,Math.min(1,t/this.wrapper.getBoundingClientRect().width)))},t=>{this.isDragging=!1,this.emit("dragend",Math.max(0,Math.min(1,t/this.wrapper.getBoundingClientRect().width)))}))}getHeight(t,e){var r;let o=((r=this.audioData)===null||r===void 0?void 0:r.numberOfChannels)||1;if(t==null)return 128;if(!isNaN(Number(t)))return Number(t);if(t==="auto"){let s=this.parent.clientHeight||128;return e?.every(i=>!i.overlay)?s/o:s}return 128}initHtml(){let t=document.createElement("div"),e=t.attachShadow({mode:"open"}),r=this.options.cspNonce&&typeof this.options.cspNonce=="string"?this.options.cspNonce.replace(/"/g,""):"";return e.innerHTML=`
      <style${r?` nonce="${r}"`:""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height,this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `,[t,e]}setOptions(t){if(this.options.container!==t.container){let e=this.parentFromOptionsContainer(t.container);e.appendChild(this.container),this.parent=e}t.dragToSeek!==!0&&typeof this.options.dragToSeek!="object"||this.initDrag(),this.options=t,this.reRender()}getWrapper(){return this.wrapper}getWidth(){return this.scrollContainer.clientWidth}getScroll(){return this.scrollContainer.scrollLeft}setScroll(t){this.scrollContainer.scrollLeft=t}setScrollPercentage(t){let{scrollWidth:e}=this.scrollContainer,r=e*t;this.setScroll(r)}destroy(){var t,e;this.subscriptions.forEach(r=>r()),this.container.remove(),(t=this.resizeObserver)===null||t===void 0||t.disconnect(),(e=this.unsubscribeOnScroll)===null||e===void 0||e.call(this)}createDelay(t=10){let e,r,o=()=>{e&&clearTimeout(e),r&&r()};return this.timeouts.push(o),()=>new Promise((s,i)=>{o(),r=i,e=setTimeout(()=>{e=void 0,r=void 0,s()},t)})}convertColorValues(t){if(!Array.isArray(t))return t||"";if(t.length<2)return t[0]||"";let e=document.createElement("canvas"),r=e.getContext("2d"),o=e.height*(window.devicePixelRatio||1),s=r.createLinearGradient(0,0,0,o),i=1/(t.length-1);return t.forEach((a,l)=>{let u=l*i;s.addColorStop(u,a)}),s}getPixelRatio(){return Math.max(1,window.devicePixelRatio||1)}renderBarWaveform(t,e,r,o){let s=t[0],i=t[1]||t[0],a=s.length,{width:l,height:u}=r.canvas,c=u/2,p=this.getPixelRatio(),f=e.barWidth?e.barWidth*p:1,d=e.barGap?e.barGap*p:e.barWidth?f/2:0,h=e.barRadius||0,g=l/(f+d)/a,m=h&&"roundRect"in r?"roundRect":"rect";r.beginPath();let y=0,x=0,v=0;for(let w=0;w<=a;w++){let S=Math.round(w*g);if(S>y){let _=Math.round(x*c*o),F=_+Math.round(v*c*o)||1,$=c-_;e.barAlign==="top"?$=0:e.barAlign==="bottom"&&($=u-F),r[m](y*(f+d),$,f,F,h),y=S,x=0,v=0}let k=Math.abs(s[w]||0),A=Math.abs(i[w]||0);k>x&&(x=k),A>v&&(v=A)}r.fill(),r.closePath()}renderLineWaveform(t,e,r,o){let s=i=>{let a=t[i]||t[0],l=a.length,{height:u}=r.canvas,c=u/2,p=r.canvas.width/l;r.moveTo(0,c);let f=0,d=0;for(let h=0;h<=l;h++){let g=Math.round(h*p);if(g>f){let y=c+(Math.round(d*c*o)||1)*(i===0?-1:1);r.lineTo(f,y),f=g,d=0}let m=Math.abs(a[h]||0);m>d&&(d=m)}r.lineTo(f,c)};r.beginPath(),s(0),s(1),r.fill(),r.closePath()}renderWaveform(t,e,r){if(r.fillStyle=this.convertColorValues(e.waveColor),e.renderFunction)return void e.renderFunction(t,r);let o=e.barHeight||1;if(e.normalize){let s=Array.from(t[0]).reduce((i,a)=>Math.max(i,Math.abs(a)),0);o=s?1/s:1}e.barWidth||e.barGap||e.barAlign?this.renderBarWaveform(t,e,r,o):this.renderLineWaveform(t,e,r,o)}renderSingleCanvas(t,e,r,o,s,i,a){let l=this.getPixelRatio(),u=document.createElement("canvas");u.width=Math.round(r*l),u.height=Math.round(o*l),u.style.width=`${r}px`,u.style.height=`${o}px`,u.style.left=`${Math.round(s)}px`,i.appendChild(u);let c=u.getContext("2d");if(this.renderWaveform(t,e,c),u.width>0&&u.height>0){let p=u.cloneNode(),f=p.getContext("2d");f.drawImage(u,0,0),f.globalCompositeOperation="source-in",f.fillStyle=this.convertColorValues(e.progressColor),f.fillRect(0,0,u.width,u.height),a.appendChild(p)}}renderMultiCanvas(t,e,r,o,s,i){let a=this.getPixelRatio(),{clientWidth:l}=this.scrollContainer,u=r/a,c=Math.min(n.MAX_CANVAS_WIDTH,l,u),p={};if(e.barWidth||e.barGap){let m=e.barWidth||.5,y=m+(e.barGap||m/2);c%y!=0&&(c=Math.floor(c/y)*y)}let f=m=>{if(m<0||m>=d||p[m])return;p[m]=!0;let y=m*c,x=Math.min(u-y,c);if(x<=0)return;let v=t.map(w=>{let S=Math.floor(y/u*w.length),k=Math.floor((y+x)/u*w.length);return w.slice(S,k)});this.renderSingleCanvas(v,e,x,o,y,s,i)},d=Math.ceil(u/c);if(!this.isScrollable){for(let m=0;m<d;m++)f(m);return}let h=this.scrollContainer.scrollLeft/u,g=Math.floor(h*d);f(g-1),f(g),f(g+1),d>1&&(this.unsubscribeOnScroll=this.on("scroll",()=>{let{scrollLeft:m}=this.scrollContainer,y=Math.floor(m/u*d);Object.keys(p).length>n.MAX_NODES&&(s.innerHTML="",i.innerHTML="",p={}),f(y-1),f(y),f(y+1)}))}renderChannel(t,e,r,o){var{overlay:s}=e,i=function(c,p){var f={};for(var d in c)Object.prototype.hasOwnProperty.call(c,d)&&p.indexOf(d)<0&&(f[d]=c[d]);if(c!=null&&typeof Object.getOwnPropertySymbols=="function"){var h=0;for(d=Object.getOwnPropertySymbols(c);h<d.length;h++)p.indexOf(d[h])<0&&Object.prototype.propertyIsEnumerable.call(c,d[h])&&(f[d[h]]=c[d[h]])}return f}(e,["overlay"]);let a=document.createElement("div"),l=this.getHeight(i.height,i.splitChannels);a.style.height=`${l}px`,s&&o>0&&(a.style.marginTop=`-${l}px`),this.canvasWrapper.style.minHeight=`${l}px`,this.canvasWrapper.appendChild(a);let u=a.cloneNode();this.progressWrapper.appendChild(u),this.renderMultiCanvas(t,i,r,l,a,u)}render(t){return hr(this,void 0,void 0,function*(){var e;this.timeouts.forEach(l=>l()),this.timeouts=[],this.canvasWrapper.innerHTML="",this.progressWrapper.innerHTML="",this.options.width!=null&&(this.scrollContainer.style.width=typeof this.options.width=="number"?`${this.options.width}px`:this.options.width);let r=this.getPixelRatio(),o=this.scrollContainer.clientWidth,s=Math.ceil(t.duration*(this.options.minPxPerSec||0));this.isScrollable=s>o;let i=this.options.fillParent&&!this.isScrollable,a=(i?o:s)*r;if(this.wrapper.style.width=i?"100%":`${s}px`,this.scrollContainer.style.overflowX=this.isScrollable?"auto":"hidden",this.scrollContainer.classList.toggle("noScrollbar",!!this.options.hideScrollbar),this.cursor.style.backgroundColor=`${this.options.cursorColor||this.options.progressColor}`,this.cursor.style.width=`${this.options.cursorWidth}px`,this.audioData=t,this.emit("render"),this.options.splitChannels)for(let l=0;l<t.numberOfChannels;l++){let u=Object.assign(Object.assign({},this.options),(e=this.options.splitChannels)===null||e===void 0?void 0:e[l]);this.renderChannel([t.getChannelData(l)],u,a,l)}else{let l=[t.getChannelData(0)];t.numberOfChannels>1&&l.push(t.getChannelData(1)),this.renderChannel(l,this.options,a,0)}Promise.resolve().then(()=>this.emit("rendered"))})}reRender(){var t;if((t=this.unsubscribeOnScroll)===null||t===void 0||t.call(this),delete this.unsubscribeOnScroll,!this.audioData)return;let{scrollWidth:e}=this.scrollContainer,{right:r}=this.progressWrapper.getBoundingClientRect();if(this.render(this.audioData),this.isScrollable&&e!==this.scrollContainer.scrollWidth){let{right:o}=this.progressWrapper.getBoundingClientRect(),s=o-r;s*=2,s=s<0?Math.floor(s):Math.ceil(s),s/=2,this.scrollContainer.scrollLeft+=s}}zoom(t){this.options.minPxPerSec=t,this.reRender()}scrollIntoView(t,e=!1){let{scrollLeft:r,scrollWidth:o,clientWidth:s}=this.scrollContainer,i=t*o,a=r,l=r+s,u=s/2;if(this.isDragging)i+30>l?this.scrollContainer.scrollLeft+=30:i-30<a&&(this.scrollContainer.scrollLeft-=30);else{(i<a||i>l)&&(this.scrollContainer.scrollLeft=i-(this.options.autoCenter?u:0));let c=i-r-u;e&&this.options.autoCenter&&c>0&&(this.scrollContainer.scrollLeft+=Math.min(c,10))}{let c=this.scrollContainer.scrollLeft,p=c/o,f=(c+s)/o;this.emit("scroll",p,f,c,c+s)}}renderProgress(t,e){if(isNaN(t))return;let r=100*t;this.canvasWrapper.style.clipPath=`polygon(${r}% 0, 100% 0, 100% 100%, ${r}% 100%)`,this.progressWrapper.style.width=`${r}%`,this.cursor.style.left=`${r}%`,this.cursor.style.transform=`translateX(-${Math.round(r)===100?this.options.cursorWidth:0}px)`,this.isScrollable&&this.options.autoScroll&&this.scrollIntoView(t,e)}exportImage(t,e,r){return hr(this,void 0,void 0,function*(){let o=this.canvasWrapper.querySelectorAll("canvas");if(!o.length)throw new Error("No waveform data");if(r==="dataURL"){let s=Array.from(o).map(i=>i.toDataURL(t,e));return Promise.resolve(s)}return Promise.all(Array.from(o).map(s=>new Promise((i,a)=>{s.toBlob(l=>{l?i(l):a(new Error("Could not export image"))},t,e)})))})}};vg.MAX_CANVAS_WIDTH=8e3,vg.MAX_NODES=10;var H1=class extends zc{constructor(){super(...arguments),this.unsubscribe=()=>{}}start(){this.unsubscribe=this.on("tick",()=>{requestAnimationFrame(()=>{this.emit("tick")})}),this.emit("tick")}stop(){this.unsubscribe()}destroy(){this.unsubscribe()}},KC=class extends zc{constructor(t=new AudioContext){super(),this.bufferNode=null,this.playStartTime=0,this.playedDuration=0,this._muted=!1,this._playbackRate=1,this._duration=void 0,this.buffer=null,this.currentSrc="",this.paused=!0,this.crossOrigin=null,this.seeking=!1,this.autoplay=!1,this.addEventListener=this.on,this.removeEventListener=this.un,this.audioContext=t,this.gainNode=this.audioContext.createGain(),this.gainNode.connect(this.audioContext.destination)}load(){return hr(this,void 0,void 0,function*(){})}get src(){return this.currentSrc}set src(t){if(this.currentSrc=t,this._duration=void 0,!t)return this.buffer=null,void this.emit("emptied");fetch(t).then(e=>{if(e.status>=400)throw new Error(`Failed to fetch ${t}: ${e.status} (${e.statusText})`);return e.arrayBuffer()}).then(e=>this.currentSrc!==t?null:this.audioContext.decodeAudioData(e)).then(e=>{this.currentSrc===t&&(this.buffer=e,this.emit("loadedmetadata"),this.emit("canplay"),this.autoplay&&this.play())})}_play(){var t;if(!this.paused)return;this.paused=!1,(t=this.bufferNode)===null||t===void 0||t.disconnect(),this.bufferNode=this.audioContext.createBufferSource(),this.buffer&&(this.bufferNode.buffer=this.buffer),this.bufferNode.playbackRate.value=this._playbackRate,this.bufferNode.connect(this.gainNode);let e=this.playedDuration*this._playbackRate;e>=this.duration&&(e=0,this.playedDuration=0),this.bufferNode.start(this.audioContext.currentTime,e),this.playStartTime=this.audioContext.currentTime,this.bufferNode.onended=()=>{this.currentTime>=this.duration&&(this.pause(),this.emit("ended"))}}_pause(){var t;this.paused=!0,(t=this.bufferNode)===null||t===void 0||t.stop(),this.playedDuration+=this.audioContext.currentTime-this.playStartTime}play(){return hr(this,void 0,void 0,function*(){this.paused&&(this._play(),this.emit("play"))})}pause(){this.paused||(this._pause(),this.emit("pause"))}stopAt(t){var e,r;let o=t-this.currentTime;(e=this.bufferNode)===null||e===void 0||e.stop(this.audioContext.currentTime+o),(r=this.bufferNode)===null||r===void 0||r.addEventListener("ended",()=>{this.bufferNode=null,this.pause()},{once:!0})}setSinkId(t){return hr(this,void 0,void 0,function*(){return this.audioContext.setSinkId(t)})}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this.bufferNode&&(this.bufferNode.playbackRate.value=t)}get currentTime(){return(this.paused?this.playedDuration:this.playedDuration+(this.audioContext.currentTime-this.playStartTime))*this._playbackRate}set currentTime(t){let e=!this.paused;e&&this._pause(),this.playedDuration=t/this._playbackRate,e&&this._play(),this.emit("seeking"),this.emit("timeupdate")}get duration(){var t,e;return(t=this._duration)!==null&&t!==void 0?t:((e=this.buffer)===null||e===void 0?void 0:e.duration)||0}set duration(t){this._duration=t}get volume(){return this.gainNode.gain.value}set volume(t){this.gainNode.gain.value=t,this.emit("volumechange")}get muted(){return this._muted}set muted(t){this._muted!==t&&(this._muted=t,this._muted?this.gainNode.disconnect():this.gainNode.connect(this.audioContext.destination))}canPlayType(t){return/^(audio|video)\//.test(t)}getGainNode(){return this.gainNode}getChannelData(){let t=[];if(!this.buffer)return t;let e=this.buffer.numberOfChannels;for(let r=0;r<e;r++)t.push(this.buffer.getChannelData(r));return t}},Zhe={waveColor:"#999",progressColor:"#555",cursorWidth:1,minPxPerSec:0,fillParent:!0,interact:!0,dragToSeek:!1,autoScroll:!0,autoCenter:!0,sampleRate:8e3},ru=class n extends j1{static create(t){return new n(t)}constructor(t){let e=t.media||(t.backend==="WebAudio"?new KC:void 0);super({media:e,mediaControls:t.mediaControls,autoplay:t.autoplay,playbackRate:t.audioRate}),this.plugins=[],this.decodedData=null,this.subscriptions=[],this.mediaSubscriptions=[],this.abortController=null,this.options=Object.assign({},Zhe,t),this.timer=new H1;let r=e?void 0:this.getMediaElement();this.renderer=new vg(this.options,r),this.initPlayerEvents(),this.initRendererEvents(),this.initTimerEvents(),this.initPlugins();let o=this.options.url||this.getSrc()||"";Promise.resolve().then(()=>{this.emit("init");let{peaks:s,duration:i}=this.options;(o||s&&i)&&this.load(o,s,i).catch(()=>null)})}updateProgress(t=this.getCurrentTime()){return this.renderer.renderProgress(t/this.getDuration(),this.isPlaying()),t}initTimerEvents(){this.subscriptions.push(this.timer.on("tick",()=>{if(!this.isSeeking()){let t=this.updateProgress();this.emit("timeupdate",t),this.emit("audioprocess",t)}}))}initPlayerEvents(){this.isPlaying()&&(this.emit("play"),this.timer.start()),this.mediaSubscriptions.push(this.onMediaEvent("timeupdate",()=>{let t=this.updateProgress();this.emit("timeupdate",t)}),this.onMediaEvent("play",()=>{this.emit("play"),this.timer.start()}),this.onMediaEvent("pause",()=>{this.emit("pause"),this.timer.stop()}),this.onMediaEvent("emptied",()=>{this.timer.stop()}),this.onMediaEvent("ended",()=>{this.emit("finish")}),this.onMediaEvent("seeking",()=>{this.emit("seeking",this.getCurrentTime())}),this.onMediaEvent("error",t=>{this.emit("error",t.error)}))}initRendererEvents(){this.subscriptions.push(this.renderer.on("click",(t,e)=>{this.options.interact&&(this.seekTo(t),this.emit("interaction",t*this.getDuration()),this.emit("click",t,e))}),this.renderer.on("dblclick",(t,e)=>{this.emit("dblclick",t,e)}),this.renderer.on("scroll",(t,e,r,o)=>{let s=this.getDuration();this.emit("scroll",t*s,e*s,r,o)}),this.renderer.on("render",()=>{this.emit("redraw")}),this.renderer.on("rendered",()=>{this.emit("redrawcomplete")}),this.renderer.on("dragstart",t=>{this.emit("dragstart",t)}),this.renderer.on("dragend",t=>{this.emit("dragend",t)}));{let t;this.subscriptions.push(this.renderer.on("drag",e=>{if(!this.options.interact)return;let r;this.renderer.renderProgress(e),clearTimeout(t),this.isPlaying()?r=0:this.options.dragToSeek===!0?r=200:typeof this.options.dragToSeek=="object"&&this.options.dragToSeek!==void 0&&(r=this.options.dragToSeek.debounceTime),t=setTimeout(()=>{this.seekTo(e)},r),this.emit("interaction",e*this.getDuration()),this.emit("drag",e)}))}}initPlugins(){var t;!((t=this.options.plugins)===null||t===void 0)&&t.length&&this.options.plugins.forEach(e=>{this.registerPlugin(e)})}unsubscribePlayerEvents(){this.mediaSubscriptions.forEach(t=>t()),this.mediaSubscriptions=[]}setOptions(t){this.options=Object.assign({},this.options,t),this.renderer.setOptions(this.options),t.audioRate&&this.setPlaybackRate(t.audioRate),t.mediaControls!=null&&(this.getMediaElement().controls=t.mediaControls)}registerPlugin(t){return t._init(this),this.plugins.push(t),this.subscriptions.push(t.once("destroy",()=>{this.plugins=this.plugins.filter(e=>e!==t)})),t}getWrapper(){return this.renderer.getWrapper()}getWidth(){return this.renderer.getWidth()}getScroll(){return this.renderer.getScroll()}setScroll(t){return this.renderer.setScroll(t)}setScrollTime(t){let e=t/this.getDuration();this.renderer.setScrollPercentage(e)}getActivePlugins(){return this.plugins}loadAudio(t,e,r,o){return hr(this,void 0,void 0,function*(){var s;if(this.emit("load",t),!this.options.media&&this.isPlaying()&&this.pause(),this.decodedData=null,!e&&!r){let a=this.options.fetchParams||{};window.AbortController&&!a.signal&&(this.abortController=new AbortController,a.signal=(s=this.abortController)===null||s===void 0?void 0:s.signal);let l=u=>this.emit("loading",u);e=yield Yhe.fetchBlob(t,l,a)}this.setSrc(t,e);let i=yield new Promise(a=>{let l=o||this.getDuration();l?a(l):this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata",()=>a(this.getDuration()),{once:!0}))});if(!t&&!e){let a=this.getMediaElement();a instanceof KC&&(a.duration=i)}if(r)this.decodedData=KH.createBuffer(r,i||0);else if(e){let a=yield e.arrayBuffer();this.decodedData=yield KH.decode(a,this.options.sampleRate)}this.decodedData&&(this.emit("decode",this.getDuration()),this.renderer.render(this.decodedData)),this.emit("ready",this.getDuration())})}load(t,e,r){return hr(this,void 0,void 0,function*(){try{return yield this.loadAudio(t,void 0,e,r)}catch(o){throw this.emit("error",o),o}})}loadBlob(t,e,r){return hr(this,void 0,void 0,function*(){try{return yield this.loadAudio("",t,e,r)}catch(o){throw this.emit("error",o),o}})}zoom(t){if(!this.decodedData)throw new Error("No audio loaded");this.renderer.zoom(t),this.emit("zoom",t)}getDecodedData(){return this.decodedData}exportPeaks({channels:t=2,maxLength:e=8e3,precision:r=1e4}={}){if(!this.decodedData)throw new Error("The audio has not been decoded yet");let o=Math.min(t,this.decodedData.numberOfChannels),s=[];for(let i=0;i<o;i++){let a=this.decodedData.getChannelData(i),l=[],u=a.length/e;for(let c=0;c<e;c++){let p=a.slice(Math.floor(c*u),Math.ceil((c+1)*u)),f=0;for(let d=0;d<p.length;d++){let h=p[d];Math.abs(h)>Math.abs(f)&&(f=h)}l.push(Math.round(f*r)/r)}s.push(l)}return s}getDuration(){let t=super.getDuration()||0;return t!==0&&t!==1/0||!this.decodedData||(t=this.decodedData.duration),t}toggleInteraction(t){this.options.interact=t}setTime(t){super.setTime(t),this.updateProgress(t),this.emit("timeupdate",t)}seekTo(t){let e=this.getDuration()*t;this.setTime(e)}playPause(){return hr(this,void 0,void 0,function*(){return this.isPlaying()?this.pause():this.play()})}stop(){this.pause(),this.setTime(0)}skip(t){this.setTime(this.getCurrentTime()+t)}empty(){this.load("",[[0]],.001)}setMediaElement(t){this.unsubscribePlayerEvents(),super.setMediaElement(t),this.initPlayerEvents()}exportImage(){return hr(this,arguments,void 0,function*(t="image/png",e=1,r="dataURL"){return this.renderer.exportImage(t,e,r)})}destroy(){var t;this.emit("destroy"),(t=this.abortController)===null||t===void 0||t.abort(),this.plugins.forEach(e=>e.destroy()),this.subscriptions.forEach(e=>e()),this.unsubscribePlayerEvents(),this.timer.destroy(),this.renderer.destroy(),super.destroy()}};ru.BasePlugin=class extends zc{constructor(n){super(),this.subscriptions=[],this.options=n}onInit(){}_init(n){this.wavesurfer=n,this.onInit()}destroy(){this.emit("destroy"),this.subscriptions.forEach(n=>n())}},ru.dom=Xhe;function Qhe(n,t,e,r){return new(e||(e=Promise))(function(o,s){function i(u){try{l(r.next(u))}catch(c){s(c)}}function a(u){try{l(r.throw(u))}catch(c){s(c)}}function l(u){var c;u.done?o(u.value):(c=u.value,c instanceof e?c:new e(function(p){p(c)})).then(i,a)}l((r=r.apply(n,t||[])).next())})}var K1=class{constructor(){this.listeners={}}on(t,e,r){if(this.listeners[t]||(this.listeners[t]=new Set),this.listeners[t].add(e),r?.once){let o=()=>{this.un(t,o),this.un(t,e)};return this.on(t,o),o}return()=>this.un(t,e)}un(t,e){var r;(r=this.listeners[t])===null||r===void 0||r.delete(e)}once(t,e){return this.on(t,e,{once:!0})}unAll(){this.listeners={}}emit(t,...e){this.listeners[t]&&this.listeners[t].forEach(r=>r(...e))}},X1=class extends K1{constructor(t){super(),this.subscriptions=[],this.options=t}onInit(){}_init(t){this.wavesurfer=t,this.onInit()}destroy(){this.emit("destroy"),this.subscriptions.forEach(t=>t())}};function ZH(n,t){let e=t.xmlns?document.createElementNS(t.xmlns,n):document.createElement(n);for(let[r,o]of Object.entries(t))if(r==="children")for(let[s,i]of Object.entries(t))typeof i=="string"?e.appendChild(document.createTextNode(i)):e.appendChild(ZH(s,i));else r==="style"?Object.assign(e.style,o):r==="textContent"?e.textContent=o:e.setAttribute(r,o.toString());return e}function q1(n,t,e){let r=ZH(n,t||{});return e?.appendChild(r),r}function Jhe(n,t,e,r){switch(this.bufferSize=n,this.sampleRate=t,this.bandwidth=2/n*(t/2),this.sinTable=new Float32Array(n),this.cosTable=new Float32Array(n),this.windowValues=new Float32Array(n),this.reverseTable=new Uint32Array(n),this.peakBand=0,this.peak=0,e){case"bartlett":for(o=0;o<n;o++)this.windowValues[o]=2/(n-1)*((n-1)/2-Math.abs(o-(n-1)/2));break;case"bartlettHann":for(o=0;o<n;o++)this.windowValues[o]=.62-.48*Math.abs(o/(n-1)-.5)-.38*Math.cos(2*Math.PI*o/(n-1));break;case"blackman":for(r=r||.16,o=0;o<n;o++)this.windowValues[o]=(1-r)/2-.5*Math.cos(2*Math.PI*o/(n-1))+r/2*Math.cos(4*Math.PI*o/(n-1));break;case"cosine":for(o=0;o<n;o++)this.windowValues[o]=Math.cos(Math.PI*o/(n-1)-Math.PI/2);break;case"gauss":for(r=r||.25,o=0;o<n;o++)this.windowValues[o]=Math.pow(Math.E,-.5*Math.pow((o-(n-1)/2)/(r*(n-1)/2),2));break;case"hamming":for(o=0;o<n;o++)this.windowValues[o]=.54-.46*Math.cos(2*Math.PI*o/(n-1));break;case"hann":case void 0:for(o=0;o<n;o++)this.windowValues[o]=.5*(1-Math.cos(2*Math.PI*o/(n-1)));break;case"lanczoz":for(o=0;o<n;o++)this.windowValues[o]=Math.sin(Math.PI*(2*o/(n-1)-1))/(Math.PI*(2*o/(n-1)-1));break;case"rectangular":for(o=0;o<n;o++)this.windowValues[o]=1;break;case"triangular":for(o=0;o<n;o++)this.windowValues[o]=2/n*(n/2-Math.abs(o-(n-1)/2));break;default:throw Error("No such window function '"+e+"'")}for(var o,s=1,i=n>>1;s<n;){for(o=0;o<s;o++)this.reverseTable[o+s]=this.reverseTable[o]+i;s<<=1,i>>=1}for(o=0;o<n;o++)this.sinTable[o]=Math.sin(-Math.PI/o),this.cosTable[o]=Math.cos(-Math.PI/o);this.calculateSpectrum=function(a){var l,u,c,p=this.bufferSize,f=this.cosTable,d=this.sinTable,h=this.reverseTable,g=new Float32Array(p),m=new Float32Array(p),y=2/this.bufferSize,x=Math.sqrt,v=new Float32Array(p/2),w=Math.floor(Math.log(p)/Math.LN2);if(Math.pow(2,w)!==p)throw"Invalid buffer size, must be a power of 2.";if(p!==a.length)throw"Supplied buffer is not the same size as defined FFT. FFT Size: "+p+" Buffer Size: "+a.length;for(var S,k,A,_,F,$,V,U,W=1,G=0;G<p;G++)g[G]=a[h[G]]*this.windowValues[h[G]],m[G]=0;for(;W<p;){S=f[W],k=d[W],A=1,_=0;for(var H=0;H<W;H++){for(G=H;G<p;)$=A*g[F=G+W]-_*m[F],V=A*m[F]+_*g[F],g[F]=g[G]-$,m[F]=m[G]-V,g[G]+=$,m[G]+=V,G+=W<<1;A=(U=A)*S-_*k,_=U*k+_*S}W<<=1}G=0;for(var K=p/2;G<K;G++)(c=y*x((l=g[G])*l+(u=m[G])*u))>this.peak&&(this.peakBand=G,this.peak=c),v[G]=c;return v}}var hh=class n extends X1{static create(t){return new n(t||{})}constructor(t){if(super(t),this.frequenciesDataUrl=t.frequenciesDataUrl,this.container=typeof t.container=="string"?document.querySelector(t.container):t.container,t.colorMap&&typeof t.colorMap!="string"){if(t.colorMap.length<256)throw new Error("Colormap must contain 256 elements");for(let e=0;e<t.colorMap.length;e++)if(t.colorMap[e].length!==4)throw new Error("ColorMap entries must contain 4 values");this.colorMap=t.colorMap}else switch(this.colorMap=t.colorMap||"roseus",this.colorMap){case"gray":this.colorMap=[];for(let e=0;e<256;e++){let r=(255-e)/256;this.colorMap.push([r,r,r,1])}break;case"igray":this.colorMap=[];for(let e=0;e<256;e++){let r=e/256;this.colorMap.push([r,r,r,1])}break;case"roseus":this.colorMap=[[.004528,.004341,.004307,1],[.005625,.006156,.00601,1],[.006628,.008293,.008161,1],[.007551,.010738,.01079,1],[.008382,.013482,.013941,1],[.009111,.01652,.017662,1],[.009727,.019846,.022009,1],[.010223,.023452,.027035,1],[.010593,.027331,.032799,1],[.010833,.031475,.039361,1],[.010941,.035875,.046415,1],[.010918,.04052,.053597,1],[.010768,.045158,.060914,1],[.010492,.049708,.068367,1],[.010098,.054171,.075954,1],[.009594,.058549,.083672,1],[.008989,.06284,.091521,1],[.008297,.067046,.099499,1],[.00753,.071165,.107603,1],[.006704,.075196,.11583,1],[.005838,.07914,.124178,1],[.004949,.082994,.132643,1],[.004062,.086758,.141223,1],[.003198,.09043,.149913,1],[.002382,.09401,.158711,1],[.001643,.097494,.167612,1],[.001009,.100883,.176612,1],[514e-6,.104174,.185704,1],[187e-6,.107366,.194886,1],[66e-6,.110457,.204151,1],[186e-6,.113445,.213496,1],[587e-6,.116329,.222914,1],[.001309,.119106,.232397,1],[.002394,.121776,.241942,1],[.003886,.124336,.251542,1],[.005831,.126784,.261189,1],[.008276,.12912,.270876,1],[.011268,.131342,.280598,1],[.014859,.133447,.290345,1],[.0191,.135435,.300111,1],[.024043,.137305,.309888,1],[.029742,.139054,.319669,1],[.036252,.140683,.329441,1],[.043507,.142189,.339203,1],[.050922,.143571,.348942,1],[.058432,.144831,.358649,1],[.066041,.145965,.368319,1],[.073744,.146974,.377938,1],[.081541,.147858,.387501,1],[.089431,.148616,.396998,1],[.097411,.149248,.406419,1],[.105479,.149754,.415755,1],[.113634,.150134,.424998,1],[.121873,.150389,.434139,1],[.130192,.150521,.443167,1],[.138591,.150528,.452075,1],[.147065,.150413,.460852,1],[.155614,.150175,.469493,1],[.164232,.149818,.477985,1],[.172917,.149343,.486322,1],[.181666,.148751,.494494,1],[.190476,.148046,.502493,1],[.199344,.147229,.510313,1],[.208267,.146302,.517944,1],[.217242,.145267,.52538,1],[.226264,.144131,.532613,1],[.235331,.142894,.539635,1],[.24444,.141559,.546442,1],[.253587,.140131,.553026,1],[.262769,.138615,.559381,1],[.271981,.137016,.5655,1],[.281222,.135335,.571381,1],[.290487,.133581,.577017,1],[.299774,.131757,.582404,1],[.30908,.129867,.587538,1],[.318399,.12792,.592415,1],[.32773,.125921,.597032,1],[.337069,.123877,.601385,1],[.346413,.121793,.605474,1],[.355758,.119678,.609295,1],[.365102,.11754,.612846,1],[.374443,.115386,.616127,1],[.383774,.113226,.619138,1],[.393096,.111066,.621876,1],[.402404,.108918,.624343,1],[.411694,.106794,.62654,1],[.420967,.104698,.628466,1],[.430217,.102645,.630123,1],[.439442,.100647,.631513,1],[.448637,.098717,.632638,1],[.457805,.096861,.633499,1],[.46694,.095095,.6341,1],[.47604,.093433,.634443,1],[.485102,.091885,.634532,1],[.494125,.090466,.63437,1],[.503104,.08919,.633962,1],[.512041,.088067,.633311,1],[.520931,.087108,.63242,1],[.529773,.086329,.631297,1],[.538564,.085738,.629944,1],[.547302,.085346,.628367,1],[.555986,.085162,.626572,1],[.564615,.08519,.624563,1],[.573187,.085439,.622345,1],[.581698,.085913,.619926,1],[.590149,.086615,.617311,1],[.598538,.087543,.614503,1],[.606862,.0887,.611511,1],[.61512,.090084,.608343,1],[.623312,.09169,.605001,1],[.631438,.093511,.601489,1],[.639492,.095546,.597821,1],[.647476,.097787,.593999,1],[.655389,.100226,.590028,1],[.66323,.102856,.585914,1],[.670995,.105669,.581667,1],[.678686,.108658,.577291,1],[.686302,.111813,.57279,1],[.69384,.115129,.568175,1],[.7013,.118597,.563449,1],[.708682,.122209,.558616,1],[.715984,.125959,.553687,1],[.723206,.12984,.548666,1],[.730346,.133846,.543558,1],[.737406,.13797,.538366,1],[.744382,.142209,.533101,1],[.751274,.146556,.527767,1],[.758082,.151008,.522369,1],[.764805,.155559,.516912,1],[.771443,.160206,.511402,1],[.777995,.164946,.505845,1],[.784459,.169774,.500246,1],[.790836,.174689,.494607,1],[.797125,.179688,.488935,1],[.803325,.184767,.483238,1],[.809435,.189925,.477518,1],[.815455,.19516,.471781,1],[.821384,.200471,.466028,1],[.827222,.205854,.460267,1],[.832968,.211308,.454505,1],[.838621,.216834,.448738,1],[.844181,.222428,.442979,1],[.849647,.22809,.43723,1],[.855019,.233819,.431491,1],[.860295,.239613,.425771,1],[.865475,.245471,.420074,1],[.870558,.251393,.414403,1],[.875545,.25738,.408759,1],[.880433,.263427,.403152,1],[.885223,.269535,.397585,1],[.889913,.275705,.392058,1],[.894503,.281934,.386578,1],[.898993,.288222,.381152,1],[.903381,.294569,.375781,1],[.907667,.300974,.370469,1],[.911849,.307435,.365223,1],[.915928,.313953,.360048,1],[.919902,.320527,.354948,1],[.923771,.327155,.349928,1],[.927533,.333838,.344994,1],[.931188,.340576,.340149,1],[.934736,.347366,.335403,1],[.938175,.354207,.330762,1],[.941504,.361101,.326229,1],[.944723,.368045,.321814,1],[.947831,.375039,.317523,1],[.950826,.382083,.313364,1],[.953709,.389175,.309345,1],[.956478,.396314,.305477,1],[.959133,.403499,.301766,1],[.961671,.410731,.298221,1],[.964093,.418008,.294853,1],[.966399,.425327,.291676,1],[.968586,.43269,.288696,1],[.970654,.440095,.285926,1],[.972603,.44754,.28338,1],[.974431,.455025,.281067,1],[.976139,.462547,.279003,1],[.977725,.470107,.277198,1],[.979188,.477703,.275666,1],[.980529,.485332,.274422,1],[.981747,.492995,.273476,1],[.98284,.50069,.272842,1],[.983808,.508415,.272532,1],[.984653,.516168,.27256,1],[.985373,.523948,.272937,1],[.985966,.531754,.273673,1],[.986436,.539582,.274779,1],[.98678,.547434,.276264,1],[.986998,.555305,.278135,1],[.987091,.563195,.280401,1],[.987061,.5711,.283066,1],[.986907,.579019,.286137,1],[.986629,.58695,.289615,1],[.986229,.594891,.293503,1],[.985709,.602839,.297802,1],[.985069,.610792,.302512,1],[.98431,.618748,.307632,1],[.983435,.626704,.313159,1],[.982445,.634657,.319089,1],[.981341,.642606,.32542,1],[.98013,.650546,.332144,1],[.978812,.658475,.339257,1],[.977392,.666391,.346753,1],[.97587,.67429,.354625,1],[.974252,.68217,.362865,1],[.972545,.690026,.371466,1],[.97075,.697856,.380419,1],[.968873,.705658,.389718,1],[.966921,.713426,.399353,1],[.964901,.721157,.409313,1],[.962815,.728851,.419594,1],[.960677,.7365,.430181,1],[.95849,.744103,.44107,1],[.956263,.751656,.452248,1],[.954009,.759153,.463702,1],[.951732,.766595,.475429,1],[.949445,.773974,.487414,1],[.947158,.781289,.499647,1],[.944885,.788535,.512116,1],[.942634,.795709,.524811,1],[.940423,.802807,.537717,1],[.938261,.809825,.550825,1],[.936163,.81676,.564121,1],[.934146,.823608,.577591,1],[.932224,.830366,.59122,1],[.930412,.837031,.604997,1],[.928727,.843599,.618904,1],[.927187,.850066,.632926,1],[.925809,.856432,.647047,1],[.92461,.862691,.661249,1],[.923607,.868843,.675517,1],[.92282,.874884,.689832,1],[.922265,.880812,.704174,1],[.921962,.886626,.718523,1],[.92193,.892323,.732859,1],[.922183,.897903,.747163,1],[.922741,.903364,.76141,1],[.92362,.908706,.77558,1],[.924837,.913928,.789648,1],[.926405,.919031,.80359,1],[.92834,.924015,.817381,1],[.930655,.928881,.830995,1],[.93336,.933631,.844405,1],[.936466,.938267,.857583,1],[.939982,.942791,.870499,1],[.943914,.947207,.883122,1],[.948267,.951519,.895421,1],[.953044,.955732,.907359,1],[.958246,.959852,.918901,1],[.963869,.963887,.930004,1],[.969909,.967845,.940623,1],[.976355,.971737,.950704,1],[.983195,.97558,.960181,1],[.990402,.979395,.968966,1],[.99793,.983217,.97692,1]];break;default:throw Error("No such colormap '"+this.colorMap+"'")}this.fftSamples=t.fftSamples||512,this.noverlap=t.noverlap||.75*this.fftSamples,this.windowFunc=t.windowFunc||"hann",this.alpha=t.alpha,this.frequencyMin=t.frequencyMin||0,this.frequencyMax=t.frequencyMax||0,this.gainDB=t.gainDB||20,this.rangeDB=t.rangeDB||80,this.scale=t.scale||"mel",this.numMelFilters=t.numMelFilters||this.fftSamples/8,this.scale=="mel"?(this.height=t.height||this.numMelFilters,this.height=Math.min(this.height,this.numMelFilters)):(this.height=t.height||this.fftSamples/2,this.height=Math.min(this.height,this.fftSamples/2)),this.createWrapper(),this.createCanvas()}onInit(){this.container=this.container||this.wavesurfer.getWrapper(),this.container.appendChild(this.wrapper),this.wavesurfer.options.fillParent&&Object.assign(this.wrapper.style,{width:"100%",overflowX:"hidden",overflowY:"hidden"}),this.subscriptions.push(this.wavesurfer.on("redraw",()=>this.render()))}destroy(){this.unAll(),this.wavesurfer.un("ready",this._onReady),this.wavesurfer.un("redraw",this._onRender),this.wavesurfer=null,this.util=null,this.options=null,this.wrapper&&(this.wrapper.remove(),this.wrapper=null),super.destroy()}loadFrequenciesData(t){return Qhe(this,void 0,void 0,function*(){let e=yield fetch(t);if(!e.ok)throw new Error("Unable to fetch frequencies data");let r=yield e.json();this.drawSpectrogram(r)})}createWrapper(){this.wrapper=q1("div",{style:{display:"block",position:"relative",userSelect:"none"}}),this.options.labels&&(this.labelsEl=q1("canvas",{part:"spec-labels",style:{position:"absolute",zIndex:9,width:"55px",height:"100%"}},this.wrapper)),this.wrapper.addEventListener("click",this._onWrapperClick)}createCanvas(){this.canvas=q1("canvas",{style:{position:"absolute",left:0,top:0,width:"100%",height:"100%",zIndex:4}},this.wrapper),this.spectrCc=this.canvas.getContext("2d")}render(){var t;if(this.frequenciesDataUrl)this.loadFrequenciesData(this.frequenciesDataUrl);else{let e=(t=this.wavesurfer)===null||t===void 0?void 0:t.getDecodedData();e&&this.drawSpectrogram(this.getFrequencies(e))}}drawSpectrogram(t){isNaN(t[0][0])||(t=[t]),this.wrapper.style.height=this.height*t.length+"px",this.width=this.wavesurfer.getWrapper().offsetWidth,this.canvas.width=this.width,this.canvas.height=this.height*t.length;let e=this.spectrCc,r=this.height,o=this.width,s=this.buffer.sampleRate/2,i=this.frequencyMin,a=this.frequencyMax;if(e){for(let l=0;l<t.length;l++){let u=this.resample(t[l]),c=new ImageData(o,r);for(let p=0;p<u.length;p++)for(let f=0;f<u[p].length;f++){let d=this.colorMap[u[p][f]],h=4*((r-f)*o+p);c.data[h]=255*d[0],c.data[h+1]=255*d[1],c.data[h+2]=255*d[2],c.data[h+3]=255*d[3]}createImageBitmap(c).then(p=>{e.drawImage(p,0,r*(1-a/s),o,r*(a-i)/s,0,r*l,o,r)})}this.options.labels&&this.loadLabels(this.options.labelsBackground,"12px","12px","",this.options.labelsColor,this.options.labelsHzColor||this.options.labelsColor,"center","#specLabels",t.length),this.emit("ready")}}hzToMel(t){return 2595*Math.log10(1+t/700)}melToHz(t){return 700*(Math.pow(10,t/2595)-1)}createMelFilterBank(t,e){let r=this.hzToMel(0),o=this.hzToMel(e/2),s=Array.from({length:t},()=>Array(this.fftSamples/2+1).fill(0)),i=e/this.fftSamples;for(let a=0;a<t;a++){let l=this.melToHz(r+a/t*(o-r)),u=Math.floor(l/i),c=u*i,p=(l-c)/((u+1)*i-c);s[a][u]=1-p,s[a][u+1]=p}return s}applyMelFilterBank(t,e){let r=e.length,o=Array(r).fill(0);for(let s=0;s<r;s++)for(let i=0;i<t.length;i++)o[s]+=t[i]*e[s][i];return o}getFrequencies(t){var e,r;let o=this.fftSamples,s=((e=this.options.splitChannels)!==null&&e!==void 0?e:!((r=this.wavesurfer)===null||r===void 0)&&r.options.splitChannels)?t.numberOfChannels:1;if(this.frequencyMax=this.frequencyMax||t.sampleRate/2,!t)return;this.buffer=t;let i=t.sampleRate,a=[],l=this.noverlap;if(!l){let p=t.length/this.canvas.width;l=Math.max(0,Math.round(o-p))}let u=new Jhe(o,i,this.windowFunc,this.alpha),c=this.createMelFilterBank(this.numMelFilters,i);for(let p=0;p<s;p++){let f=t.getChannelData(p),d=[],h=0;for(;h+o<f.length;){let g=f.slice(h,h+o),m=new Uint8Array(o/2),y=u.calculateSpectrum(g);this.scale=="mel"&&(y=this.applyMelFilterBank(y,c));for(let x=0;x<o/2;x++){let v=20*Math.log10(y[x]);v<-this.rangeDB?m[x]=0:v>-this.gainDB?m[x]=255:m[x]=(v+this.gainDB)/this.rangeDB*255+256}d.push(m),h+=o-l}a.push(d)}return a}freqType(t){return t>=1e3?(t/1e3).toFixed(1):Math.round(t)}unitType(t){return t>=1e3?"KHz":"Hz"}loadLabels(t,e,r,o,s,i,a,l,u){t=t||"rgba(68,68,68,0)",e=e||"12px",r=r||"12px",o=o||"Helvetica",s=s||"#fff",i=i||"#fff",a=a||"center";let c=this.height||512,p=c/256*5,f=this.frequencyMin,d=(this.frequencyMax-f)/p,h=this.labelsEl.getContext("2d"),g=window.devicePixelRatio;if(this.labelsEl.height=this.height*u*g,this.labelsEl.width=55*g,h.scale(g,g),h)for(let m=0;m<u;m++){let y;for(h.fillStyle=t,h.fillRect(0,m*c,55,(1+m)*c),h.fill(),y=0;y<=p;y++){h.textAlign=a,h.textBaseline="middle";let x=f+d*y,v=this.freqType(x),w=this.unitType(x),S=16,k;k=y==0?(1+m)*c+y-10:(1+m)*c-50*y+2,this.scale=="mel"&&x!=0&&(k=k*this.hzToMel(x)/x),h.fillStyle=i,h.font=r+" "+o,h.fillText(w,S+24,k),h.fillStyle=s,h.font=e+" "+o,h.fillText(v,S,k)}}}resample(t){let e=this.width,r=[],o=1/t.length,s=1/e,i;for(i=0;i<e;i++){let a=new Array(t[0].length),l;for(l=0;l<t.length;l++){let p=l*o,f=p+o,d=i*s,h=d+s,g=Math.max(0,Math.min(f,h)-Math.max(p,d)),m;if(g>0)for(m=0;m<t[0].length;m++)a[m]==null&&(a[m]=0),a[m]+=g/s*t[l][m]}let u=new Uint8Array(t[0].length),c;for(c=0;c<t[0].length;c++)u[c]=a[c];r.push(u)}return r}};var eme=["waveform"],tme=["spectrogram"],nme=["audioPlayer"],QH=(()=>{let t=class t{constructor(){this.tensorData=[],this.sampleRate=44100,this.noise=null,this.zoomLevel=20,this.isPlaying=!1,this.frame_size=[1049344,2],this.currentContinuousTensor=nt(this.frame_size),this.nextContinuousTensor=nt(this.frame_size),this.last_right_anchor=Pt([1,128]),this.noiseg=Pt([1,64])}selectFile(){document.querySelector('input[type="file"]').click()}onFileSelected(r){let o=r.target.files[0];if(o){let s=new FileReader;s.onload=i=>z(this,null,function*(){let a=JSON.parse(i.target.result);this.loadTensorFromJSON(a)}),s.readAsText(o)}}loadTensorFromJSON(r){let{data:o,shape:s}=r;this.noise=ln(o,s),console.log("Tensor loaded:",this.noise),this.noise.print()}ngOnDestroy(){this.waveSurfer&&this.waveSurfer.destroy()}startInferenceStereo(){return z(this,null,function*(){let r=yield Nc("./assets/models/stereo_model_web/model.json"),o=nt([1,1]),s=yield r.executeAsync(o);console.log("res",s.shape),this.tensorData=yield s.array(),this.wavBlob=yield this.tensorToAudioBlob(s,this.sampleRate);let i=URL.createObjectURL(this.wavBlob);this.waveSurfer&&this.waveSurfer.destroy(),this.waveSurfer=ru.create({container:this.waveformDiv.nativeElement,waveColor:"violet",progressColor:"purple",normalize:!0,height:200,minPxPerSec:this.zoomLevel,autoCenter:!0,plugins:[hh.create({container:this.spectrogramDiv.nativeElement,labels:!0})]}),this.waveSurfer.load(i),this.waveSurfer.on("play",()=>{this.isPlaying=!0}),this.waveSurfer.on("pause",()=>{this.isPlaying=!1}),this.waveSurfer.on("finish",()=>{this.isPlaying=!1,this.waveSurfer.seekTo(0)}),console.log("finished")})}startInferenceWaveform(){return z(this,null,function*(){let r=yield Nc("./assets/models/noise_model_web/model.json"),o=yield Nc("./assets/models/waveform_model_web_fac_6/model.json"),i=Math.floor(120/23)+1;console.log("fac",i);let a=this.noise;if(a==null){console.log("No noise tensor loaded, generating one...");let c=nt([1,1]);a=yield r.executeAsync(c)}console.log("noise_predictions",a.shape),console.log("noise_predictions",a);let l=yield o.executeAsync(a);console.log("Predictions:",l),console.log("res",l.shape),this.tensorData=yield l.array(),this.wavBlob=yield this.tensorToAudioBlob(l,this.sampleRate);let u=URL.createObjectURL(this.wavBlob);this.waveSurfer&&this.waveSurfer.destroy(),this.waveSurfer=ru.create({container:this.waveformDiv.nativeElement,waveColor:"violet",progressColor:"purple",normalize:!0,height:200,minPxPerSec:this.zoomLevel,autoCenter:!0,plugins:[hh.create({container:this.spectrogramDiv.nativeElement,labels:!0})]}),this.waveSurfer.load(u),this.waveSurfer.on("play",()=>{this.isPlaying=!0}),this.waveSurfer.on("pause",()=>{this.isPlaying=!1}),this.waveSurfer.on("finish",()=>{this.isPlaying=!1,this.waveSurfer.seekTo(0)}),console.log("finished")})}playPause(){this.waveSurfer&&this.waveSurfer.playPause()}stop(){this.waveSurfer&&(this.waveSurfer.stop(),this.isPlaying=!1)}downloadTensorAsJson(){let r=JSON.stringify(this.tensorData),o=new Blob([r],{type:"application/json"}),s=window.URL.createObjectURL(o),i=document.createElement("a");i.href=s,i.download="tensor.json",document.body.appendChild(i),i.click(),document.body.removeChild(i),window.URL.revokeObjectURL(s)}downloadWav(){if(!this.wavBlob){console.error("WAV Blob is not available.");return}let r=window.URL.createObjectURL(this.wavBlob),o=document.createElement("a");o.href=r,o.download="audio.wav",document.body.appendChild(o),o.click(),document.body.removeChild(o),window.URL.revokeObjectURL(r)}tensorToAudioBlob(r,o){return z(this,null,function*(){let s=yield r.data(),i=new(window.AudioContext||window.webkitAudioContext),a=r.shape[1]||1,l=s.length/a;this.audioBuffer=i.createBuffer(a,l,o);for(let u=0;u<a;u++){let c=this.audioBuffer.getChannelData(u);for(let p=0;p<l;p++)c[p]=s[p*a+u]}return this.audioBufferToWav(this.audioBuffer)})}audioBufferToWav(r){let o=r.numberOfChannels,s=r.length*o*2+44,i=new ArrayBuffer(s),a=new DataView(i),l=[],u=r.sampleRate,c=16,p=0,f=0;function d(m){a.setUint16(f,m,!0),f+=2}function h(m){a.setUint32(f,m,!0),f+=4}h(1179011410),h(s-8),h(1163280727),h(544501094),h(16),d(1),d(o),h(u),h(u*o*c/8),d(o*c/8),d(c),h(1635017060),h(s-f-4);for(let m=0;m<o;m++)l.push(r.getChannelData(m));let g=r.length;for(;f<s;){for(let m=0;m<o;m++){let y=Math.max(-1,Math.min(1,l[m][p]));y=y<0?y*32768:y*32767,a.setInt16(f,y,!0),f+=2}p++}return new Blob([i],{type:"audio/wav"})}startContinuousGeneration(){return z(this,null,function*(){this.genNoiseModel=yield Nc("./assets/models/continous_noise_model_web/model.json"),this.genWaveformModel=yield Nc("./assets/models/waveform_model_web/model.json");for(let r=0;r<3;r++){console.log("i",r);let o=this.genNoiseModel.execute([this.noiseg,this.last_right_anchor]);console.log("res",o);let s=o[1];if(this.last_right_anchor=o[0],console.log(s.shape),console.log(this.last_right_anchor.shape),r>0){let i=this.genWaveformModel.execute(s);console.log("Predictions:",i),console.log("res",i.shape),this.currentContinuousTensor=this.nextContinuousTensor,this.nextContinuousTensor=i}}yield this.startPlaying(this.currentContinuousTensor)})}startPlaying(r){return z(this,null,function*(){this.wavBlob=yield this.tensorToAudioBlob(r,this.sampleRate);let o=URL.createObjectURL(this.wavBlob);this.waveSurfer||(this.waveSurfer=ru.create({container:this.waveformDiv.nativeElement,waveColor:"violet",progressColor:"purple",normalize:!0,height:200,minPxPerSec:this.zoomLevel,autoCenter:!0,plugins:[hh.create({container:this.spectrogramDiv.nativeElement,labels:!0})]}),this.waveSurfer.on("play",()=>{this.isPlaying=!0}),this.waveSurfer.on("pause",()=>{this.isPlaying=!1}),this.waveSurfer.on("finish",()=>z(this,null,function*(){yield this.startPlaying(this.nextContinuousTensor),this.waveSurfer.seekTo(0),yield this.waveSurfer.play(),this.generateNextPart()}))),this.waveSurfer.load(o),this.waveSurfer.on("ready",()=>z(this,null,function*(){yield this.waveSurfer.play()})),console.log("finished")})}generateNextPart(){let r=this.genNoiseModel.execute([this.noiseg,this.last_right_anchor]);console.log("res",r);let o=r[1];this.last_right_anchor=r[0],console.log(o.shape),console.log(this.last_right_anchor.shape);let s=this.genWaveformModel.execute(o);console.log("Predictions:",s),console.log("res",s.shape),this.currentContinuousTensor=this.nextContinuousTensor,this.nextContinuousTensor=s}};t.\u0275fac=function(o){return new(o||t)},t.\u0275cmp=dy({type:t,selectors:[["app-root"]],viewQuery:function(o,s){if(o&1&&(Iy(eme,5),Iy(tme,5),Iy(nme,5)),o&2){let i;$h(i=Ph())&&(s.waveformDiv=i.first),$h(i=Ph())&&(s.spectrogramDiv=i.first),$h(i=Ph())&&(s.audioPlayer=i.first)}},standalone:!0,features:[Ty],decls:13,vars:1,consts:[["fileInput",""],["waveform",""],["spectrogram",""],[1,"controls"],[3,"click"],["type","file","accept",".json","hidden","",3,"change"],[1,"waveform"],[1,"spectrogram"]],template:function(o,s){if(o&1){let i=dR();Cu(0,"div",3)(1,"button",4),Su("click",function(){return Oh(i),Mh(s.startContinuousGeneration())}),Sy(2,"Start Continuous Generation"),Iu(),Cu(3,"input",5,0),Su("change",function(l){return Oh(i),Mh(s.onFileSelected(l))}),Iu(),Cu(5,"button",4),Su("click",function(){return Oh(i),Mh(s.playPause())}),Sy(6),Iu(),Cu(7,"button",4),Su("click",function(){return Oh(i),Mh(s.stop())}),Sy(8,"Stop"),Iu()(),Fh(9,"div",6,1)(11,"div",7,2)}o&2&&(BA(6),QI(" ",s.isPlaying?"Pause":"Play"," "))},styles:[".waveform-container[_ngcontent-%COMP%], .spectrogram-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:stretch;position:relative;width:100%;overflow:hidden;margin-bottom:20px}.waveform[_ngcontent-%COMP%], .spectrogram[_ngcontent-%COMP%]{flex:1;overflow:auto}.y-axis[_ngcontent-%COMP%]{position:absolute;left:0;top:0;bottom:0;width:50px;display:flex;align-items:center;justify-content:center;writing-mode:vertical-rl;text-orientation:mixed;background-color:#f0f0f0;z-index:1}.x-axis[_ngcontent-%COMP%]{text-align:center;margin-top:5px}.controls[_ngcontent-%COMP%]{display:flex;gap:10px;margin-bottom:20px}.controls[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:5px 10px}.waveform-container[_ngcontent-%COMP%]   .waveform[_ngcontent-%COMP%], .spectrogram-container[_ngcontent-%COMP%]   .spectrogram[_ngcontent-%COMP%]{margin-left:50px}.waveform-container[_ngcontent-%COMP%], .spectrogram-container[_ngcontent-%COMP%]{height:200px}.waveform[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%], .spectrogram[_ngcontent-%COMP%]   canvas[_ngcontent-%COMP%]{width:100%!important}audio[_ngcontent-%COMP%]{margin-top:20px;width:100%}"]});let n=t;return n})();GR(QH,D_).catch(n=>console.error(n));
